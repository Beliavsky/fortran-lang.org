{
    "name": "fortran-lang/fpm",
    "issues": [
        {
            "number": 150,
            "user": "everythingfunctional",
            "date": "2020-07-25 20:13:20+00:00",
            "title": "Propogate exit codes from tests and executables",
            "text": "Fix #143",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-25 21:06:41+00:00",
                    "text": "+1 to merge. I don't have time right now to test it, but the change looks good.\n\nEventually we have to add tests for all these things.\n\u2026\nOn Sat, Jul 25, 2020, at 2:47 PM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#150 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWE4ZBYFMVPNLA4BNKLR5NAGRANCNFSM4PHTX5DA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-26 20:53:23+00:00",
                    "text": "I tried it out a couple of different ways and it worked, so I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 149,
            "user": "milancurcic",
            "date": "2020-07-24 18:18:32+00:00",
            "title": "TOML parser",
            "text": "Part of #136\nI found 2, both support TOML v0.5 spec:\n\ntoml-f which is pure Fortran, but unfortunately GPLv3-licensed. We could ask the author to offer a more permissive license beside GPL.\nf_tomlc99 which interfaces a C parser. MIT-licensed.\n\nSo each presents an integration challenge.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-24 19:45:25+00:00",
                    "text": "In terms of easiness of use, we should try to stick to pure Fortran packages for fpm dependencies, since the non Fortran dependencies must be built somehow on all platforms for all users, and that can get messy --- we discussed just loading such packages from Conda as binaries on all platforms, which I think is preferable, but I was hoping to integrate with Conda in the Fortran fpm, and not worry about it for haskell fpm.\nAs such, we can probably quite easily improve haskell fpm to be able to compile C or C++ files inside an fpm package if we have to. But 3rd party non-Fortran dependencies will cause more issues I feel.\nConclusion: We have to tackle robust building / using of non Fortran dependencies, but I would worry about it a bit later, once Fortran fpm works well. So I would just stick to pure Fortran for now."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 19:58:23+00:00",
                    "text": "I asked the author of toml-f at awvwgk/toml-f#1 if he would be willing to relicence. If he would, that would be awesome, I think it's exactly what we are looking for."
                }
            ]
        },
        {
            "number": 148,
            "user": "milancurcic",
            "date": "2020-07-24 16:57:00+00:00",
            "title": "fpm command placeholders and expand help message",
            "text": "To warm up my Fortran fingers before the workday, I made a few benign UI improvements:\n\nExpand the print message, borrowing from fpm-haskell and Cargo\nAdd placeholder new, install, run, test commands and \"not implemented\" messages",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-24 18:04:10+00:00",
                    "text": "What GFortran version do you have? I have 7.5.0 and it returns a non zero exit value, as can be verified by:\n~/.../fpm/fpm(master)$ ./fpm \n Fortran Package Manager (fpm)\n OS Type: Linux\n~/.../fpm/fpm(master)$ echo $?\n0\n~/.../fpm/fpm(master)$ ./fpm xx\n Unknown command: xx                                                                                                  \nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fd711f9b32a\n#1  0x7fd711f9bed5\n#2  0x7fd711f9cf86\n#3  0x555e59a321c7\n#4  0x555e59a32273\n#5  0x7fd711bb0b96\n#6  0x555e59a31fd9\n#7  0xffffffffffffffff\n~/.../fpm/fpm(master)$ echo $?\n1"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 18:07:42+00:00",
                    "text": "@LKedward I don't remember if we discussed fpm help, but it will sure be useful to display command-specific help messages, e.g. fpm help build (Cargo has it).\n@certik Never mind, now I can't reproduce it, which means that I mistakenly tested the exit code of something else that had it as 0. Are you fine with explicit error stop 1 or should I revert that one? I think at least this way the code will be consistent across compilers, if it's not already."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 18:11:52+00:00",
                    "text": "I don't mind what is in there, as it will get rewritten anyway eventually. I only don't like your commit message, as it implies that somehow error stop is bad, while my understanding of it is that it will always exit the program with non zero exit code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 18:28:48+00:00",
                    "text": "@certik Now I'm confused. Does \"add exit code to error stop\" imply that it's bad? It merely states what was added to the code.\nBut more importantly, do you not think that error stop 1 is more robust than error stop? The standard recommends that error stop causes a non-zero exit code, so I think we can confidently trust that all compilers will do that. However, I don't know what error codes various compilers return, so even after the fact about my mistake I think this is an improvement."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 19:38:57+00:00",
                    "text": "I think you posted it in the comment not a commit log, my apologies. It's fine to merge as it is, so I am going to merge it.\nI am not sure if error stop 1 is more robust than error stop, unless you care about the value of the non zero code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 19:43:58+00:00",
                    "text": "@certik Ah, okay, got it, all clear now. I agree, that comment was a mistake. I went back and crossed it over so it doesn't confuse anybody else.\nYes for explicit error stop code it will matter only when we want to set different codes. As you say, these are just placeholders so it doesn't matter for now."
                }
            ]
        },
        {
            "number": 147,
            "user": "certik",
            "date": "2020-07-22 22:19:30+00:00",
            "title": "Execute the newly built fpm",
            "text": "On all platforms.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-23 16:08:34+00:00",
                    "text": "This is just a simple addition to the CI, tests work, I am going to merge it."
                }
            ]
        },
        {
            "number": 146,
            "user": "certik",
            "date": "2020-07-22 21:07:45+00:00",
            "title": "Design a model that captures fpm's understanding of the project",
            "text": "The Fortran fpm should have a module that represents the semantics of all the information that fpm gathers about the project. Here is the pipeline of fpm build:\n\n\nParse: read fpm.toml, read src/*, read app/* (later also tests/*, examples/*, ...), read every Fortran file, determine if it is a program or a module, note module / program name, note all Fortran module dependencies.\n\n\nSemantics: checks that all the information is consistent: that module / program name is consistent with the filename, that module and package dependencies are present, that info in fpm.toml is consistent with the files that are present. In this phase we check for all errors and report nice error messages to the user if something is wrong. After this phase is over, the project is correct and can be compiled (there can be compiler error messages later on, but no fpm error messages).\n\n\nModel: The result of the phase 2. is saved in a standalone representation that we should be able to print out. This representation has all the information that later phases will require. And it is checked, in other words, all fpm errors are already reported. It is possible to print this representation out. I can imagine a lot of our tests can simply be to run fpm build --show-model that will only print the model out, but not do any build, and we check it against reference results, to ensure that fpm was able to gather and check all the information correctly.\n\n\nBackends:\na. Build backend: takes the Model (and nothing else) and builds the project\nb. CMake backend: takes the Model (and nothing else) and generates a CMake build system (#69) or a standalone tarball with all dependencies and a CMake build system (#123).\n\n\nThis design will ensure that the initially possibly messy and error prone parts in 1. and 2. are completely separated from the actual build or cmake backends, and that we can test each part separately. Also, even for our users it would be very helpful if fpm can print the Model in a nice form, so that users can check that fpm was able to understand their project correctly, before attempting to do any build. If the Model is not what users expected, then they know that fpm didn't understand their project correctly and they can report a bug, or rearrange their files or fpm.toml.\n\n@milancurcic, @everythingfunctional let me know if you want to do a quick phone call about this.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 21:17:02+00:00",
                    "text": "Regarding package dependencies: to have a complete Model without any missing Fortran modules, one might need to checkout every dependency (recursively) and execute 1. and 2. on it, to figure out what Fortran modules the dependency has, and then one can ensure that there are (globally) no missing modules.\nSo executing 1. and 2. on a given package will create a Model with possible missing Fortran modules. But downloading & executing 1. and 2. on each dependency (before building) we can construct a Model for each package and ensure that all the Models are consistent.\nSo part of the Model can be a structure like Package, and a full Model would then have a set of Packages with dependencies between them, etc. This full Model will then be an input to #123. Also one can then use this full Model to design a good parallel Build backend.\n\nI think from a practical perspective, it makes sense if a Model's Package structure is constructed locally for a given package, and checked for everything except missing Fortran modules. This can then be (even in parallel) repeated for each dependency, as this process is independent of order. Finally, at the end, this set of Packages is taken and checked that all missing modules resolve correctly according to the Package dependencies, and this resolved set of Packages then comprises the finished Model as part of step 3. Then one can hand it over to the backends  in 4.\nEach Package would know where on the disk the files are checked out. So when the backends in 4. start the work, no internet connection is needed, everything is checked out.\nThe only possible improvement is to start building while other packages are still downloading, but that's going to mess up the separation of things, so we might want to do it like Debian/Ubuntu, which first downloads all packages, and only then installs them in the correct order. So besides this very minor lack of optimization, this seems like a very clean design, that will allow us to maintain clean code and be very transparent to users."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-23 19:18:13+00:00",
                    "text": "@certik , I think this is a very good design. There are some details to flesh out (obviously), but this is quite similar to the way it's done in the Haskell version.\nI might add a step 0, parse the command line, as some commands do not require reading the fpm.toml or doing all (or even any) of the following steps. fpm new for example.\nWe probably should schedule a call. I'm swamped today and tomorrow, but should be able to squeeze it some time after that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 19:27:30+00:00",
                    "text": "It looks good, I'm down for a call next week. Please email a few time slots for next week. It'd be good to also entrain anybody who's interested in getting more involved with fpm development."
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 23:33:50+00:00",
                    "text": "Ok, the call is set for Tuesday 1pm PDT. If anyone else wants to join this discussion, you can, just comment here so that we can invite you."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-24 09:59:53+00:00",
                    "text": "I'm interested in getting more involved with fpm development so would be interested in joining that call."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-24 10:07:28+00:00",
                    "text": "Same here :).\n\nOp vr 24 jul. 2020 om 12:00 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n I'm interested in getting more involved with fpm development so would be\n interested in joining that call.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5XJRXIPRZBWFSRA5LR5FLSRANCNFSM4PFDFI3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 15:33:45+00:00",
                    "text": "@LKedward, @arjenmarkus perfect, thanks. I will post the meeting information here, so that you can join also."
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 17:36:26+00:00",
                    "text": "Here is the Zoom meeting invitation at 1pm Pacific Time today.\nOnd\u0159ej \u010cert\u00edk is inviting you to a scheduled Zoom meeting.\nTopic: FPM Design Discussion\nTime: Jul 28, 2020 02:00 PM Mountain Time (US and Canada)\nJoin Zoom Meeting\nhttps://zoom.us/j/99897479516?pwd=UnpBL05la3YyYmVSdEo1T0VSVmJwUT09\nMeeting ID: 998 9747 9516\nPasscode: YY1XEv"
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 19:57:18+00:00",
                    "text": "Just a reminder that the meeting starts in 3 minutes."
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 21:13:15+00:00",
                    "text": "Summary of our meeting:\n\nLooks like we all agreed on the general design above.\nWe discussed some details such as:\n\nHow to test this: integration tests vs unit tests, vs integration tests with specific features to test. We will iterate as we go. We can use Vegetables for unit testing.\nHow to link C dependencies: include the linking information in the Model, backend links\nThe Model includes everything, including command line options\nAllow the Model to print to the screen (for testing and informational purposes)\nThat it is probably a good idea as a start to download all dependencies and figure out a Model that includes all the dependencies, and only then pass it over to the backend. Later we can investigate whether the backend cannot start building some files speculatively sooner.\n\n\nStep forward: refactor our current fpm to follow the design above: construct a Model, pass it to the backend."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-29 06:40:54+00:00",
                    "text": "Hi Ondrej, all,\n\nsorry I missed the meeting - I was home rather late and I did not see any\nmessage with a link to the meeting ;). I will try and catch up with the\nmaterial so far.\n\nRegards,\n\nArjen\n\nOp di 28 jul. 2020 om 23:13 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Summary of our meeting:\n\n    - Looks like we all agreed on the general design above.\n    - We discussed some details such as:\n       - How to test this: integration tests vs unit tests, vs integration\n       tests with specific features to test. We will iterate as we go. We can use\n       Vegetables for unit testing.\n       - How to link C dependencies: include the linking information in\n       the Model, backend links\n       - The Model includes everything, including command line options\n       - Allow the Model to print to the screen (for testing and\n       informational purposes)\n       - That it is probably a good idea as a start to download all\n       dependencies and figure out a Model that includes all the dependencies, and\n       only then pass it over to the backend. Later we can investigate whether the\n       backend cannot start building some files speculatively sooner.\n    - Step forward: refactor our current fpm to follow the design above:\n    construct a Model, pass it to the backend.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRZLWWNL4YBLV3QGJIDR545PVANCNFSM4PFDFI3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-07-29 06:58:40+00:00",
                    "text": "No worries! I am sure we'll have another development meeting soon.\n\u2026\nOn Wed, Jul 29, 2020, at 12:41 AM, Arjen Markus wrote:\n\n\n Hi Ondrej, all,\n\n sorry I missed the meeting - I was home rather late and I did not see any\n message with a link to the meeting ;). I will try and catch up with the\n material so far.\n\n Regards,\n\n Arjen\n\n Op di 28 jul. 2020 om 23:13 schreef Ond\u0159ej \u010cert\u00edk ***@***.***\n >:\n\n > Summary of our meeting:\n >\n > - Looks like we all agreed on the general design above.\n > - We discussed some details such as:\n > - How to test this: integration tests vs unit tests, vs integration\n > tests with specific features to test. We will iterate as we go. We can use\n > Vegetables for unit testing.\n > - How to link C dependencies: include the linking information in\n > the Model, backend links\n > - The Model includes everything, including command line options\n > - Allow the Model to print to the screen (for testing and\n > informational purposes)\n > - That it is probably a good idea as a start to download all\n > dependencies and figure out a Model that includes all the dependencies, and\n > only then pass it over to the backend. Later we can investigate whether the\n > backend cannot start building some files speculatively sooner.\n > - Step forward: refactor our current fpm to follow the design above:\n > construct a Model, pass it to the backend.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#146 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAN6YRZLWWNL4YBLV3QGJIDR545PVANCNFSM4PFDFI3Q>\n > .\n >\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBXYJLYFELAQTY7UT3R57AAHANCNFSM4PFDFI3Q>."
                }
            ]
        },
        {
            "number": 145,
            "user": "certik",
            "date": "2020-07-22 20:10:35+00:00",
            "title": "Read the source files automatically",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 20:43:05+00:00",
                    "text": "This obviously needs a lot more testing, but as a proof of concept it's good enough. It reads the files from the src/ directory if it exists and builds them. It seems to work on all platforms. Still no module dependency resolution."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 21:30:42+00:00",
                    "text": "I rebased on top of the latest master to simplify the history."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 22:17:30+00:00",
                    "text": "Thanks for the review. Merging."
                }
            ]
        },
        {
            "number": 144,
            "user": "certik",
            "date": "2020-07-22 15:03:08+00:00",
            "title": "fpm should detect operating system",
            "text": "Given the issues in #141 to determine the OS type, I think the most robust is to do it like CMake: fpm will detect / know the operating system that it is on, and it will pass this information down the source files, for example in terms of macro definitions, such as:\n\nFPM_OS_LINUX\nFPM_OS_MACOS\nFPM_OS_WINDOWS\n\nOr something like that. We might be even more specific than that if needed. This seems to be the most robust and cross-platform way to do it that will work with all Fortran compilers.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 15:11:20+00:00",
                    "text": "I tried various ways using macros in #142, and none of them seem to work with gfortran. So that's why I think having fpm define those macros is the way to go."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 15:16:58+00:00",
                    "text": "Right, so if fpm itself can detect the operating system, what do you need the macros for? I thought the macros are only useful when your software doesn't have the information you need. Or am I missing something?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:23:55+00:00",
                    "text": "It's a chicken and an egg. The fpm implementation in Fortran needs to know the system type so that we know what command to use to get the directory content. The most robust seems to be if the build system (whether cmake or fpm) passes this information in as macro definitions."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 15:31:07+00:00",
                    "text": "Okay, so the bootstrap Haskell fpm will know the OS and pass the macros down to Fortran fpm. Then in the future when you want to bootstrap Fortran fpm using Fortran fpm, then the OS information will already be available in the boostrap Fortran fpm binary. It made me dizzy for a little bit, but I think it works."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:34:47+00:00",
                    "text": "Right. The other way to bootstrap fpm down the road will be via cmake (#123), so the cmake build system that fpm will generate will have to detect the OS type (which cmake knows how to do) and then create the proper FPM_OS_* macro defines."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 11:50:39+00:00",
                    "text": "You could use the commands that come with the operating system (for instance this website gives some indicators.\nWhile this will not be waterproof, the module may simply test the various commands - whichever succeeds is the one we want.\nI can give this a try."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 12:32:31+00:00",
                    "text": "I just tried:\nver in a Windows command box gives the indication of the Windows version\nThis does not work with MinGW or Cygwin, even though they are Windows-based OSes.\nuname -a succeeds on MinGW, Cygwin and Linux with proper indications of all OS types.\nI have no access to MacOS but I imagine that uname -a work fine there as well.\n(Something to check: whether ver is not a haphazard program - for uname I guess /usr/bin/uname is restrictive enough?)"
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 14:59:22+00:00",
                    "text": "Here is how we currently do this using environment variables: \n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 16\n      in\n      6ef2546\n    \n    \n    \n    \n\n        \n          \n           integer function get_os_type() result(r)"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:16:20+00:00",
                    "text": "Hm, the environment variable HOMEPATH is set to \"\\Users\\markus\" on my Cygwin and MinGW/w-64 installations. So, with the current procedure that would boil down to \"Windows\"."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 17:19:54+00:00",
                    "text": "It looks like we may have to combine the current HOMEPATH query with a ver test suggested by @arjenmarkus if we want to differentiate MinGW or Cygwin from Windows."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:23:10+00:00",
                    "text": "Since they represent very different operating environments, I think we\ncannot ignore the difference ;). For instance: \"dir\" does not work under\nCygwin or MinGW.\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:20 schreef Milan Curcic <notifications@github.com>:\n\u2026\n It looks like we may have to combine the current HOMEPATH query with a ver\n test suggested by @arjenmarkus <https://github.com/arjenmarkus> if we\n want to differentiate MinGW or Cygwin from Windows.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#144 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2ZDUGZDNVZCMXWNUDR5BWMXANCNFSM4PEZSOMQ>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:26:10+00:00",
                    "text": "Oops, I was too hasty: \"dir\" does actually work and \"dir -b\" also. But then\n\"dir /b\" does not and, vice versa, under a Windows command box \"dir -b\"\ndoes not work - it looks for a file \"-b\".\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:22 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n Since they represent very different operating environments, I think we\n cannot ignore the difference ;). For instance: \"dir\" does not work under\n Cygwin or MinGW.\n\n Regards,\n\n Arjen\n\n Op do 23 jul. 2020 om 19:20 schreef Milan Curcic ***@***.***\n >:\n\n> It looks like we may have to combine the current HOMEPATH query with a\n> ver test suggested by @arjenmarkus <https://github.com/arjenmarkus> if\n> we want to differentiate MinGW or Cygwin from Windows.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#144 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR2ZDUGZDNVZCMXWNUDR5BWMXANCNFSM4PEZSOMQ>\n> .\n>"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 17:34:15+00:00",
                    "text": "Right, dir is part of GNU Coreutils, so it works on most Linux systems, but not on macOS for example. Best to stay away from it for making important decisions :)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 18:25:21+00:00",
                    "text": "I have experimented a bit: the attached code correctly identifies the\nfour OSes I have access to. It cannot rely on \"ver\", because that is\nalso supported by MinGW and Cygwin, so instead I use \"uname\". However,\nMinGW gives odd results - /usr/bin/uname was not found (presumably the\ndirectory is not properly substituted). So, it also tries \"uname\"\nwithout the path.\n\nThe executable I created with Intel Fortran gives the right (!)\nidentification under a Windows command box, MinGW and Cygwin. I have\nnot tested the MinGW/Cygwin variants under the others.\n\n(Attaching it to an email was the fastest way, but of course I can\nalso put it in a pull request)\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:34 schreef Milan Curcic <notifications@github.com>:\n\n Right, dir is part of GNU Coreutils, so it works on most Linux systems, but not on macOS for example. Best to stay away from it for making important decisions :).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n! getos.f90 --\n!     Attempt to characterise the operating system\n!\nmodule getos\n    implicit none\n\n    integer, parameter :: OS_WINDOWS = 1\n    integer, parameter :: OS_LINUX   = 2\n    integer, parameter :: OS_MACOS   = 3\n    integer, parameter :: OS_CYGWIN  = 4\n    integer, parameter :: OS_MINGW   = 5\n\ncontains\n\n! get_os --\n!     Identify the operating system\n!\n! Arguments:\n!     None\n!\n! Note:\n!     Linux is used as the fallback option. Should we distinguish this from a positive identification?\n!\ninteger function get_os()\n    character(len=80) :: val\n    character(len=20) :: os_id\n    integer           :: lun\n    integer           :: stat\n\n    !\n    ! Try the environment variable\n    !\n    call get_environment_variable( \"HOMEPATH\", val, status = stat )\n\n    if ( stat == 0 .and. val(1:7) == \"\\Users\\\" ) then\n        !\n        ! We may be on Windows, probably, but what flavour? Windows, Cygwin or MinGW?\n        !\n        ! First try \"uname\"\n        !\n        ! Note: MinGW gives an error when using the full path ...\n        !\n        call execute_command_line( \"/usr/bin/uname -a > fpm_tmp.out 2>&1\", exitstat = stat )\n        if ( stat /= 0 ) then\n            call execute_command_line( \"uname -a > fpm_tmp.out 2>&1\", exitstat = stat )\n        endif\n\n        if ( stat /= 0 ) then\n            !\n            ! This seems to be Windows\n            !\n            get_os = OS_WINDOWS\n        else\n            open( newunit = lun, file = \"fpm_tmp.out\" )\n            read( lun, * ) os_id\n            close( lun, status = 'delete' )\n\n            get_os = merge( OS_CYGWIN, OS_MINGW, os_id(1:6) == 'CYGWIN' )\n        endif\n    else\n        !\n        ! We are on Linux or MacOS\n        !\n        call get_environment_variable( \"HOME\", val, status = stat )\n\n        if ( stat == 0 ) then\n            if ( val(1:7) == \"/Users/\" ) then\n                get_os = OS_MACOS\n            else\n                get_os = OS_LINUX\n            endif\n        else\n            !\n            ! Use Linux as fallback option\n            !\n            get_os = OS_LINUX\n        endif\n    endif\nend function get_os\n\nend module getos\n\n! test ...\n!\nprogram test_get_os\n    use getos\n\n    integer :: id\n\n    character(len=10), dimension(5) :: os_identification = &\n        ['Windows   ', 'Linux     ', 'MacOS     ', 'Cygwin    ', 'MinGW     ']\n\n    id = get_os()\n    write(*,*) id, os_identification(id)\n\nend program test_get_os"
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 23:37:46+00:00",
                    "text": "Thanks @arjenmarkus, much appreciated. We should incorporate this into fpm."
                }
            ]
        },
        {
            "number": 143,
            "user": "certik",
            "date": "2020-07-22 14:41:32+00:00",
            "title": "`fpm run` does not propagate exit code",
            "text": "fpm run does not return with error if the program fails, as can be checked by:\n$ fpm run && echo \"OK\"\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7ff9ae8262ed in ???\n#1  0x7ff9ae826ed5 in ???\n#2  0x7ff9ae827f86 in ???\n#3  0x55ee5e99e013 in get_os\n\tat src/fpm.F90:22\n#4  0x55ee5e99df25 in __fpm_MOD_print_help\n\tat src/fpm.F90:28\n#5  0x55ee5e99daa2 in MAIN__\n\tat app/main.f90:7\n#6  0x55ee5e99dc43 in main\n\tat app/main.f90:2\nOK\n\nThis causes CI tests to pass even though they should fail, e.g.:\nhttps://github.com/fortran-lang/fpm/pull/142/checks?check_run_id=897192409\nwhich should have failed, but happily continues:\n...\n# gfortran (for build/gfortran_debug/app/main.o)\n# gfortran (for build/gfortran_debug/app/fpm)\n+ fpm run\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fc9615aaaed in ???\n#1  0x7fc9615ab605 in ???\n#2  0x7fc9615acc93 in ???\n#3  0x55b23ed92014 in get_os\n\tat src/fpm.F90:22\n#4  0x55b23ed91f21 in __fpm_MOD_print_help\n\tat src/fpm.F90:28\n#5  0x55b23ed91a7d in MAIN__\n\tat app/main.f90:7\n#6  0x55b23ed91c28 in main\n\tat app/main.f90:2\n+ fpm run --args build\n # Building project\n + gfortran -c src/fpm.F90 -o fpm.o\n + gfortran -c app/main.f90 -o main.o\n...\n\nThis is quite high priority, as we need our CI to be reliable with regards to these things.\n@everythingfunctional do you  know how to fix it?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-23 16:34:48+00:00",
                    "text": "I see. I expected the function used to run external commands to propagate that automatically, but I guess I was wrong. It should just be a matter of catching the return status and manually doing something with it. I should have some time to look into it this weekend."
                }
            ]
        },
        {
            "number": 142,
            "user": "certik",
            "date": "2020-07-22 05:24:08+00:00",
            "title": "Initial implementation of get_os()",
            "text": "It might be difficult to get this working via pre-processor.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 14:43:10+00:00",
                    "text": "This PR actually fails tests, but they look like they passed due to #143."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:07:46+00:00",
                    "text": "@milancurcic the tests are currently failing, even though they are green. The macros do not work, if you click on the output when we just run fpm, you can see that you get a stacktrace and \"error stop\"."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:09:06+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-22 15:28:47+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables.\n\nHow did you pass the macro to gfortran? as -DFMP_OS_xxxx?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-22 15:39:56+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables.\n\nIf it could help, fpp and macros seem to work when compiling manually:\n gfortran -cpp -D_WIN32 fpm.F90\n$ ./a.out \n Fortran Package Manager (fpm)\n OS Type:            3"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:44:36+00:00",
                    "text": "@jvdp1 the issue is that those macros do not seem to be defined by default on any platform with gfortran (and obviously we need to support all Fortran compilers down the road, each defining slightly different macros).\nThe current solution as of (a1dc068) seems to work. It's obviously not super robust, but it will get us started, and we can design the correct full solution in #144."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:53:53+00:00",
                    "text": "Everything works except Windows. It just occurred tome that if $HOME doesn't exist, then we can assume Windows. I am going to rework it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 16:05:40+00:00",
                    "text": "The problem now is that if a Windows user defines %HOME% for any reason, the function will fail.\nI think the original %HOMEPATH% approach is more robust, but you also need to test the value:\ncall get_environment_variable(\"HOMEPATH\", val, status=stat)\nif (stat == 0 .and. val(1:7) == \"\\Users\\\") then\n    r = OS_WINDOWS\n    return\nend if"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:16:52+00:00",
                    "text": "So when I first implemented $HOMEPATH for Windows, it failed: https://github.com/fortran-lang/fpm/runs/899185101, but then the later commit which didn't touch it, succeeded: https://github.com/fortran-lang/fpm/runs/899226753. This is infuriating, I spent hours yesterday due to this fragility of the GitHub Actions. I think they sometimes test a previous commit, even though they claim to test the latest commit. This is really bad from a reliability perspective.\nAnyway, the latest commit (only using $HOME) also seems to work, but who know knows if it actually got tested?\nI can put in back the $HOMEPATH if you prefer. This is all fragile and can easily break anyway, if somebody declares HOMEPATH on linux for example."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 16:20:49+00:00",
                    "text": "This is all fragile and can easily break anyway, if somebody declares HOMEPATH on linux for example.\n\nYes, but testing for the value (\"\\Users\\\") greatly reduces the chance of collision. I don't think we should excuse the code to be fragile if the CI is already fragile."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:25:46+00:00",
                    "text": "Right. I did it as you suggested, but I just don't know which of the two is more robust (will succeed in more cases):\n\nTest for $HOMEPATH=\\Users\\\nTest that $HOME does not exist\n\nBecause I do not know if $HOMEPATH on Windows can be set to other paths than \\Users\\ quite often, or not. And compared to that how often do users define $HOME on Windows."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:36:14+00:00",
                    "text": "I checked the CI manually, it still seems to work (assuming the CI tested the latest commit). But given the fact that the previous commit seems to work, then if the master fails after this is merged, we can always revert the latest commit.\nThis is ready for a final review and merge as far as I am concerned."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 20:25:06+00:00",
                    "text": "@milancurcic, @everythingfunctional is this ok to go in? I have another PR (#145) that depends on this."
                }
            ]
        },
        {
            "number": 141,
            "user": "certik",
            "date": "2020-07-21 22:04:55+00:00",
            "title": "How to list directory content",
            "text": "In order to move beyond #137, we need a cross-platform way to read all the *.f90 files in a directory. What is the best way to do that in Fortran?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:11:27+00:00",
                    "text": "For cross-platform you need this.\nOtherwise, I think the next best kludge would be to call execute_command_line('ls > tmp.txt'), then parse tmp.txt, and equivalent on Windows."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:20:55+00:00",
                    "text": "We need a temporary solution so that we are not stuck on this, and can move on, and in the meantime we can work on the full general solution."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:27:50+00:00",
                    "text": "I agree. I think wrapping around the shell commands on each OS is the way to go."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:34:23+00:00",
                    "text": "It seems like it. How do you determine which OS you are on from Fortran?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:45:23+00:00",
                    "text": "Perhaps we can test the value of an environment variable (get_environment_variable) that we know will be different between systems? Perhaps HOME, and then detect based on whether the value has forward slashes (Linux and macOS) or backslashes (Windows)? Just an idea, I've never done this myself."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:59:23+00:00",
                    "text": "Good idea, the GET_ENVIRONMENT_VARIABLE intrinsic will do this. That will get us started, and we can make this more robust / general later."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:23:50+00:00",
                    "text": "I'd put it behind a function and just use preprocessor directives. Something like:\nfunction is_windows()\n    logical :: is_windows\n\n#ifdef (WIN_32)\n    is_windows = .true.\n#elif\n    is_windows = .false.\n#endif\nObviously you'll need to look up the proper syntax and tests, but that way, even if you change the way it's done, it shouldn't require changing any other code anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:28:01+00:00",
                    "text": "@everythingfunctional ah that's right, I think that should work."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 23:37:52+00:00",
                    "text": "I didn't know fpm supported preprocessing. \ud83d\udc4d in that case."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:43:41+00:00",
                    "text": "fpm isn't doing any preprocessing, but our currently only supported compiler does a bit ;). Should be enough to solve at least the \"Is this Windows or not?\" question."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 09:00:36+00:00",
                    "text": "I just tried: on Windows \"dir /b\" gives the bare list of file names, just as \"ls\". That means that only the command is different - not the format of the output (with out \"/b\" you get a lot of rubbish ;))."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 14:46:18+00:00",
                    "text": "@everythingfunctional so the ifdef trick does not work with gfortran to determine the OS, I tried that in #142, and it does not work on linux, nor anywhere else... Let's further discuss this OS determination in #144."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:31:03+00:00",
                    "text": "Thanks @arjenmarkus. I will try to do this once #142 is merged, as I need to determine the OS type first to know which command to run."
                }
            ]
        },
        {
            "number": 140,
            "user": "certik",
            "date": "2020-07-21 21:58:03+00:00",
            "title": "Build hello_world",
            "text": "The build is hardwired, but it works. This is mainly useful to setup our CI.\nOnce we implement a more general solution, we just need to keep our CI passing.\nFixes #137.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 22:10:24+00:00",
                    "text": "Weird. The Linux CI didn't execute the additional lines I added in this PR: https://github.com/fortran-lang/fpm/pull/140/checks?check_run_id=896195075"
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:29:50+00:00",
                    "text": "I extracted the tests into separate files, now they are executed properly. Don't know what the problem was, it looks like a bug at the CI."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:32:55+00:00",
                    "text": "The CI is not executing the latest version of the files at a given commit. That's a bug, which makes it pretty hard to Debug."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:56:18+00:00",
                    "text": "It finally works, all tests pass and are executed properly. Hello World test now works on all platforms."
                }
            ]
        },
        {
            "number": 139,
            "user": "certik",
            "date": "2020-07-21 20:13:34+00:00",
            "title": "Minimal `fpm build` implementation",
            "text": "Very minimal fpm build now works, it can only build fpm itself, but it can do it on all platforms, which is nice.\nAfter this is in, the next step is to make it more general and build the hello_world example, and then execute this test also.\nTowards #137.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 21:39:02+00:00",
                    "text": "Finally some code I can contribute! I am going to merge, the change is simple, so I think one positive review is enough."
                }
            ]
        },
        {
            "number": 138,
            "user": "certik",
            "date": "2020-07-21 19:56:40+00:00",
            "title": "`fpm run --args \"a b c\"` should become `fpm run -- a b c`",
            "text": "As in Cargo.\nCurrently you must use \" as in:\nfpm run --args \"a b c\"\n\nRather, one should just do:\nfpm run -- a b c",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:29:56+00:00",
                    "text": "I agree, just couldn't figure out how to make that work with the command line parser I was using in Haskell."
                }
            ]
        },
        {
            "number": 137,
            "user": "certik",
            "date": "2020-07-21 19:52:41+00:00",
            "title": "Minimal version working",
            "text": "This minimal version will:\n\ncompile test/example_packages/hello_world\nrun this particular test\n\nTo get this working, we do not need any of the 3rd party packages as listed in #136, we only need to implement fpm build, fpm run, we do not need to read the toml file for now, so we can get it working quite quickly.\nThe main goal is to start testing this as part of our testing. Then later we can swap a proper CLI library, a proper TOML reading library, etc.",
            "comments": []
        },
        {
            "number": 136,
            "user": "certik",
            "date": "2020-07-21 19:45:52+00:00",
            "title": "Roadmap for Fortran implementation",
            "text": "We need libraries for the following functionality (any help appreciated with any of these):\n\n CLI (#135)\n TOML parser (#149)\n execute gfortran on all platforms\n download using git and tarballs (http)\n list directory content (#141)\n\nRoadmap:\n\n Good tests and spec (#133)\n A minimal version working that can compile test/example_packages/hello_world, which does not require 3rd party packages, run this particular test (#137)\n Get more and more tests working\n\nIf anything else comes up, I will update this issue.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 20:58:43+00:00",
                    "text": "Fortran interface to curl for http requests: https://github.com/interkosmos/fortran-curl\nIf we end up needing more advanced git stuff than just downloading the code, we can wrap libgit2."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 20:14:28+00:00",
                    "text": "Per my comment in #149 (comment), it seems all of these can in principle be done in pure Fortran, except the internet download of tarballs. For git repositories, we'll just assume that the git executable is installed, as we already do in haskell fpm. To be able to bootstrap fpm easily, we can just have all dependencies as git repositories and assume git is present on all platforms. Then in principle everything can be done in pure Fortran, which I think might be very helpful at least initially.\nThen we can implement robust support for 3rd party non Fortran dependencies in the fortran fpm. Eventually we can then depend on curl or any other library (but if we do for fpm itself, it will always be more challenging to install it from source, say on HPC machines than if every dependency is pure Fortran)."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2020-07-26 19:08:37+00:00",
                    "text": "FYI...somewhere i have a Fortran interface to WinINet that i wrote years ago. I think it was pretty rudimentary but it could be used to download files (on windows only of course). I can dig that up, but maybe you just want to stick with curl on all platforms?"
                }
            ]
        },
        {
            "number": 135,
            "user": "milancurcic",
            "date": "2020-07-21 15:45:53+00:00",
            "title": "Command line interface (CLI)",
            "text": "How to implement the CLI in fpm-fortran? We can use:\n\nIntrinsics command_argument_count and get_command_argument (lowest level, no dependencies)\nFLAP by @szaghi (library, pure Fortran, I've used it a bit with good experience)\nM_cli by @urbanjost (library, pure Fortran, no personal experience with it)\nSome other library I'm not aware of?\n\nI think we should go with a library and both FLAP and M_cli seem to do what we need (positional arguments + optional flags). What do you think?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 15:52:02+00:00",
                    "text": "I would go with FLAP. But we have to make it an fpm package first, so that we can use it as a dependency. Update: that actually might not be as easy without refactoring... Looking at M_cli, it actually seems much easier to create an fpm package out of it. So we might start with M_cli, and then if FLAP can be made an fpm package, we can switch to it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 19:05:56+00:00",
                    "text": "M_cli is already an fpm package (I tried it--it works). However, after reviewing M_cli in more detail, I'm quite strongly in favor of FLAP. It seems more mature and powerful while in my opinion having a simpler API.\n@szaghi would you accept a PR to FLAP that would make it an fpm package? We'd make sure that your existing build systems  (CMake, Make, Fobis) still work. This would require adding an fpm.toml file to the top-level directory, and some adjustments to module names or source file names, but otherwise it would be backward compatible from user's point of view. Best part, it would make FLAP part of a rapidly growing fpm ecosystem of packages."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:33:31+00:00",
                    "text": "I haven't had a chance to look at either of the libraries, but that is definitely the way to go. We need to do whatever can help us bootstrap this faster.\nNote: the command line for fpm is quite complicated; subcommands, flags that are only applicable for a subset of them, some flags which may be mutually exclusive, etc.\nI think the first step, before we start implementing the command line interface is to clearly spec it out. Then we can pick a library and start implementing."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 19:59:02+00:00",
                    "text": "I am aware of two more libraries for command line interfaces:\n\ncommand_args from @arjenmarkus\nFTN_Getopt by Reinhold Bader (author of FGSL). I like the simplicity of this one (it is a single module). Unfortunately, the source code is not publicly available at the moment. I have a copy of the code and the author has indicated to me I can share it under GPL and the condition of preserving the authorship."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 20:18:30+00:00",
                    "text": "I would like all fpm dependencies to be MIT or BSD licensed, because we are linking everything statically into one executable, so GPL (and even LGPL) would prohibit us to license fpm under the MIT license."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-21 20:24:29+00:00",
                    "text": "Wouldn't it be useful to integrate such a library first (or simultaneously) in stdlib?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 20:24:39+00:00",
                    "text": "One more library I learned of recently is libSUFR (libSUFR is a library containing Some Useful Fortran Routines). It is also GPL.\nThe M_cli module from @urbanjost is licensed under the Unlicense.\nThe way I understand the licensing system of FLAP:\n\nfor FOSS projects:\n    GPL v3;\nfor closed source/commercial projects:\n    BSD 2-Clause;\n    BSD 3-Clause;\n    MIT.\n\n\nfpm would count as a FOSS project, since the source is public. Am I correct?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 20:31:51+00:00",
                    "text": "fpm would count as a FOSS project, since the source is public. Am I correct?\n\nI think that strictly only GPL family of software is FOSS. We are just OSS :)\nI'm pretty sure that @szaghi meant \"use whatever license you want\". He can confirm this."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 20:32:58+00:00",
                    "text": "@jvdp1 yes, stdlib should have basic command line parsing, just like Python has it. But we can wait with stdlib's integration until we get more experience what API makes the most sense."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 20:47:13+00:00",
                    "text": "Just as an alternative idea, we could also wrap one of the many existing C and C++ libraries:\n\ndocopt.c, docopt.cpp\ncommander\nCLI11 (I noticed @certik is a contributor \ud83d\udc4d ) Edit: It also has a partial TOML parser.\ncxxopts\n\nI think with the current Haskell version of fpm this would require a custom Makefile."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 21:42:07+00:00",
                    "text": "Yes, I investigated all options for C++, and most of them work, and I settled with using CLI11 for LFortran. Works great."
                }
            ]
        },
        {
            "number": 134,
            "user": "certik",
            "date": "2020-07-21 15:36:57+00:00",
            "title": "Haskell fails to install on macOS at our CI",
            "text": "The error is:\nRun curl --insecure -L https://get.haskellstack.org/stable/osx-x86_64.tar.gz | tar xz --strip-components=1 --include '*/stack' -C /Users/runner/.local/bin\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (35) Server aborted the SSL handshake\n\nSee e.g. https://github.com/fortran-lang/fpm/pull/131/checks?check_run_id=894840007",
            "comments": []
        },
        {
            "number": 133,
            "user": "milancurcic",
            "date": "2020-07-21 15:34:59+00:00",
            "title": "Draft an fpm specification",
            "text": "I want us to get started on the specification document. It would describe the expected behavior of fpm. It wouldn't be a user documentation, although users could use it to diagnose fpm bugs. A spec would help define much needed tests that would catch various recently reported unhandled exceptions.\nRather than us writing a spec and then an implementation following that spec, I think the spec should evolve side-by-side as we implement and discover the preferred ways to do things. So it will very much be a living document.\nI'm happy to start the first draft. In this issue, I'm merely asking for thumbs up if you agree, and if not let me know why.\n@certik @everythingfunctional @LKedward @arjenmarkus @smeskos",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 16:08:21+00:00",
                    "text": "If it was me, I would be fine with the spec simply being the tests themselves. But I am not against having a separate document also, but in either case, from a practical perspective, we need the tests for sure. That is how we will ensure that the Haskell and Fortran versions actually work."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 17:30:50+00:00",
                    "text": "I agree about tests, but to write tests you need to know the expected behavior of the program. Writing a spec would force us to get clear on the expected behavior."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 17:59:20+00:00",
                    "text": "That's fine with me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:23:37+00:00",
                    "text": "To the extent we can, the tests should read very much like the spec. But I am in favor of starting with a spec right now, mostly because I believe there are aspects of the Haskell version that do not function exactly as we want. We should have a discussion about how to handle these situations before we start writing the tests."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 06:29:15+00:00",
                    "text": "I agree: having worked with fpm a bit more, I see how it works currently\nand how it sometimes conflicts with things I am used to. It is not so bad\nthat fpm enforces a particular practice, but it should be clear what it\naccepts and that should match our intentions.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 21:23 schreef Brad Richardson <\nnotifications@github.com>:\n\u2026\n To the extent we can, the tests should read very much like the spec. But I\n am in favor of starting with a spec right now, mostly because I believe\n there are aspects of the Haskell version that do not function exactly as we\n want. We should have a discussion about how to handle these situations\n before we start writing the tests.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#133 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRY7GDQKFTCYFW3S2GTR4XTMVANCNFSM4PDXFU6A>\n ."
                }
            ]
        },
        {
            "number": 132,
            "user": "certik",
            "date": "2020-07-21 15:28:57+00:00",
            "title": "Fix tests on macOS",
            "text": "It turns out there were several problems on the macOS runner, all of which this PR fixes:\n\nthe download of the Haskell binary failed due to some SSL handshake error\nthe \"bin\" directory which would host the stack binary does not exist\nthe gfortran binary is no longer pre-installed on macOS (only gfortran-9)\n\nFixes #134.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 17:46:52+00:00",
                    "text": "@everythingfunctional you might want to figure out how to install Haskell on macOS, right now I just downloaded the macOS tarball on my linux, uploaded it to a gist, and let it download from the gist by the CI, so that it works, as we need the CI to be working."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:20:24+00:00",
                    "text": "I don't have access to a mac to test this out, but I suspect it is something that the stack maintainers will fix. They're install script is supposed to support most platforms."
                }
            ]
        },
        {
            "number": 131,
            "user": "certik",
            "date": "2020-07-21 15:11:33+00:00",
            "title": "Initial Fortran infrastructure",
            "text": "This PR moves the Haskell version into a bootstrap directory and creates a new fpm package called fpm, which is the Fortran based fpm. For now the Fortran fpm is just the default \"new\" template, but I modified the print statement. The important part is that it is tested by the CI to build and run on all platforms (Linux, macOS and Windows). This provides the initial infrastructure needed so that others can now start working on the Fortran based fpm, and things will get tested by the CI. Once this is merged, we can send subsequent PRs to depend on other Fortran fpm packages for command line, internet access etc., and slowly start building the functionality that we need.\nPlan for this PR:\n\n Move Haskell based version to a dedicated directory (CI test still builds and tests this version)\n Add initial Fortran version as an fpm package\n\n Make CI test to build the Fortran version using the Haskell version\n\n\n\nEverything that I wanted to get done is implemented. This is ready for review.\nFixes #124.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 15:40:40+00:00",
                    "text": "The macOS failure is unrelated (#134)."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 18:58:42+00:00",
                    "text": "The CI gave me a lot of issues today, but I finally got everything building and passing on all platforms. This is ready for review."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 19:29:19+00:00",
                    "text": "Thanks @everythingfunctional for the review. If it looks good to you, then I am going to go ahead and merge this, so that we can start improving various parts of this in subsequent PRs."
                }
            ]
        },
        {
            "number": 130,
            "user": "milancurcic",
            "date": "2020-07-21 15:09:02+00:00",
            "title": "Catch module+program or multiple modules in a source file and print a helpful message to the user",
            "text": "See #126. fpm currently allows either a single module or a single program in a source file. However, Fortran allows having:\n\nMultiple modules per source file\nModule + program in a source file\nProcedures without modules in a source file\n\nfpm should catch these scenarios and print a helpful error message for the user.",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 06:21:28+00:00",
                    "text": "Just a comment: I noticed that fpm does allow more than one module in a file - and it seems to work: one of the source files I experimented with has a small module to define a type and then a module with the same name as the source file that uses it. So not two independent ones, I agree."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:46:10+00:00",
                    "text": "For simplicity, I think by default fpm should simply expect one module per file, and impose the naming consistency convention. We can discuss if we should implement optional options in fpm.toml to allow more modules per file."
                }
            ]
        },
        {
            "number": 129,
            "user": "milancurcic",
            "date": "2020-07-21 15:04:59+00:00",
            "title": "Handle module name - source file name mismatch and print helpful message to the user",
            "text": "See #128. Currently fpm does not help the user figure out what went wrong if the module name / file name convention is not followed. fpm should detect this and print a helpful message to the user, for example:\nfpm error: I noticed that you defined a module `my` in file `src/mx.f90`. The module name must match the source (path) name. Either rename your module to `mx`, or place it in `src/my.f90`.\n\nor similar.",
            "comments": []
        },
        {
            "number": 128,
            "user": "arjenmarkus",
            "date": "2020-07-21 09:19:20+00:00",
            "title": "Implicit relationship between the names of a module and the source file that contains it assumed",
            "text": "I have run into a problem that is illustrated with the attached project:\n`\n$ d:/fortran/fpm/fpm.exe build\ngfortran (for build/gfortran_debug/mxmy/mx.o build/gfortran_debug/mxmy/mx.mod)\nfpm.exe: Error when running Shake build system:\nat want, called at src\\Build.hs:205:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n\nDepends on: build/gfortran_debug/mxmy/libmxmy.a\nat need, called at src\\Build.hs:203:13 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\nDepends on: build/gfortran_debug/mxmy/mx.o\nat &%>, called at src\\Build.hs:183:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\nDepends on: build/gfortran_debug/mxmy/mx.o build/gfortran_debug/mxmy/mx.mod\nat error, called at src\\Development\\Shake\\Internal\\Rules\\Files.hs:245:13 in shake-   0.18.5-7VS8ovPeUeSCopHgkQQ1Vu:Development.Shake.Internal.Rules.Files\nRaised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\nbuild/gfortran_debug/mxmy/mx.o\nbuild/gfortran_debug/mxmy/mx.mod - MISSING\n`\n\nThe source file is called \"mx.f90\" but it contains a module \"my\". Apparently this is not currently supported, whether by design or otherwise. It seems to me to be a bug.\ntest-fpm-mxmy.zip",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:51:12+00:00",
                    "text": "Hi Arjen, yes, it's by design, see https://github.com/fortran-lang/fpm/blob/master/PACKAGING.md#single-module-library.\nThe rationale is that if we have higher constraints on the user application or library structure, we can design a more robust build system that has a \"sane default\" with fewer edge cases.\nDo you think the packaging guide could be improved in any way?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:55:06+00:00",
                    "text": "However, the unhelpful response from fpm is not by design, but is due to this exception handling not being implemented. In scenarios like this fpm must be helpful to the user, for example:\nfpm error: I noticed that you defined a module `my` in file `src/mx.f90`. The module name must match the source (path) name. Either rename your module to `mx`, or place it in `src/my.f90`.\n\nor similar."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 14:56:14+00:00",
                    "text": "Yes, the default layout that fpm expects is on purpose restricted, similar to how Cargo does it. The module names must be consistent with the filename.\nHowever, I am all for allowing exceptions, which you could specify by hand in fpm.toml. We should do that.\nThe error message is not helpful. But we should work on fixing both of these things in the Fortran implementation (see #124)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 15:02:18+00:00",
                    "text": "It is not criticism :) - just a user experience. I understand the\nlimitations, but an innocent user may run into this sort of things and not\nbe able to pinpoint the cause (as I was not with my other problem).\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 16:56 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Yes, the default layout that fpm expects is on purpose restricted, similar\n to how Cargo does it. The module names must be consistent with the filename.\n\n However, I am all for allowing exceptions, which you could specify by hand\n in fpm.toml. We should do that.\n\n The error message is not helpful. But we should work on fixing both of\n these things in the Fortran implementation (see #124\n <#124>).\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#128 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5JSM22HTKDFHJED3TR4WUB7ANCNFSM4PDLQ2RQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 15:11:32+00:00",
                    "text": "@certik I opened #129 and #130 to track these specific exception handling and error message issues.\nI also created the fpm-fortran tag so that we can tag any issue to be specific to the Fortran implementation and not Haskell. You'll notice that I didn't initially tag #129 and #130 as fpm-fortran, as I'm unsure whether we should leave these unattended for a long time before fpm-fortran is up to speed. I think they're quite critical UI issues."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 19:27:12+00:00",
                    "text": "And I implemented the initial infrastructure for Fortran at #131 to start getting things moving."
                }
            ]
        },
        {
            "number": 127,
            "user": "urbanjost",
            "date": "2020-07-19 12:33:17+00:00",
            "title": "Should fpm automatically make stdlib available, plus some notes on trying the fpm prototype",
            "text": "July 18, 2020\n\n[  ]  I think stdlib should be available via fpm and possibly included by default. It would\nbe a shame if there were not some integration between the projects.\n\nA few comments on fpm (Fortran Package Manager)\n\n\nI could not find a way using \"fpm build\" or \"fpm run\" to work with\nprograms that required external libraries (not always available\nstatically) like X11 Windows and ncurses and various math libraries\ninstalled on my machine. Is there some description of how to set\ncompiler options I missed?\n\n\nI could not get an \"fpm\" command to recognize any compiler except\ngfortran(1).\n\n\nSome type of \"install\" mode is highly desirable to place files in a single location.\nIt should include some way to handle data and documentation files\nas well as the *.a and *.mod files and executables. Otherwise, seperate program\ndevelopment ends up producing a lot of duplication if each program requires the\nsame packages, or you are forced to keep all development in the same file tree.\n\n\nFor builds that build many programs having to put each one in a seperate directory\ncreates a very awkward file layout. Some type of option for executables where\nyou could give a list of specific files to use for building a program might be\na solution. Automatically assuming all files at or below the path is not always\ndesirable even though it makes some cases very simple to configure.\n\n\nThe \"run\" subcommand is fine for a single program, but if you have a number of\ntests or programs it would be nice if it had a \"list\" option.\n\n\nbeing able to search and list entries in a central registry is apparently planned (?)\nbut it would at least be nice if\npackages listed at\nhttps://fortran-lang.org were marked as to whether fpm support\nwas enabled.  As a substitute for a search/list feature I did a\nglobal search (on just github) of the filename \"fpm.toml\" and at\nleast on that site there were not many hits, so maybe this is too\nearly anyway.\n\n\nThe install of fpm(1) required way too much infrastructure. A Fortran-based version\nis planned?\n\n\nHere is a list of my public repositories that are fpm-enabled:\n\n    [dependencies]\n    # worked well with simple single-module projects\n     M_kracken95   = { git = \"https://github.com/urbanjost/M_kracken95.git\" }\n     M_cli         = { git = \"https://github.com/urbanjost/M_cli.git\"  }\n     M_calculator  = { git = \"https://github.com/urbanjost/M_calculator.git\" }\n     M_change      = { git = \"https://github.com/urbanjost/M_change.git\" }  \n     M_color       = { git = \"https://github.com/urbanjost/M_color.git\" }\n     M_history     = { git = \"https://github.com/urbanjost/M_history.git\" }\n     M_io          = { git = \"https://github.com/urbanjost/M_io.git\" }\n     M_msg         = { git = \"https://github.com/urbanjost/M_msg.git\" }\n     M_time        = { git = \"https://github.com/urbanjost/M_time.git\" }\n     M_strings     = { git = \"https://github.com/urbanjost/M_strings.git\" }\n     # uses ISO_C_BINDING but no C wrapper code. fpm(1) worked well\n     M_process     = { git = \"https://github.com/urbanjost/M_process.git\" }\n     #\n     # required creating makefiles:\n     M_system      = { git = \"https://github.com/urbanjost/M_system.git\" }\n     # this did not work satisfactorily ...\n     M_draw        = { git = \"https://github.com/urbanjost/M_draw.git\" }\n\nFor projects not requiring other libraries or C wrappers and just comprised of\na few modules I had no problems.\nAs soon as I needed some C wrappers or needed to build A C library as part of\nthe project it got very difficult. I really could not come up with a satisfactory\nbuild of the M_draw.f90 module, as it requires data files and C routines; and I\ntried a lot of variations. It is not clearly shown in the documentation just how\nyou can use a customized build script or makefile and still have it work cleanly\nwith fpm.\n\n\nInitializing an existing .git directory with \"fpm init\" was problematic as it\nalways tries to initialize git and overwrites README.md. To use \"fpm\ninit\" required Moving the original directory; making new one with\n\"fpm init\"; removing .git and them moving files back.  Would be\nnice if instead of the \"Jane Doe\" fpm.toml file created that it\nuse names from .gitconfig for initial values, and not overwrite\nexisting files like README.md or initialize git(1) if .git exists\nif you run it in an existing directory.\n\n\nIt should at least be noted in the documentation that there is no \"fpm clean\"\noption\n\n\n.F90 files appear to be supported, but with no way to specify preprocessor\noptions; since preprocessors vary between compilers this could get complicated\nbut I was wondering whether a specific preprocessor would be supported in the\nfuture and how options can be passed to one now.\n\n\nIt was easier to just create a Makefile for any legacy codes with routines not\nin modules or when C wrappers were needed, but worked quite well for single-module\nprojects. It was nice to be able to write a program that needed access to file\nsystem information, manipulated strings, printed date and time information and",
            "comments": []
        },
        {
            "number": 126,
            "user": "arjenmarkus",
            "date": "2020-07-18 15:11:25+00:00",
            "title": "Complaints about recursive rules",
            "text": "I tried to use fpm on a somewhat more complex collection of Fortran modules and their test programs. They are all part of my Flibs project (http://flibs.sf.net). I copied the source files for the modules to a directory src and the sources for the test programs to test/xxx (well, for two test programs, to get started). Then I set up a fpm.toml file. All have been attached.\nfpm gave me an error message:\nBuild system error - recursion detected:\nKey type:   FilesQ\nKey value:  build/gfortran_debug/computing/combinations.o build/gfortran_debug/computing/combinations.mod\nRules may not be recursive\nAs all the modules are standalone I am not sure what went wrong. Also, I noticed that with my first attempt it complained about a different (!) module than when I redirected the output.\nIt may be that the problem has already been solved - my version of fpm is one month old.\ntest-fpm-flibs.zip",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:25:52+00:00",
                    "text": "Some of the source files contain a program at the end which uses the module. This use statement signals to the fpm build system that the module depends on itself. Thus, the recursive rule error message.\nBasic fix, remove the example programs from the end of the module source files."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 06:34:17+00:00",
                    "text": "Hi Brad,\n\noh, I will have to check that - I was rather certain there was nothing like\nthat ... Thanks for looking into this.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 01:26 schreef Brad Richardson <\nnotifications@github.com>:\n\u2026\n Some of the source files contain a program at the end which uses the\n module. This use statement signals to the fpm build system that the module\n depends on itself. Thus, the recursive rule error message.\n\n Basic fix, remove the example programs from the end of the module source\n files.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#126 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRYYYOIWSM7W3KDR5WLR4THA3ANCNFSM4PAASMNA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 09:15:18+00:00",
                    "text": "Yes, two of the source files contained a test program (I should have a look at those :)). But when I removed them and tried again, I ran into another issue: a presumed relation between the names of the module and the source file that contains it. I will report it as a separate issue."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:57:56+00:00",
                    "text": "Especially because this (module + program in a source file) is valid, fpm needs to be able to detect this and print a helpful message to the user."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 15:03:58+00:00",
                    "text": "Yes, the error message was puzzling. If you know the design decisions\nand usage constraints it is probably easy enough to locate the cause,\nbut for a novice user it will not immediately be clear.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 16:58 schreef Milan Curcic <notifications@github.com>:\n\u2026\n\n Especially because this (module + program in a source file) is valid, fpm needs to be able to detect this and print a helpful message to the user.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                }
            ]
        },
        {
            "number": 125,
            "user": "arjenmarkus",
            "date": "2020-07-17 07:42:10+00:00",
            "title": "Not so trivial program: Fortran with a bit of C and a prebuilt library",
            "text": "After this month's call, I looked for a small but not entirely trivial program to try fpm with (not trivial in the sense that it consists of several source files, rather than a single one). I found one that is a trifle more complex than any of the examples I have seen and I would like advice on how to deal with it:\n\nIt consists of several Fortran source files and a single C source file\nSome of the Fortran source files require preprocessing (the extension is .F90, so some compilers will do that automatically)\nThe program needs to be linked to a (C) library that has been installed on the system\n\nThe trivial way I build it is via a bunch of compile commands with the required options, so ultimately that could function as a custom build script, but the above set-up seems a fairly common situation.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-17 19:58:55+00:00",
                    "text": "With current functionality, your only option for this is a custom build script. At some point in the future we'll have the capabilities built into fpm to handle linking to a system library and (hopefully) compiling C code, but we aren't there yet."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-18 14:06:12+00:00",
                    "text": "I understand - I already thought that would be the answer :). Consider it another likely scenario that - at some point in time - needs to be supported.."
                }
            ]
        },
        {
            "number": 124,
            "user": "certik",
            "date": "2020-07-16 22:11:29+00:00",
            "title": "Create the infrastructure for the Fortran version",
            "text": "Per our discussion on the phone call:\n\nUse this repository\ncreate a directory \"fortran\" and \"haskell\" (we can call it differently) and put the haskell version into the \"haskell\" directory and start a Fortran version in the \"fortran\" directory\nUse fpm to build the \"fortran\" directory --- it will be just an fpm package\nEnsure haskell fpm can build it\nReuse the test suite for both haskell and fortran\n\nThis is probably the highest priority issue now so I pinned it.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 18:59:55+00:00",
                    "text": "I think the PR #131 that I just finished fixes this issue."
                }
            ]
        },
        {
            "number": 123,
            "user": "certik",
            "date": "2020-07-16 20:07:51+00:00",
            "title": "Allow to generate a standalone tarball with all dependencies",
            "text": "fpm should have a feature like fpm tarball --include-deps that will create a tarball of the current fpm package together with all dependencies and a build system such as CMake (#69), so that one can unpack this tarball at a machine without internet connection, and build everything from scratch (all the dependencies and the main application).\nThere are many usages of this feature:\n\nan application that must run on an HPC machine without internet connection, and I want to distribute it as a tarball that is built using cmake (a common expectation)\nfpm itself --- we can distribute fpm source code like this, and anybody with cmake can then build it from source (no other dependencies needed)",
            "comments": []
        },
        {
            "number": 122,
            "user": "ivan-pi",
            "date": "2020-07-16 19:20:29+00:00",
            "title": "Have fpm define precision",
            "text": "Recent Fortran language resources usually recommend defining a module with constants defining the precision that are later reused throughout the code, for example:\nmodule precision\n  integer, parameter :: sp = kind(1.0)\n  integer, parameter :: dp = kind(1.0d0)\n  integer, parameter :: wp = dp\nend module\nThese kinds of modules are duplicated throughout libraries. This can potentially lead to incompatibilities, i.e. if library 1 uses single precision as default, and library 2 uses double precision. The user is then faced with the problem of either adapting library 1, or making library 2 use the precision module from library 1.\nWould it make sense to have some mechanism to give fpm the \"power\" of enforcing a certain default precision? Hopefully in the long-term most Fortran programmers would default to just using constants from the stdlib precision module. This might not always be enough (i.e. interfacing with C, or perhaps using fpm on some non x86_64 architectures).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-16 19:25:27+00:00",
                    "text": "Great question. I don't know, I am hoping we will encourage the community to use stdlib to get precision. Fpm has the \"power\" to do anything, but the question is how it would work and if it makes sense. Like the promoting of single precision to double?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-17 09:46:23+00:00",
                    "text": "Yes, the entire situation is kind of messy. I have seen some codes which rely on the compiler flags such as -fdefault-real-8 to automatically upgrade real literals such as 1.0 to double precision.\nIn the Fortran METIS interface I used the C preprocessor:\n#ifdef REAL64\n    integer, parameter, public :: real_t = c_double\n#else\n    integer, parameter, public :: real_t = c_float\n#endif\nto allow users to select the precision depending on the version of METIS installed on their system.\nI think it would be good if we could establish some guidelines for package developers whether such precision choices are responsibility of the package developer or the package user, and whether it should be done by 1) a preprocessor (C, fypp) + build system, or 2) the package manager."
                }
            ]
        },
        {
            "number": 121,
            "user": "MarkWieczorek",
            "date": "2020-07-15 21:46:49+00:00",
            "title": "github dependencies are never updated",
            "text": "One method for downloading dependencies is to specify a github project, and optionally a specific branch, tag, or commit. However, once the entire git project is cloned, it is never updated.\nAn option should be provided to allow to update the dependencies when they change at github. In my opinion, if a specific tag or commit is not specified, the default behavior should in fact be to check for updates automatically.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-15 23:16:10+00:00",
                    "text": "Actually I think we should do it like Cargo --- fpm determines a particular version that satisfies your fpm.toml, and generates fpm.lock. Then it never checks or updates any dependencies, it simply uses fpm.lock which has the exact dependency pinned down. But you can run fpm update command that will update your dependencies (and updates your fpm.lock file). More info:\nhttps://doc.rust-lang.org/cargo/commands/cargo-update.html"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 23:47:29+00:00",
                    "text": "Right now it's not doing anything to check that the version that is there is the right version, that it was cloned and checked-out correctly, etc, just that there is something there.\nWe haven't come up with a coherent strategy for version constraint checking, let alone version constraint solving, so I've just punted on doing anything for now. We'll probably look at what Cargo's solution was.\nThe solution that @certik described is what many (most?) language specific package managers have settled on. It prevents things in your code from breaking randomly because somebody pushed a bug to their repository."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-16 09:27:03+00:00",
                    "text": "A related feature request is the following: Instead of cloning the entire repo, it would be useful in many instances (to speed up the download process) to only do a shallow clone (with git clone --depth=1). I'm not sure what the default beviour should be, but it would be useful to at least have the option."
                }
            ]
        },
        {
            "number": 120,
            "user": "MarkWieczorek",
            "date": "2020-07-14 12:30:13+00:00",
            "title": "\"name\" should not be a required fpm.toml keyword for files that do not link to an fpm library",
            "text": "In the current configuration, it is necessary to specify a name keyword at the top of the fpm.toml file. This name is used to name the directory that contains the .mod, .a, and .o files that are used to generate a static library.\nHowever, if you have a project with only a single file in the app folder, there is no need to have a src folder nor to compile a library at all. In this case, however, if you omit the name keyword, fpm will exit with the error tomland decode error:  Key name is not found\nFurthermore, in my opinion, the name keyword should not be at the head of the file, but should more logically be under the [library] heading, as this is where all the information about the compiled archive is listed. (This would be analogous to name in [[executable]]).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-14 15:48:46+00:00",
                    "text": "If you create a new package with Cargo, say cargo new y, then you get the following Cargo.toml:\n[package]\nname = \"y\"\nversion = \"0.1.0\"\nauthors = [\"Ond\u0159ej \u010cert\u00edk <ondrej@certik.us>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nSo the name is simply the name of the package. Even if it is just a simple executable. So I think the name should stay, it's the name of the project."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:36:06+00:00",
                    "text": "name is used as the default for many things, so you do need it. Otherwise, you'd need to be explicit about everything and likely repeat yourself, which we're trying to avoid for common use cases."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 17:05:03+00:00",
                    "text": "If that is the case, shouldn't\n[[executable]]\nname =\n\nbe set by default to name? If you don't set the executable name, you get a similar error.\nEncountering this project for the first time, it wasn't really obvious what the parameters in the fpm.toml file mean. In addition to this, there is also\n[library]\nsource-dir\n\nwhich is the directory for files used to compile .mod and .a files. However\n[[executabe]]\nsource-dir\n\nCorresponds only to the name of the directory in build/gfortran_debug  where you find the compiled executable."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 18:22:59+00:00",
                    "text": "Yeah, we haven't worked through all of the possible combinations of fpm.toml inputs and under what combinations defaults should work. For example\n[[executable]]\nsource-dir = \"app1\"\nshould probably work with the \"defaults\" for name and main, but\n[[executable]]\nsource-dir = \"app1\"\n\n[[executable]]\nsource-dir = \"app2\"\nwould need to complain about conflicting names for the executables.\nThe documentation almost certainly needs work and clarification."
                }
            ]
        },
        {
            "number": 119,
            "user": "MarkWieczorek",
            "date": "2020-07-14 12:16:41+00:00",
            "title": "Link to precompiled system-wide archives",
            "text": "fpm is great for including external fortran projects as dependencies (typically downloaded at github).\nHowever, it often arises that a fortran project needs to link to an already compiled system-wide archive, such as lapack or fftw. At present, to the best of my knowledge, there is no simple way to link to such files in fpm. It is possible that this might be possible using a Makefile, but that would be non-optimal.\nIdeally, the libraries to link to would be placed in the fpm.toml file,  something like this:\nlink = 'fftw, lapack'",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:13:16+00:00",
                    "text": "This is certainly on our radar. We just haven't gotten to it yet."
                }
            ]
        },
        {
            "number": 118,
            "user": "MarkWieczorek",
            "date": "2020-07-10 21:14:34+00:00",
            "title": "Compile archive using pre-existing Makefile",
            "text": "I have a somewhat complicated archive that is compiled with a pre-existing Makefile, and I would like to make this more accessible to those who might want to use it as a fpm dependency.\nBased on the documentation, I thought that I would just need to specify the name of the Makefile in the fpm.toml file, but this obviously didn't work.\nI think that it would be very useful for fpm to have have the option of simply executing a pre-existing makefile, and then placing the compiled .mod and .a files wherever it is that they are needed. Ideally, this would be specified in the fpm.toml file something like this:\n[library]\nmakefile = \"make all F95=$(FC) DIR=$(BUILD_DIR)\"\n\nAlternatively, given that the .mod and .a files are initially found in the src directory, instead of having the makefile manually move them to $(BUILD_DIR), this could be done by fpm itself after the makefile successfully terminates.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-11 00:33:19+00:00",
                    "text": "We certainly want to try and make migrating existing projects to fpm as easy as possible. The questions that need to be answered to solve this problem are:\n\nHow does fpm figure out how to call the makefile? You're example shows something that might be workable\nHow does fpm figure out where the makefile put the stuff it needs to copy? This one's a bit harder\n\nOn the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands. It's a tad less portable, but a pretty straightforward workaround."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-11 09:40:46+00:00",
                    "text": "On the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands.\n\nIs it possible for fpm to run a script now (without compiling files) ? That would probably work for me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 14:45:56+00:00",
                    "text": "@MarkWieczorek, yes. Check out the details here. Let us know if anything is unclear or you get stuck."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-13 20:52:32+00:00",
                    "text": "I am starting to make some progress.\nFirst, it turns out that if you have your own Makefile from a pre-existing project\n[library]\nsource-dir=\"src\"\nbuild-script = \"make all\"\n\nand\n[library]\nsource-dir=\"src\"\nbuild-script = \"Makefile\"\n\ndo not do the same thing. The first example actually does what I want (i.e., just do a make all in shell) but the second seems to try compile my source files using fpm.\nSecond, if you exclude the src-dir line, the following doesn't work as expected:\n[library]\nbuild-script = \"make all\"\n\nThis suprises me, because fpm doesn't need to know where my source files are, given that everything is to be compiled by my pre-existing makefile.\nI think that part of the solution will be to refactor the documentation, and describe what is actually happening with the above commands. It would be very useful to have a section in the documentation describing how to port a pre-existing project to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 20:54:57+00:00",
                    "text": "We should have tests for all of the above, then it will at least be clear what is supposed to work."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-13 21:25:29+00:00",
                    "text": "One final thing:\nEverything works when using\nname = \"project\"\n[library]\nsource-dir=\"src\"\nbuild-script=make all F95=$FC\n\nHowever,  fpm build ends with the error/warning\nmake: *** No rule to make target `/path/build/gfortran_debug/project/libproject.a'.  Stop.\n\nThis is because (as stated in the docs) \"Additionally, script will be called with the name of the archive (*.a file) that should be produced as the command line argument.\"\nIs there a way to disable this behavior?"
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 11:52:41+00:00",
                    "text": "I've encountered one final problem, which unfortunately is the most important for me.\nFirst, I can successfully compile my project locally using a pre-existing makefile, as described above. The makefile moves all the .mod and .a files to BUILD_DIR, which is located in the main directory at\ngfortran_debub/project/\n\nHowever, if I try to use my project as a dependency (downloaded from github) in another project, the .mod and .a files are located at\nbuild/dependencies/project/build/gfortran_debug/project/\n\nand the following directory is empty:\nbuild/gfortran_debug/prioject/\n\nWhen building the code that makes use of the dependencies, fpm can no longer find where the dependency .a and .mod files are located.\nDoes anyone have any ideas on how to solve this problem? Obviously the files from build/dependencies/project/build/gfortran_debug/project/ need to be copied to build/gfortran_debug/prioject/, but I don't see how to do this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:22:17+00:00",
                    "text": "In your case, I'd recommend using a wrapper script to make doing things properly a bit easier. Something like\n#!/bin/bash\n\nexpected_archive=$1\n\nmake all F95=$FC\ncp where/your/*.mod $BUILD_DIR\ncp where/your/archive.a $expected_archive\nbecause, as you've noticed, the build directory will be different when included as a dependency. If you can, you should try and make use of the FFLAGS environment variable as well, so in the future, projects using yours can try out different compiler flags."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 20:09:30+00:00",
                    "text": "That might work, but what would I use as the argument to the script ($1) ?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 22:01:13+00:00",
                    "text": "fpm calls that script with the appropriate argument. So assuming your script is called build_script.sh, your fpm.toml would look like\n...\n[library]\nsource-dir = \"src\" # presumably\nbuild_script = \"build_script.sh\"\n...\nand fpm will call your script (effectively) like\nFC=gfortran FFLAGS=\"-some -flags ...\" BUILD_DIR=\"wherever/fpm/decides\" INCLUDE_DIRS=\"build/thing1 build/package2 ...\" build_script.sh some/where/libpackage.a"
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 22:25:11+00:00",
                    "text": "@everythingfunctional why not pass everything as environment variables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 23:05:22+00:00",
                    "text": "I'm not sure I have a thoroughly compelling answer, but my thinking is along the lines of the following:\n\nWe should conform to common practices in existing build systems\nCommon build commands (or at least the ones I'm used to) are of the form build_script what_I_would_like_built\nA common practice for overriding build parameters is via environment variables\n\nI'd agree it's not the most elegant and consistent design, but if our goal is to make migrating to fpm easier, conforming to existing practices is probably the way to go."
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 23:23:38+00:00",
                    "text": "I would suggest to follow Cargo's approach, and not invent our own conventions.\n\u2026\nOn Tue, Jul 14, 2020, at 5:05 PM, Brad Richardson wrote:\n\n\n I'm not sure I have a thoroughly compelling answer, but my thinking is\n along the lines of the following:\n\n  * We should conform to common practices in existing build systems\n  * Common build commands (or at least the ones I'm used to) are of the\n form `build_script what_I_would_like_built`\n  * A common practice for overriding build parameters is via environment\n variables\n I'd agree it's not the most elegant and consistent design, but if our\n goal is to make migrating to fpm easier, conforming to existing\n practices is probably the way to go.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#118 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWEBAUPZFHBQJ6YSGPTR3TQD7ANCNFSM4OW6ADFA>."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-15 07:47:26+00:00",
                    "text": "some/where/libpackage.a\n\nAnd what about the .mod files?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 18:34:25+00:00",
                    "text": "The mod files need to go in the same place."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 18:41:02+00:00",
                    "text": "I would suggest to follow Cargo's approach, and not invent our own conventions.\n\u2026\nOn Tue, Jul 14, 2020, at 5:05 PM, Brad Richardson wrote: I'm not sure I have a thoroughly compelling answer, but my thinking is along the lines of the following: * We should conform to common practices in existing build systems * Common build commands (or at least the ones I'm used to) are of the form build_script what_I_would_like_built * A common practice for overriding build parameters is via environment variables I'd agree it's not the most elegant and consistent design, but if our goal is to make migrating to fpm easier, conforming to existing practices is probably the way to go. \u2014 You are receiving this because you commented. Reply to this email directly, view it on GitHub <#118 (comment)>, or unsubscribe https://github.com/notifications/unsubscribe-auth/AAAFAWEBAUPZFHBQJ6YSGPTR3TQD7ANCNFSM4OW6ADFA.\n\nI think Cargo's approach is really good, and we should strive for it. In the mean time, we don't yet support using Fortran as a build script, and their approach doesn't support any other custom (or existing) build scripts, like we would (maybe) like to support."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 20:03:47+00:00",
                    "text": "Cargo requires to write Rust code for the script. We should allow other scripts such as Bash or Makefile, as we discussed. But they should be treated exactly the same as the (future) Fortran script (if we decide to allow that, or just require Bash or Makefile).\nThe API is described here:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html\nThe script is run as is (with no arguments) and everything is passed using environment variables:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html#inputs-to-the-build-script\nAnd the outputs are communicated by printing to stdout using the \"cargo:...\" encoding:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script\nCan we do the same for fpm?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 21:06:55+00:00",
                    "text": "I think we should move towards Cargo's API design. Then the communication mechanism can be the same for any build script; inputs as environment variables, outputs as prefixed lines on stdout.\nThere is a subtle distinction between Bash, Makefile, and Fortran build scripts though that they aren't treated exactly the same. Fortran must be compiled first, potentially with some dependencies if we're following Cargo's design. Bash scripts are executed directly, and Makefiles must be executed with make.\nI also don't know that this design will make it any easier to transition existing projects to fpm. There is virtually no chance that an existing build system will \"just work\" with this design, but that chance was probably pretty small with my design anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 21:16:43+00:00",
                    "text": "Perfect, thanks. Yes, I agree it won't make it easier for other projects to port, but by using the same design as Rust, at least they don't have to update their build scripts once they port (currently they will have to update the makefile / bash script after we change the API).\nUsing Fortran as a script sound weird at first, but make sense from a multiplatform perspective, as it would run natively on Windows and other platforms, while Bash typically does not run natively, but requires a linux subsystem on Windows. I think that's why Cargo chose Rust as the script."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-15 21:39:52+00:00",
                    "text": "I think that there is a very simple solution for projects that compile with pre-existing makefiles: We just need to define two environment variables.\n\nBUILD_DIR is already defined, and tells where to put the .mod and .a files within the original project. This would either be in the directory build/gfortran_debug/project if you were simply building the project by itself, or in build/dependencies/gfortran_debug/project if you were installing it as a dependency.\nINSTALL_DIR, which is where the contents of BUILD_DIR get copied when the project is installed as a dependency. This corresponds to BUILD_DIR/../../gfortran_debug/project.\n\nIn practice, the makefile would compile all the .mod and .a files in BUILD_DIR, and only if INSTALL_DIR is defined would they then get copied to INSTALL_DIR."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 23:23:58+00:00",
                    "text": "Something like that. Here is the list of environment variables that Cargo defines:\nhttps://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts\nnote that most are prefixed with CARGO_, but some are not. I suspect the ones that are not are due to historical reasons. I very strongly suggest we prefix all our environment variables by FPM_, so it would be FPM_BUILD_DIR and FPM_INSTALL_DIR. The reason is that it is very easy to make complex 3rd party build systems fail if you define an environment variable with a common name like BUILD_DIR or INSTALL_DIR, because the customized 3rd party build system can easily do something different if this variable is defined. By prefixing all variables, we ensure that our environment variables do not clash with user defined variables. It's a good habit to do that, not to pollute the environment namespace."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 23:55:50+00:00",
                    "text": "A quick note, BUILD_DIR is always build/<compiler>_<debug_or_release>/project, whether it's building your project standalone or as a dependency. So when building your project as a dependency, the BUILD_DIR is not within your project's directory. Thus, no need for the INSTALL_DIR variable."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-16 08:48:18+00:00",
                    "text": "Thanks for all the help: I turns out that I was misinterpreting how BUILD_DIR was being set for stand-alone projects and dependencies. (I also made a dumb choice to hardcode the variable build/gfortran_debug/myproject in the makefile for the standalone project). Using\nbuild-script = \"make all F95=$FC LIBPATH=$BUILD_DIR MODPATH=$BUILD_DIR\"\n\nnow works for both cases :) The only thing I need to do to make this work is to be able to link to system-wide libraries.\nOne final question: how do I change debug to release ?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-29 20:17:34+00:00",
                    "text": "Could the Makefile of stdlib be already used to compile stdlib with fpm?"
                }
            ]
        },
        {
            "number": 117,
            "user": "everythingfunctional",
            "date": "2020-07-08 18:25:48+00:00",
            "title": "Fix bug with case in program source file name.",
            "text": "Fix #116\nI guess up to now nobody had tried using uppercase in the name of their program source file. This fixes it.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-07-11 21:47:28+00:00",
                    "text": "Nice timing. This was vexing me and I had just found the work-around and was going to report the bug.  Guess it is time to update my copy of fpm(1). That raises the question of whether there should be a line to put in the input files indicating what version of fpm(1) was tested with (which might produce a warning) and what version is at (at least) required? \\\nI would change the pathname back to containing uppercase letters but I am  afraid it would confuse anyone attempting to use the repository with an older version of fpm(1), for example.\nI was working on setting up the following for use with fpm(1) when I hit the problem:\n[dependencies]\n M_process      = { git = \"https://github.com/urbanjost/M_process.git\" }\n\nC SUPPORT?\nI see others have mentioned at least supporting C wrappers for use with the intrinsic module ISO_C_BINDING; but unless that is imminent does anyone have an example using a custom build script that does that? I have a bunch of stuff (M_system, M_draw, M_ncurses, ... that has C wrappers or bindings that I wanted to try with fpm(1) but that is a show stopper; whereas STACK has good multi-language support, etc..\nREVIEW?\nI have a bunch of stuff I was trying with fpm(1) so if anyone has time to comment on how I have used (abused?) it so far, M_process and M_time are about done as far as what I was planning on.\nPRETTY PICTURE WANTED?\nAny kind of an image to place on pages that support fpm(1)? A glowing box with light coming out of it with a big \"F\" above the box?  Anyone feeling artistic?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 16:05:55+00:00",
                    "text": "@urbanjost , I have an example wrapping a C library here.\nIf I can find some free time I'll try and give your project a look."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-13 18:45:36+00:00",
                    "text": "@certik can you please review this or approve without review? This fix allows some users to build their packages."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 20:06:53+00:00",
                    "text": "This looks good, the fix is simple and tests pass."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-07-16 01:39:47+00:00",
                    "text": "The C wrapper and Makefile and fpm example project file are great. It was not clear from the documentation I had found so far how to do that. I wil see how far I get in the next few days.  Not knowing how to do this was preventing me from going much further with my fpm experiments."
                }
            ]
        },
        {
            "number": 116,
            "user": "lauvergn",
            "date": "2020-07-08 12:03:45+00:00",
            "title": "fortran main name file",
            "text": "I found an issue related to the name of the main fortran file.\nWhen main.f90 is in the app directory, the executable is created nicely. Part of the fpm.toml file is:\n\n[[executable]]\nname=\"TEST_dnS.x\"\nsource-dir=\"app\"\nmain=\"main.f90\"\n\nHowever, when, I'm using another name (TEST_dnS.f90)\n\n[[executable]]\nname=\"TEST_dnS.x\"\nsource-dir=\"app\"\nmain=\"TEST_dnS.f90\"\n\nI've got some errors:\n\nfpm: Error when running Shake build system:\nat want, called at src/Build.hs:114:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n\nDepends on: build/gfortran_debug/app/TEST_dnS.x\nat need, called at src/Build.hs:120:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nDepends on: build/gfortran_debug/app/test_dns.o\nat &%>, called at src/Build.hs:137:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nDepends on: build/gfortran_debug/app/test_dns.o build/gfortran_debug/app/test_dns.mod\nat undefined, called at src/Build.hs:142:25 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nat error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err\nRaised the exception:\nPrelude.undefined",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:16:36+00:00",
                    "text": "That looks to me like it's expecting a test_dns module. Perhaps there is a uppercase/lowercase mismatch in the file name? Maybe try deleting the build directory to start fresh?\nI can maybe try and dig deeper later today if none of those work."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 15:24:22+00:00",
                    "text": "Perhaps there is a uppercase/lowercase mismatch in the file name?\n\nI thought about that too, but it is not that.\n\nMaybe try deleting the build directory to start fresh?\n\nI've tried that as well (several times!!)"
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 16:33:34+00:00",
                    "text": "I can maybe try and dig deeper later today if none of those work.\n\nThanks, you can get the full test here:\nhttps://github.com/lauvergn/test-fpm"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 18:18:53+00:00",
                    "text": "Figured out the problem. The build process for the executable isn't handling upper-case vs lower-case correctly for the name of the source file vs the name of the object file. I'll get a fix put together shortly."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 18:21:15+00:00",
                    "text": "Figured out the problem. The build process for the executable isn't handling upper-case vs lower-case correctly for the name of the source file vs the name of the object file. I'll get a fix put together shortly.\n\nThanks"
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-09 12:58:04+00:00",
                    "text": "Thnanks"
                }
            ]
        },
        {
            "number": 115,
            "user": "lauvergn",
            "date": "2020-07-08 07:50:32+00:00",
            "title": "Moving a fpm package structure to another one",
            "text": "In a way, it is not an issue about the actual fpm tool, but something which might be annoying in the future.\nLet assume, you have package with one or several libraries, so the fpm tree is:\n\nsrc/math_constants/\nsrc/phys_constants/\n\nSo a fortran files is math_constants_xxx.f90 and its corresponding module name is math_constants_xxx.\nNow, if one wants to move this structure to a more complex one (or it is taken from another package):\n\nsrc/Util/math_constants/\nsrc/Util/phys_constants/\n\nThen it means, you have to change:\n\nall module names inside the library and also in the other part of the code (much more complex, although with some ide it is doable)\n\nI think fpm needs some tools to perform such features.\nalias gardhor",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-08 15:11:00+00:00",
                    "text": "Yes, we discussed this exact issue in the past and we all agree that fpm should be able to fix up your code when you move files around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:13:28+00:00",
                    "text": "Yeah, I could definitely see that being a desired refactoring, and it certainly would be a chore to do manually.\nSolving this properly will involve a more complete Fortran parser than we've needed so far. This and other desired features are making it pretty clear that we're going to need one.\nSome thoughts on what the user interface might look like:\n\nfpm move <old-name> <new-name>\nfpm rename <old-name> <new-name>\nMaybe have a separate tool?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-08 15:19:00+00:00",
                    "text": "Actually the API I was thinking of would be:\n\nfpm fix_module_names or something like that, and it would go into each file and ensure the module name corresponds to the path.\n\nBut I can see that fpm move would also be useful to fix all use statements.\nThese are all things that we should do in the Fortran version of fpm."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-08 15:32:49+00:00",
                    "text": "Just an idea. Could it be part of fpm build? Example:\n$ fpm build\n...\n...\nfpm error: I found inconsistent module name in src/a/b/util.f90. Do you want me to fix it? [y/n/a]\n\nSo an error would trigger a prompt from user, which could be overriden with a flag like fpm build --fix-all or similar.\nLike with many other software things, it's a design compromise between many small commands versus fewer more general commands. I don't know what's nicer for the average user."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 15:44:12+00:00",
                    "text": "fpm fix_module_names or something like that, and it would go into each file and ensure the module name corresponds to the path.\n\n\nA tool like that will be great also to move (or to help moving) a none-fpm package to a fpm one."
                },
                {
                    "user": "certik",
                    "date": "2020-07-08 15:47:03+00:00",
                    "text": "@milancurcic and @lauvergn yes to both. For fpm build, perhaps with an option fpm build -i (as in interactive), since I think the build should not wait for user input by default, as it would stall on CIs."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:49:51+00:00",
                    "text": "Yep, I agree. Both of those would also be useful additions. To the extent possible fpm should provide meaningful error messages and help the user fix any problems related to the conventions/restrictions that it imposes."
                }
            ]
        },
        {
            "number": 114,
            "user": "smeskos",
            "date": "2020-07-07 13:05:05+00:00",
            "title": "module naming issue",
            "text": "I found out after a lot of trouble that I couldn't build my project because I had all the modules files in src/ in the form mod_name.f90, when I renamed all files to m_name.f90 and the modules to module m_name respectively, it recognized them all and built successfully.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 14:06:09+00:00",
                    "text": "Right, it's an important detail. :)\nI'm curious, did you read the Packaging Guide beforehand? If not, perhaps we need to link to it more prominently from the README. Currently it's at the bottom. If you did read it, was any part of the guide confusing?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:11:10+00:00",
                    "text": "Yes, I read it. Let me rephrase, the problem was not with the same name, I already had my files and modules named the same. The problem is with the particular style: mod_name.f90 and module mod_name. It couldn't recognize modules starting with the prefix mod_."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 15:17:44+00:00",
                    "text": "Okay, I see. I don't think that should be the case. @everythingfunctional can you confirm this behavior? Is it expected?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:34:49+00:00",
                    "text": "We discussed the naming convention in #39 a bit.\nI think the above seems to be a bug either way, but in general, we were thinking that we could simply name the modules by a name, and then fpm would enforce the directory structure in the name. So if you are calling your module as mod_name, and put it into src/a/b/mod_name.f90, then fpm would enforce that the module is called a_b_mod_name, but the filename is just mod_name.f90. That way we are essentially allowing to have namespaces."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:36:38+00:00",
                    "text": "The other issue related to this is that all modules should probably be prefixed by the name of the package, again, enforced by fpm. That way when you depend on it in other dependencies, the modules do not clash. So src/mymod.f90 would start with module mypackage_mymod."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:41:29+00:00",
                    "text": "CCing @everythingfunctional, it's important that we get this right soon.\nI think the way we could do it is to implement what I described above by default and fpm would give an error if the modules are not named correctly. But users could override this in fpm.toml, if they really do not want to use this convention, say with module_naming_convention = false or something like that.\nFor example, in stdlib we already are naming modules like stdlib_experimental_io. After we move stdlib to use fpm, we would have a directory structure: src/experimental/io.f90, and since the package is called stdlib and since io.f90 is in the experimental directory, the file would start with module stdlib_experimental_io (as it already does). After the module graduates to stable, we move it to src/io.f90 and it would start with module stdlib_io."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 15:50:48+00:00",
                    "text": "The other issue related to this is that all modules should probably be prefixed by the name of the package, again, enforced by fpm. That way when you depend on it in other dependencies, the modules do not clash. So src/mymod.f90 would start with module mypackage_mymod.\n\nI agree that we need some solution to prevent name clash with dependencies, but this solution doesn't look like a good one to me. Consider datetime-fortran, which has the package name \"datetime\", and one module that contains a derived type datetime. How do you suggest I name the module?\nThe way it's named currently (datetime_module), this would require that I rename the module source file to src/module.f90. It works but it's very awkward to me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-07 16:52:55+00:00",
                    "text": "If  mod_name as the name of a module was not working but m_name was, that's a bug. I'm not sure what the problem is offhand.\nI think enforcing modules in a library be prefixed by the project name is probably overkill. If namespacing is needed, we have a way to do that. Just put everything in a folder with the name of the library. I'm not sure having that be the default is necessary."
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 20:02:58+00:00",
                    "text": "I tried to replicate my issue with a smaller test case, and I couldn't, this time, fpm worked fine with modules with prefix mod_.  I also tried https://github.com/wavebitscientific/functional-fortran from  @milancurcic (since his modules are with mod_) and it also worked fine. I can only guess that I am missing something in my main project. I am going to look into it and will come back when I figure it out. Sorry for this false alarm. Regardless, your comments were very interesting and helpful. Thank you all!"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 20:28:42+00:00",
                    "text": "@smeskos I am glad it works!\n@everythingfunctional I don't know. We should discuss it. I feel module names without prefixes should be reserved for the main (user) application. Libraries should hide their modules behind a prefix. That is the common convention in C, which has the same problem (all functions being global). So if we agree that is a good convention, then we should enforce it (users can opt-out)."
                }
            ]
        },
        {
            "number": 113,
            "user": "smeskos",
            "date": "2020-07-07 12:57:28+00:00",
            "title": "preprocessor directives",
            "text": "I am trying to build a simple logging library I wrote some time ago. In order to get file names and current line number I use a small preprocessor file: macros.h that only contains:\n#ifndef FL\n#define FL __FILE__\n#endif\n\n#ifndef LN\n#define LN __LINE__\n#endif\nand I include it at the beginning of the file I want to use it like #include \"macros.h\"\nI get this error when I am trying to build with fpm:\nExit code: 1\nStderr:\ntest/main.f90:1:2:\n\n    1 | #include \"marcos.h\"\n      |  1\nWarning: Illegal preprocessor directive\ntest/main.f90:8:20:\n\n    8 |     call log%info(FL, LN, 'Passed')\n      |                    1\nError: Symbol \u2018fl\u2019 at (1) has no IMPLICIT type\ncompilation terminated due to -fmax-errors=1.\nNote that this is with main.f90\nWhen I changed the name to main.F90and the fpm.toml file accordingly:\n[[test]]\nname=\"runTests\"\nsource-dir=\"test\"\nmain=\"main.F90\"\nThen I got this error:\nExit code: 1\nStderr:\ntest/main.F90:2:2:\n\n    2 | program test\n      |  1~~~~~~~~~\nFatal Error: marcos.h: No such file or directory\ncompilation terminated.\nAny suggestions of what I may be doing wrong?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 14:08:37+00:00",
                    "text": "Is your include file macros.h or marcos.h? Currently your f90 file tries to include marcos.h but perhaps the file is called macros.h."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 14:30:27+00:00",
                    "text": "As discussed in #78, the .f90 files should also be run through the pre-processor, perhaps no by default (for speed reasons), but if you enable it in the fpm.toml."
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:06:36+00:00",
                    "text": "@milancurcic You are correct that was a typo, but the problem persists after correcting it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 15:17:42+00:00",
                    "text": "Hi @smeskos, is the macros.h file in the same folder as the .f90 files that include it?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:32:22+00:00",
                    "text": "@LKedward right, that was the problem. I had this in src/ but I wanted to use it in test/. Thank you!!"
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 16:27:33+00:00",
                    "text": "Glad that fixed it!\nWe may potentially need an option to manually specify an include path or have a standard include folder (include/) which contains text inclusions; consider the case if you needed to use macros.h from both src/ and test/"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 19:46:06+00:00",
                    "text": "Thank you again. I am closing this."
                }
            ]
        },
        {
            "number": 112,
            "user": "smeskos",
            "date": "2020-07-07 12:39:16+00:00",
            "title": "Managing flags",
            "text": "Is it possible to add/remove flags and reset back to defaults if needed?\nIs there an option to display flags (before building)? (eg. fpm show flags)",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-07 14:31:37+00:00",
                    "text": "@smeskos what flags do you have in mind? Compiler flags?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 14:58:42+00:00",
                    "text": "Yes I mean compiler flangs."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:10:20+00:00",
                    "text": "I don't think it's possible currently, but we need to have it.\nProbably fpm.toml should allow to set flags for specific compilers per file.\nHowever, even more important is to extract common flags into general settings that work across compilers.\nWhat flags would you like to set @smeskos ?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:22:19+00:00",
                    "text": "I would like to set -cpp, -Wconversion and -std=f2018.  But most importantly to suppress warnings (per case), eg. many times when I am still testing something and is under-development I set -Wno-uninitialized-variables and others as well, the reason is that I don't want to pollute the output with dozens non-relevant warnings."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 15:28:07+00:00",
                    "text": "+1 for customising compile flags for debug/release.\nAlso need an option for specifying link flags for linking against external libs like BLAS etc."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:29:00+00:00",
                    "text": "Ok, so let's take it on a case by case:\n\n\n-cpp should be done in a general manner as discussed in #78.\n\n\n-std=f2018 should also be done in a general manner (that works with all compilers), probably an fpm.toml setting such as \"standard = F2018\" or something like that.\n\n\nThe -Wconversion should be enabled by default, together with all other common warnings\n\n\n-Wno-uninitialized-variables this is the one where we need to allow to set a specific option per file. It could also be done from a command line.\n\n\nSo we need a general solution, but the most common use cases (such as 1., 2. and 3. above) should be abstracted out and fpm should know how to deal with those."
                }
            ]
        },
        {
            "number": 111,
            "user": "certik",
            "date": "2020-07-06 20:09:15+00:00",
            "title": "Introduce --lib to initalize a project with a library",
            "text": "Currently this is the default, but there should be an option for the default value also (in addition I propose that this should not be the default in #109).",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-06 21:22:27+00:00",
                    "text": "I would combine this, #109, and #110 into a single issue, as these are all related.\nFor renaming the command line flags, I'm open to that. I tend to lean towards the more verbose to help make things more \"self documenting\", but understand that's not always the most popular way for everything.\nIn general, there are 3 (partially) independent pieces that fpm might create for a new project: src/project.f90, app/main.f90, and test/main.f90. Let's say the command line flags for each are --app, --lib, and --test.\nIf I understand correctly, you're suggesting that the default should be fpm new --app --lib name.\nIn order to not include an app, you'd then want a --no-app flag. So, should we have both flags, or just the ones for the opposite of the default? Having both would imply a total of 6 flags, each of which is mutually exclusive with the other; --app or --no-app, --lib or --no-lib, and --test or --no-test. But, we only really need the flags --no-app, --no-lib, and --test. And then a user can't actually specify contradictory flags, because there aren't any.\nExcept for one question. Should we allow fpm new --no-lib --test name? It doesn't actually break anything, but is kind of strange, because at that point what are you going to be testing?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-06 22:16:39+00:00",
                    "text": "Good point. In Cargo, the --lib and --bin (as Cargo calls it) are mutually exclusive, so specifying --lib means no --bin.\nGiven the slight differences in Fortran and Rust and how modules are called, we can change this and figure out what makes sense for Fortran.\nBut the naming and default I think can be the same. \"fpm new\" would create the default app / executable. In addition, it can still create a library. Perhaps we'll always create a library, so perhaps --lib will always be on.\nAs long as:\nfpm new x\ncd x\nfpm run\n\nworks and executes the executable, then I am fine. The above I feel will be a very common workflow to test something out, whether to test out some library, or some Fortran construct, or some quick idea.\nI think you start a new Fortran library much less often. Sort of like writing a Python script vs starting a new Python library that you upload on pypi. I do the script much more often.\nLet's get an agreement on that first. Since you agree with the renaming of the options, those are the two main things I care about. We can discuss how exactly the --lib works later as we gain more experience with fpm."
                }
            ]
        },
        {
            "number": 110,
            "user": "certik",
            "date": "2020-07-06 20:07:33+00:00",
            "title": "Rename --with-executable to --bin (or --app)",
            "text": "So that it is easier to type. Although in #109 I argue it should be the default.",
            "comments": []
        },
        {
            "number": 109,
            "user": "certik",
            "date": "2020-07-06 20:05:55+00:00",
            "title": "fpm new should do --with-executable by default",
            "text": "That is what Cargo does and what I also find intuitive. Very common when I want to just try something out in Fortran.",
            "comments": []
        },
        {
            "number": 108,
            "user": "milancurcic",
            "date": "2020-06-24 16:15:59+00:00",
            "title": "rename reference to other fpm",
            "text": "Minor change to the README to not use the word \"effing\" when referring to the other fpm.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-24 16:26:59+00:00",
                    "text": "Merging as previously agreed on by @certik and @everythingfunctional ."
                },
                {
                    "user": "certik",
                    "date": "2020-06-24 16:28:03+00:00",
                    "text": "+1, thank you @milancurcic !"
                }
            ]
        },
        {
            "number": 107,
            "user": "ivan-pi",
            "date": "2020-06-21 15:21:22+00:00",
            "title": "Projects including legacy files",
            "text": "I've been trying to get fpm to work with some old-school packages like MINPACK: https://github.com/certik/minpack. These projects are generally just a bunch of fixed format \".f\" files. For modern applications that rely on such legacy codes, an interface module is the first step towards safe function calls.\nTrying to run fpm build on @certik's MINPACK fails with errors akin to:\nfpm build --release\n# gfortran (for build/gfortran_release/minpack/rwupdt.o build/gfortran_release/minpack/rwupdt.mod)\n# gfortran (for build/gfortran_release/minpack/dmchar.o build/gfortran_release/minpack/dmchar.mod)\n# gfortran (for build/gfortran_release/minpack/lmpar.o build/gfortran_release/minpack/lmpar.mod)\n# gfortran (for build/gfortran_release/minpack/hybrd.o build/gfortran_release/minpack/hybrd.mod)\nfpm: Error when running Shake build system:\n  at want, called at src/Build.hs:205:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/libminpack.a\n  at need, called at src/Build.hs:203:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/rwupdt.o\n  at &%>, called at src/Build.hs:183:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/rwupdt.o build/gfortran_release/minpack/rwupdt.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/gfortran_release/minpack/rwupdt.o\n  build/gfortran_release/minpack/rwupdt.mod - MISSING\n\nI understand that fpm is expecting to find a module file for each single \".f\" file. Is it possible to somehow work around this? The farthest I could get it in the fpm source was to remove to the \"-Wimplicit-interface\" flag which was creating lots of warnings \ud83d\ude48 .\nAm I right to think fpm is currently most suitable for projects composed of multiple module files?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:55:04+00:00",
                    "text": "I was playing around with gtk-fortran and I found a work-around for non-module sources by renaming them to .in files so that fpm ignored them and including them with the include statement in a module.\nIt's not ideal and I'm not sure what the plan is for supporting non-module sources but I think they should be supported in some form.\nPerhaps the larger question is whether we will make fpm flexible enough to support legacy packages in their original form or require restructuring of such packages; this latter option is not as extreme as it sounds since for some packages, fpm support will be brought through a third-party fork anyway (i.e. not via the upstream repo)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 21:47:46+00:00",
                    "text": "At the moment, fpm is only really targeted at projects with modules. At some point we may support non-module sources, but it may be some time before we get to it.\n@LKedward , clever workaround. I may even suggest that as a recommended migration path.\nIn the mean time, there is always the out that fpm now supports custom build scripts or Makefiles (with some specific requirements)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:17:28+00:00",
                    "text": "We have to support non-module sources. But this might be a feature to put into the Fortran based fpm to keep the Haskell based on minimal to be used in bootstrapping."
                }
            ]
        },
        {
            "number": 106,
            "user": "arjenmarkus",
            "date": "2020-06-21 12:28:18+00:00",
            "title": "Error message on Cygwin - \"pwd -W\"",
            "text": "I have tried to build fpm on Windows/Cygwin and got an error message. The output to screen was:\n$ stack build\nPreparing to install GHC to an isolated location.\nThis will not interfere with any system-level installation.\nDownloaded ghc-8.6.5.\nAlready downloaded.\nAlready downloaded.\nDecompressing ghc-8.6.5.tar.xz...\n7-Zip 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18\nProcessing archive: C:\\Users\\markus\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.6.5.tar.xz\nExtracting  ghc-8.6.5.tar\nEverything is Ok\nSize:       1773445120\nCompressed: 280280296\nExtracting ghc-8.6.5.tar...\nExtracted total of 9780 files from ghc-8.6.5.tar\nGHC installed to C:\\Users\\markus\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.6.5\nCloning 536a5e6ffb148d0dd4e4c4b120913a6744097676 from https://github.com/kowainik/tomland.git\nReceived ExitFailure 1 when running\nRaw command: \"C:\\cygwin\\bin\\git.EXE\" submodule update --init --recursive\nRun from: C:\\cygwin\\tmp\\with-repo1848\\cloned\nStandard error:\n/usr/libexec/git-core/git-sh-setup: line 344: pwd: -W: invalid option\npwd: usage: pwd [-LP]\nUnable to determine absolute path of git directory\nApparently, an option -W to the \"pwd\" command is being used that does not exist in the Cygwin version of \"pwd\".\nHow to proceed?",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-21 12:36:06+00:00",
                    "text": "The Linux version requires that I install parts of \"stack\" in /usr/local/bin. Unfortunately, I do not have root/sudo access to the Linux systems I can log on to, so that makes it difficult for me to test fpm on Linux."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:57:57+00:00",
                    "text": "Hi @arjenmarkus, if you don't have root access on linux, please follow the manual installation procedure for stack."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 08:28:32+00:00",
                    "text": "The cygwin error appears to be a fundamental incompatibility between stack and the cygwin environment (at least for this command) - I've been able to run stack build successfully on Windows via command prompt after installing git for windows. I haven't verified stack test in command prompt because I use gfortran via msys2.\nI don't see any reason why fpm built in this manner won't subsequently work from within cygwin.\nAside: interestingly, stack appears to install the msys2 environment on windows when stack build is run. msys2 is a newer fork of cygwin which I switched to (from cygwin) a year ago - I find I have much fewer compatibility problems with msys2."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 09:26:05+00:00",
                    "text": "Hi Laurence,\n\nthanks for that reference. I hoped this morning that I might be able to use\na VM for Linux, but that fails - sigh. Oh well, the instructions should\nhelp me solve that via the regular machine.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n access on linux, please follow the manual installation procedure\n <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n for stack.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#106 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 09:28:31+00:00",
                    "text": "Hi Laurence,\n\none reason for sticking to Cygwin for me is the better (?) support for\ninstalling packages. I have MinGW-w64/MSYS2 installed as well, perhaps\nI should indeed try it that way too.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 10:28 schreef Laurence Kedward <notifications@github.com>:\n\u2026\n\n The cygwin error appears to be a fundamental incompatibility between stack and the cygwin environment (at least for this command) - I've been able to run stack build successfully on Windows via command prompt after installing git for windows. I haven't verified stack test in command prompt because I use gfortran via msys2.\n I don't see any reason why fpm built in this manner won't subsequently work from within cygwin.\n\n Aside: interestingly, stack appears to install the msys2 environment on windows when stack build is run. msys2 is a newer fork of cygwin which I switched to (from cygwin) a year ago - I find I have much fewer compatibility problems with msys2.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 09:57:24+00:00",
                    "text": "Hi Arjen,\n\none reason for sticking to Cygwin for me is the better (?) support for installing packages.\n\nThis is a fair point - it would be good to support running fpm on Cygwin, even if that means building fpm outside of Cygwin as I demonstrated.\nLaurence"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 14:20:15+00:00",
                    "text": "Hi Laurence,\n\njust tried this, but now the \"stack build\" command produces the following\noutput;\n stack build\nNo setup information found for ghc-8.6.5 on your platform.\nThis probably means a GHC bindist has not yet been added for OS key\n'linux64-gmp4'.\nSupported versions: ghc-7.8.4, ghc-7.10.2, ghc-7.10.3, ghc-8.0.1,\nghc-8.0.2, ghc-8.2.1, ghc-8.2.2, ghc-8.4.2\n\nI am not sure this is relevant, but the OS is fairly old - CentOS 6, if I\nam not mistaken.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n access on linux, please follow the manual installation procedure\n <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n for stack.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#106 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 17:29:55+00:00",
                    "text": "Well, the good news is that after installing the version of stack and git\nfor \"plain Windows\", building fpm went smoothly and I could build a simple\n(one-source-file) program. (Some juggling required: I have gfortran\ninstalled for Cygwin and MinGW-w64/MSYS2, not for \"plain Windows\", but from\na Cygwin command window, it works fine)\n\nRegards,\n\nArjen\n\n\n\n\nOp ma 22 jun. 2020 om 16:20 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n Hi Laurence,\n\n just tried this, but now the \"stack build\" command produces the following\n output;\n\n > stack build\n No setup information found for ghc-8.6.5 on your platform.\n This probably means a GHC bindist has not yet been added for OS key\n 'linux64-gmp4'.\n Supported versions: ghc-7.8.4, ghc-7.10.2, ghc-7.10.3, ghc-8.0.1,\n ghc-8.0.2, ghc-8.2.1, ghc-8.2.2, ghc-8.4.2\n\n I am not sure this is relevant, but the OS is fairly old - CentOS 6, if I\n am not mistaken.\n\n Regards,\n\n Arjen\n\n Op ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\n ***@***.***>:\n\n> Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n> access on linux, please follow the manual installation procedure\n> <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n> for stack.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#106 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n> .\n>"
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 18:15:29+00:00",
                    "text": "Hi Arjen,\nUnfortunately I won't be much help with the CentOS error but I'm glad you were able to get it working on Windows also.\nAre you able to run stack test in the fpm root folder under Cygwin? I was encountering an error with the makefile test case when I did this under msys2.\nLaurence\nFor future users: it seems stack build is incompatible with the Cygwin environment, but fpm can still be used in Cygwin if built in \"Plain Windows\" as done by myself and Arjen."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 18:56:58+00:00",
                    "text": "Hi Laurence,\n\nI just ran \"stack test\" and I get errors as well:\n\ngfortran -c -J/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile\n -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g\n-fbounds-check -fcheck-array-temporaries -fbacktrace -o\n/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile/hello_makefile.o\nsrc/hello_makefile.f90\nf951: Warning: Nonexistent include directory\n\u2018/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile\u2019\n[-Wmissing-include-dirs]\nsrc/hello_makefile.f90:10:25:\n\n   10 | end module hello_makefile\n      |                         1\nFatal Error: Cannot open module file\n\u2018/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile/hello_makefile.mod0\u2019\nfor writing at (1): No such file or directory\ncompilation terminated.\n\nSo, indeed the same case is failing here as well.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 20:15 schreef Laurence Kedward <notifications@github.com>:\n\u2026\n\n Hi Arjen,\n Unfortunately I won't be much help with the CentOS error but I'm glad you were able to get it working on Windows also.\n Are you able to run stack test in the fpm root folder under Cygwin? I was encountering an error with the makefile test case when I did this under msys2.\n\n Laurence\n\n For future users: it seems stack build is incompatible with the Cygwin environment, but fpm can still be used in Cygwin if built in \"Plain Windows\" as done by myself and Arjen.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-23 08:32:38+00:00",
                    "text": "Hi Arjen,\nThanks for confirming - I wasn't sure if something was wrong with my msys2 setup.\nNot sure what the problem is, but it looks like it only affects the makefile builds.\nRegards,\nLaurence"
                }
            ]
        },
        {
            "number": 105,
            "user": "ivan-pi",
            "date": "2020-06-21 09:20:09+00:00",
            "title": "Projects with multiple drivers",
            "text": "Following the discussion at the monthly call, I've installed fpm and am trying to convert a few of my Fortran projects to the recommended structure. These projects involve some legacy fixed-style functions and subroutines, an interface module, and several driver programs (tests). The folder structure is something like:\n.\n\u251c\u2500\u2500 drivers\n\u2502   \u251c\u2500\u2500 driver1.f90\n|   \u2514\u2500\u2500 driver2.f90\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 legacy\n|   |   \u251c\u2500\u2500 legacy1.f\n|   |   \u2514\u2500\u2500 legacy2.f\n|   \u2514\u2500\u2500 interface.f90\n\u2514\u2500\u2500 fpm.toml\n\nDo I need to add multiple sections such as\n[[driver]]\nname = \"driver1\"\nsource-dir = \"drivers\"\nmain = \"driver1.f90\"\n\nto the TOML file? Right now my build just crashes because of multiple executable files.\nI think having multiple executable programs is a quite common type of package, say you have a library for building mesh triangulations, and then with it a small set of command line tools calling routines from this common library.\nAnother question is can I already specify dependencies on system-wide installed libraries. Say a project (or one of it's dependencies) needs to be linked with -llapack -lblas (with the actual LAPACK and BLAS libraries potentially in some non-default location). Does this fit under issue #99 of custom build scripts?\nI had a few other comments about the installation process, but they were already fixed in #101. A remaining point might be that after doing stack install in the fpm folder, the ${HOME}/.local/bin/ folder might not be on the path already, requiring an extra command export PATH=\"$PATH:$HOME/.local/bin/\".",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-06-21 13:50:08+00:00",
                    "text": "Here is the project I am trying to convert to be fpm-usable: https://github.com/ivan-pi/fortran_lsp/tree/fpm"
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:34:25+00:00",
                    "text": "Hi @ivan-pi, regarding multiple drivers I believe the current fpm behaviour allows only one executable source file per folder, where any other Fortran files in that same folder are assumed to be modules; this is undocumented I think because the behaviour is still under discussion, see #91 - the suggestion there by @certik seems promising.\n\nA remaining point might be that after doing stack install in the fpm folder, the ${HOME}/.local/bin/ folder might not be on the path already, requiring an extra command export PATH=\"$PATH:$HOME/.local/bin/\".\n\nThis is a good point and should probably be added to the README."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-06-22 09:27:29+00:00",
                    "text": "Thanks @LKedward  for pointing me to the previous discussion. It seems that this issue is then a duplicate. @everythingfunctional and @certik, should I close this issue and comment in #91 instead?\n\nThis is a good point and should probably be added to the README.\n\nI will create a pull request in the next day or two."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 22:06:03+00:00",
                    "text": "Hi @ivan-pi , thanks for trying out fpm with your project. You can have more than one executable per project, but as @LKedward pointed out you must have them in separate folders. Not that the entry in the toml file starts as [[executable]] instead of [[driver]], or it seemed like you considered these to be test programs, so you may want to specify them with [[test]].\nAs for the compiler flags, we haven't really gotten a good handle on how to deal with those. The problem mostly comes from what to do with them in terms of dependencies. Does a project's dependencies get compiled with the flags it specified? What about projects that depend on it? What about if you switch compilers? It's on our radar, it's just a really hard problem that we haven't tackled yet.\nYou can close this issue if you feel the other adequately covers it. Also, feel free to open up other issues if you want make sure we keep track of anything else you asked here."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:20:36+00:00",
                    "text": "I believe Cargo supports to have multiple main programs in the bin directory. I think we agreed to use an app directory instead of bin. Is there a reason why fpm cannot compile those automatically?\nIt is intuitive and natural. I would expect it to work also."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 22:35:36+00:00",
                    "text": "It's not that we can't support it, it just makes things more complicated than \"everything else in this folder is a module that should be compiled and linked in\".\nWe (sort of) support having multiple programs in the app directory, they just have to be in separate sub-folders and have explicit entries in fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:39:44+00:00",
                    "text": "Yes, it's a little more complicated, but it makes life so much easier for the end user. That is the whole point of fpm. :)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 23:54:46+00:00",
                    "text": "Yeah, that's probably true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-23 16:07:50+00:00",
                    "text": "fpm init could generate the appropriate [[executable]] sections for the user. Just throwing an idea out there, not something that I think is a priority."
                },
                {
                    "user": "certik",
                    "date": "2020-06-23 18:18:43+00:00",
                    "text": "Cargo does not require any modifications to Cargo.toml to have executables. We should not either. So fpm init just produces the default initial fpm.toml, and users don't need to touch it, they just create the app dir and put programs in it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-23 18:43:16+00:00",
                    "text": "Yes, the sane default of multiple programs in app/ is what we should aim for.\nMy comment about fpm init was specific to the scenario of multiple programs in custom (non-default) location, which needs to be specified in the toml file, just like Cargo does.\nI actually didn't know (or forgot) that we supported multiple executables by specifying them in fpm.toml, so I was happy to read about it in this thread."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-07 18:08:02+00:00",
                    "text": "Yes, it's a little more complicated, but it makes life so much easier for the end user. That is the whole point of fpm. :)\n\nYes, that will great !!\nalias gardhor"
                }
            ]
        },
        {
            "number": 104,
            "user": "certik",
            "date": "2020-06-20 23:01:41+00:00",
            "title": "Remove the space before comma",
            "text": "This is a fixup of #101.",
            "comments": []
        },
        {
            "number": 103,
            "user": "EverLookNeverSee",
            "date": "2020-06-20 19:53:09+00:00",
            "title": "ENH: Using OpenMP in stdlib",
            "text": "Hi there\nI started learning OpenMP couple weeks ago and would like to use it to parallelize and speed up fortran standard library codebase.",
            "comments": []
        },
        {
            "number": 102,
            "user": "everythingfunctional",
            "date": "2020-06-19 03:36:59+00:00",
            "title": "Enable fpm to create a new package",
            "text": "This is just the bare minimum I would say is necessary for fpm new.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 13:56:15+00:00",
                    "text": "A minor observation: I expected the behaviour to be to initialise a project in the current directory (like git init), as opposed to the command creating a new directory - but I think that is just something that needs documenting somewhere for users.\n\nThis (fpm new) behaviour is analogous to cargo new, and what you describe is analogous to cargo init. So if we wanted to have this, it would be covered by fpm init."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-19 14:56:51+00:00",
                    "text": "Yeah, I'll add some documentation to the README, and maybe PACKAGING.md"
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 17:33:44+00:00",
                    "text": "I believe this should be called init.\n\nFurthermore, it should initialize in the current directory without an argument, or create a new directory with an argument, just like git or Cargo.\n\nLet's keep the UI as similar to others established tools as possible.\n\u2026\nOn Fri, Jun 19, 2020, at 8:57 AM, Brad Richardson wrote:\n\n\n Yeah, I'll add some documentation to the README, and maybe PACKAGING.md\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVVJAAHKPTZZ565HTRXN4EFANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 18:03:24+00:00",
                    "text": "@certik, see cargo new and cargo init.\nIn short, cargo new (and likewise, fpm new) creates a new directory and initializes the TOML and starter source files. I think this is what this PR implements, but again, without a PR description or some example in the documentation, hard to say. @everythingfunctional can you please describe the behavior with a small example? How is this invoked? What files are created?\ncargo init initializes the package in an existing directory with existing source files. So fpm init will be used to \"fpm-ize\" an existing package that obeys the fpm layout. fpm new is used to bootstrap a new empty package. They're different.\nAt least this is my understanding of it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 18:04:54+00:00",
                    "text": "@everythingfunctional can you please describe the behavior with a small example? How is this invoked? What files are created?\n\nSorry, I didn't mean to nag. :) I saw your earlier response after writing this."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:26:07+00:00",
                    "text": "No, cargo init creates a new package in the current directory and cargo init b creates a new package in a new directory b. I am not sure what the difference is to cargo new. But I've only used cargo init and it creates a new package from scratch."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:27:04+00:00",
                    "text": "See #96 where I go into all the details. See also #96 (comment)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:31:06+00:00",
                    "text": "Both cargo new and cargo init seem identical to me. They both initialize in you current directory, or in a new directory if you provide it as an argument. The initialized files seem identical. What is the difference between the two?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 19:19:21+00:00",
                    "text": "cargo new only creates a new directory and initializes a project in it.\ncargo init initializes a project in an existing directory, and optionally does what cargo new does.\nFor cargo new, PATH is required. For cargo init, PATH is optional.\nIndeed, if starting from scratch, they appear very much the same and redundant.\nHowever, if there is anything special about the directory layout (multiple binaries, tests etc.) and contents that would be reflected in Cargo.toml, I would expect cargo init to do that. But I don't think it does, at least in the simple example I tried.\nFor fpm it should. For example, if you have a package layout with multiple programs, fpm init should be able to output a correct fpm.toml according to the special layout.\nfpm new simply bootstraps something from scratch.\nIt's very nice and useful to use Cargo and Rust for reference, but it's not an end all. We're not targeting Rust users. What we make should make sense to us. fpm new for a new project very much makes sense, and fpm init makes more sense for initializing an existing project."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 20:45:20+00:00",
                    "text": "For me it makes sense to use \"fpm init\" like \"git init\". Create a new project from scratch.\n\nI don't think by default it should do something different based on an existing project. However let's have it as an option.\n\nWe should optimize for the most common use case. I think that would be to start a new project from scratch.\n\nAlso, let's have only one command, init. Having two seems redundant and confusing.\n\u2026\nOn Fri, Jun 19, 2020, at 1:19 PM, Milan Curcic wrote:\n\n\n `cargo new` only creates a new directory and initializes a project in it.\n\n `cargo init` initializes a project in an existing directory, and\n optionally does what `cargo new` does.\n\n For `cargo new`, `PATH` is required. For `cargo init`, `PATH` is optional.\n\n Indeed, if starting from scratch, they appear very much the same and redundant.\n\n However, if there is anything special about the directory layout\n (multiple binaries, tests etc.) and contents that would be reflected in\n Cargo.toml, I would expect `cargo init` to do that. But I don't think\n it does, at least in the simple example I tried.\n\n For fpm it should. For example, if you have a package layout with\n multiple programs, `fpm init` should be able to output a correct\n fpm.toml according to the special layout.\n\n `fpm new` simply bootstraps something from scratch.\n\n It's very nice and useful to use Cargo and Rust for reference, but it's\n not an end all. We're not targeting Rust users. What we make should\n make sense to us. `fpm new` for a new project very much makes sense,\n and `fpm init` makes more sense for initializing an existing project.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBLCKEQ6AJ52AAUTJLRXO24NANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 21:19:46+00:00",
                    "text": "For me it makes sense to use \"fpm init\" like \"git init\". Create a new project from scratch.\n\ngit init actually does not only create a new project from scratch. It initializes existing files in the directory into the git repository if there are any. It does also create a new git repository. I think it's difficult to argue that the word \"init\" is more intuitive for creating something new than the word \"new\". To me \"init\" means initialize, which means enable some capability in existing directory+files. In the context of fpm, that would mean simply create fpm.toml given existing pakage layout.\nBut I agree that we shouldn't have redundant commands like Cargo does. It looks like the choice is whether we want to have one command that does multiple things or two narrowly-scoped commands.\n\nWe implement just fpm init which can both create a new empty project and \"fpm-ize\" an existing non-fpm package (basically generate a correct fpm.toml);\nWe implement fpm new that creates an empty project and fpm init to initialize an existing package.\n\nI think @certik prefers option 1. I prefer option 2. as it's easier to understand to me. There may be some other options I missed. @everythingfunctional @LKedward what do you prefer?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 21:24:07+00:00",
                    "text": "An argument for fpm init over fpm new (all else being equal) is that init is a verb and new is a noun. Using a verb would be more consistent with our existing commands (build, install, run, test), and semantically makes more sense (do this with that).\nSo I am not opposed to the word \"init\". But I do prefer smaller utility commands over more general ones that would behave differently depending on current directory."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-19 22:24:39+00:00",
                    "text": "Technically, giti init doesn't create a new project from scratch. It initializes an existing project's git configuration.\nI like having two different commands because they do two different things. fpm new for new projects, and fpm init for existing projects.\nSince the most common use case would be to start a new project from scratch, that's why I implemented it first."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:06:05+00:00",
                    "text": "How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects. So I don't think we should optimize for this rare case.\n\nSo I vote to rename new to init and we are in agreement.\n\u2026\nOn Fri, Jun 19, 2020, at 4:24 PM, Brad Richardson wrote:\n\n\n Technically, `giti init` doesn't create a new project from scratch. It\n initializes an existing project's git configuration.\n\n I like having two different commands because they do two different\n things. `fpm new` for new projects, and `fpm init` for existing\n projects.\n\n Since the most common use case would be to start a new project from\n scratch, that's why I implemented it first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWFIEEUF4HMPJRLSMM3RXPQTHANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 23:24:53+00:00",
                    "text": "How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n\nI expect that we'll use fpm init quite often in the early days, perhaps even more often than fpm new, as we'll work hard on adapting existing Fortran packages (ours and those of others) into fpm. In the long run, I expect fpm new would be used more often.\nIt also depends how you're used to doing things. I never ever ran git init to create a new repo from scratch. I always run it after I've written and played with some code and want to make a git repo out of it. Same with fpm. For any more complex layout package, I'd much rather run fpm init and have fpm write the fpm.toml for me, than me editing it by hand every time I add a new file.\nEven if it's an edge case and something that we'd want down the road, I think it's useful to carefully design and name things early on."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:53:03+00:00",
                    "text": "I always indeed run \"git init\" on an empty repository to start a new project.\n\nRegarding adding new files, you don't modify fpm.toml when you do that.\n\u2026\nOn Fri, Jun 19, 2020, at 5:25 PM, Milan Curcic wrote:\n\n\n > How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n\n I expect that we'll use `fpm init` quite often in the early days,\n perhaps even more often than `fpm new`, as we'll work hard on adapting\n existing Fortran packages (ours and those of others) into fpm. In the\n long run, I expect `fpm new` would be used more often.\n\n It also depends how you're used to doing things. I never ever ran git\n init to create a new repo from scratch. I always run it after I've\n written and played with some code and want to make a git repo out of\n it. Same with fpm. For any more complex layout package, I'd much rather\n run `fpm init` and have fpm write the fpm.toml for me, than me editing\n it by hand every time I add a new file.\n\n Even if it's an edge case and something that we'd want down the road, I\n think it's useful to carefully design and name things early on.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDWQADEDJQCBLH5LDLRXPXVDANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:54:59+00:00",
                    "text": "More generally, let's follow what Rust does, it's a well tested approach. Once we use it and don't like it, then let's discuss to do something else.\n\u2026\nOn Fri, Jun 19, 2020, at 5:52 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I always indeed run \"git init\" on an empty repository to start a new project.\n\n Regarding adding new files, you don't modify fpm.toml when you do that.\n\n On Fri, Jun 19, 2020, at 5:25 PM, Milan Curcic wrote:\n >\n >\n > > How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n >\n > I expect that we'll use `fpm init` quite often in the early days,\n > perhaps even more often than `fpm new`, as we'll work hard on adapting\n > existing Fortran packages (ours and those of others) into fpm. In the\n > long run, I expect `fpm new` would be used more often.\n >\n > It also depends how you're used to doing things. I never ever ran git\n > init to create a new repo from scratch. I always run it after I've\n > written and played with some code and want to make a git repo out of\n > it. Same with fpm. For any more complex layout package, I'd much rather\n > run `fpm init` and have fpm write the fpm.toml for me, than me editing\n > it by hand every time I add a new file.\n >\n > Even if it's an edge case and something that we'd want down the road, I\n > think it's useful to carefully design and name things early on.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#102 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDWQADEDJQCBLH5LDLRXPXVDANCNFSM4OCLLZMQ>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-20 02:42:07+00:00",
                    "text": "I honestly didn't even know that git init directory was a valid command. I learned something new today! I always thought you just had to git init inside a directory, existing files or not.\nI still think that the command that makes the most sense for creating a new project is fpm new, even if that's not what Cargo does. Although I will note the following output from cargo, which would seem to suggest that cargo somewhat agrees with me. cargo new is for a new cargo package and cargo init is for in an existing directory.\n[darter:~] cargo help new\ncargo-new \nCreate a new cargo package at <path>\n\nUSAGE:\n    cargo new [OPTIONS] <path>\n\n[darter:~] cargo help init\ncargo-init \nCreate a new cargo package in an existing directory\n\nUSAGE:\n    cargo init [OPTIONS] [--] [path]"
                },
                {
                    "user": "certik",
                    "date": "2020-06-20 17:04:23+00:00",
                    "text": "Here is the guide for Cargo:\nhttps://doc.rust-lang.org/cargo/guide/creating-a-new-project.html\nit seems they recommend cargo new also.\nI explained my position above, Milan and Brad explained theirs, and it looks like they prefer to use fpm new instead of fpm init to start a new package. So unless more people have an opinion right now, let's go with fpm new and move on.\nHowever, I reserve the right to run a poll later on, and if more people prefer fpm init, let's reconsider. Until then, let's do fpm new."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-20 18:21:39+00:00",
                    "text": "However, I reserve the right to run a poll later on, and if more people prefer fpm init, let's reconsider. Until then, let's do fpm new.\n\nDefinitely, we don't have a majority agreement right now."
                }
            ]
        },
        {
            "number": 101,
            "user": "EverLookNeverSee",
            "date": "2020-06-17 11:51:54+00:00",
            "title": "Optional Fix for README",
            "text": "Separating navigating to stack directory and Adding to PATH\nBecause some of users may navigate to stack directory first and and enter this command(export PATH=\"$PATH:pwd/stack-2.1.3-linux-x86_64-static/)  in order to install stack command that causes error below in $PATH:\nNo such file or directory",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-06-17 12:13:30+00:00",
                    "text": "@everythingfunctional This reminds me of a question I wanted to ask about the instructions for installing stack: why does the README recommend following the 'Manual Download' instructions as opposed to using the simpler install script or distribution package managers? I used the Ubuntu distribution package followed by running $ stack upgrade which was much simpler and works fine.\nThe instructions for installing stack are pleasantly comprehensive (and cross-platform!) and I think we should simply refer users to this page and allow them to choose their preferred installation method."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-17 14:40:43+00:00",
                    "text": "I think this is a positive change, as our specific instruction was Linux only.\n\nThank you @milancurcic for approving this PR."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-17 14:45:34+00:00",
                    "text": "Thanks @EverLookNeverSee , I agree this is an improvement.\nUnless Brad had a specific reason for recommending the manual installation method, I think this is good to merge with one change: can you revert 7ee74b1?\n\nOk, I'll revert it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-17 16:20:15+00:00",
                    "text": "@certik wanted to support people who didn't have sudo access to install system wide. I agree that the official stack install instructions are generally the preferred way, so I support this change. We may  want to have a separate section to put the manual install instructions somewhere just in case."
                },
                {
                    "user": "certik",
                    "date": "2020-06-17 20:34:11+00:00",
                    "text": "I would like to keep it in some form, as requiring a sudo access is a non-starter on almost any machine where I would like to use fpm (I don't have sudo access)."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-06-17 20:50:39+00:00",
                    "text": "I would like to keep it in some form, as requiring a sudo access is a non-starter on almost any machine where I would like to use fpm (I don't have sudo access).\n\nI agree. Could this link  just be mentioned to replace the deleted section. Furthermore, all OS are described there."
                },
                {
                    "user": "certik",
                    "date": "2020-06-17 21:43:57+00:00",
                    "text": "I think that link would work."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-20 07:59:48+00:00",
                    "text": "@certik\nWhat should we do for this PR?"
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-21 06:52:32+00:00",
                    "text": "@certik Thanks for merging."
                }
            ]
        },
        {
            "number": 100,
            "user": "milancurcic",
            "date": "2020-06-16 17:52:56+00:00",
            "title": "add a note about Effing Package Management and elaborate on prototype",
            "text": "This PR:\n\nAdds a clarification about the other fpm\nExpands the note on fpm being an early prototype\n\nFixes #90",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-16 18:09:05+00:00",
                    "text": "Minor wording change suggestion, but other than that this looks good. Thanks for tackling this one."
                },
                {
                    "user": "certik",
                    "date": "2020-06-16 18:29:33+00:00",
                    "text": "I would also add at the end:\nAs the prototype matures and we enter production, we will do our best to stay backwards compatible.\n(Otherwise looks good, thanks!)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-16 18:51:40+00:00",
                    "text": "Thank you, both. Merging."
                }
            ]
        },
        {
            "number": 99,
            "user": "everythingfunctional",
            "date": "2020-06-15 00:11:07+00:00",
            "title": "Add support for Makefiles and generic build scripts",
            "text": "",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 00:33:29+00:00",
                    "text": "I think I might need some help from somebody who understands Windows a bit better to help me with the issue there. I'm guessing either something with the absolute paths is screwing up make, or the environment variables aren't working properly. I'm leaning towards the former, but I don't have access to a Windows machine to test it with at the moment."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 01:00:39+00:00",
                    "text": "The windows error is:\n# gfortran (for build/gfortran_debug/test/main.o)\n# gfortran (for build/gfortran_debug/test/runTests.exe)\n Hello, from test!\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\with_makefile\\build\\gfortran_debug\\with_makefile\\libwith_makefile.a'.  Stop.\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\makefile_complex\\build\\gfortran_debug\\with_makefile\\libwith_makefile.a'.  Stop.\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\makefile_complex\\build\\gfortran_debug\\makefile_complex\\libmakefile_complex.a'.  Stop."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 04:20:47+00:00",
                    "text": "I am worried it's going to mess up buildsystems. Cargo is not using such variables either.\n\u2026\nOn Sun, Jun 14, 2020, at 9:53 PM, Brad Richardson wrote:\n\n\n ***@***.**** commented on this pull request.\n\n In test/example_packages/makefile_complex/Makefile\n <#99 (comment)>:\n\n > @@ -0,0 +1,9 @@\n +INCLUDE_FLAGS = $(addprefix -I,$(INCLUDE_DIRS))\n +\n +$(BUILD_DIR)/libmakefile_complex.a: $(BUILD_DIR)/wrapper_mod.o\n The ones I used are actually the standard environment variables for\n Makefiles. You (almost) can use an empty Makefile and these would\n actually work. We can use prefixed variables, but it's one extra\n difference from what a lot of people will already have and be used to.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#99 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGC5W5YVTCC3G5C4JDRWWLMJANCNFSM4N5VZI5A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 04:53:46+00:00",
                    "text": "I am worried it's going to mess up buildsystems. Cargo is not using such variables either.\n\nI'm not sure I understand. The environment variables are only set while fpm is running. Can you give me an example of a situation that might break?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 05:58:10+00:00",
                    "text": "I'm not sure I understand. The environment variables are only set while fpm is running. Can you give me an example of a situation that might break?\n\nI don't know for sure, but an example would be an autotools build system, that reads these common environment variables, and if they are set by fpm it might break the build. I've definitely seen build systems where things break if you set these variables. So then the user would have to unset them before running autotools.\nIt seems that prefixing them with FPM_, it would ensure that as we expose more variables in the future, things that already work will continue working.\nHowever, one variable I would set automatically, and that is CMAKE_PREFIX_PATH. I think Spack does it, and that makes any CMake project to easily find all the fpm dependencies without the user having to do anything.\nI think your idea is to follow a similar philosophy for raw Make also.\nAlso as a documentation, it's hard to tell from looking at the script who sets the BUILD_DIR variable. But if it is FPM_BUILD_DIR, then it is clear that it is set by fpm.\nI don't know. Let's try this, and keep our options open to possibly prefix it if we run into problems?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 06:16:40+00:00",
                    "text": "My thinking is that if having those environment variables set means your build script doesn't work, that your build script isn't compatible with fpm, and you need a different one for fpm to use. Since the variables aren't persistent after fpm is done running, it won't break existing build systems. They can coexist side by side.\nIf we use prefixed variables, then users are practically guaranteed to have to write a new build script for fpm to use. If we use commonly used ones, there's a chance their existing one might actually work.\nI agree, let's see how this works out, and if we have to change it later, we can.\nI'm not all that familiar with CMake, but we can always do different things for different build tools when we add support for them."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 14:53:04+00:00",
                    "text": "My only minor nitpick is with the compounding of Makefiles and build scripts / executables in the fpm.toml definition\n\nI hadn't really thought about it that hard. It's worth considering. Usually I'd agree, but somehow this seemed simpler from a user and documentation stand point. If you have a custom build process, there's one way/place to specify it, and fpm just knows what to do with it.\n@milancurcic or @certik , do you guys have an opinion on this?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 17:07:21+00:00",
                    "text": "These are all really tough questions with good arguments on both sides. My only suggestion is to be open and open to change things if things don't feel right. I think the way forward is to insist that we are still in a prototype phase, and so things can (and will) change --- let's put this in bold in the README? And in a prototype phase, let's just try it, and get more experience, and be ready to change things. Only after we declare we are in production, we should be backwards compatible as  much as possible.\nIn general, I was hoping that fpm would simply execute the \"script\" as an executable, and always pass the same environment variables. I feel it is ok for fpm to know how to execute the script properly, so a bash script using bash, a Xonsh script using Xonsh, Make file using make, and an executable as an executable.\nI think it is absolutely ok for users to write a short build script. You will have to do it anyway for cmake projects."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-15 18:10:22+00:00",
                    "text": "I don't see issues with this. Like @certik said, let's try it and we can revise if there's need for it. We can't think of all correct answers ahead of time without trying things first in practice.\nMinor nit pick: As a user I didn't expect that for using make the build_script value would be Makefile or *.mk. build_script = \"make\" or build_script = \"make target\" seems more intuitive, because that's what I would've typed otherwise. However, this is also perhaps problematic because neither Makefile nor make are scripts (Makefile is a specification file and make is a command/tool). Perhaps a build_command parameter would be more appropriate if both arbitrary scripts and make are to be invoked with it."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 19:47:09+00:00",
                    "text": "One issue with build_command is that we need to specify the shell. So it could be Bash on Linux/macOS and PowerShell on Windows. Simple commands like make target would work in both. More advanced things, such as referencing an environment variable will not work cross-platform. Essentially the issue is a lack of cross-platform shell.\nRust / Cargo goes around this by simply writing the \"build script\" in Rust itself, thus making it cross-platform.\nI think there is a huge need for a cross-platform native shell. We even started one: https://github.com/xonsh/minixonsh (Xonsh itself is one, but being a Python program, it has the typical Python issues related to distribution and speed).\nBut until there is one (and well supported), I think we should not just pick one and require it.\nSo given all of this, the two option are:\n\n\nbuild_script would be directly executed in Bash / PowerShell, so you have to use a subset that works in both, such as make or make target. Or bash my_buildscript.sh.\n\n\nbuild_script points to a script or executable that gets executed. So Makefile gets executed via make, as fpm knows this.\n\n\nI still think 2. seems better.\nBut overall, I don't know what the best way forward is. So let's just try something to get moving, and iterate."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-16 02:48:48+00:00",
                    "text": "I think there will be some packages which are just not supported on all platforms, and that's ok. As a community we can encourage that and provide support when we're able, but that's going to be a big hurdle in some instances.\nAs everybody seems to agree, let's try this PR out and see how it goes."
                }
            ]
        },
        {
            "number": 98,
            "user": "epagone",
            "date": "2020-06-13 18:35:35+00:00",
            "title": "Add pre-requisites to `stack build` in `README`",
            "text": "On my Ubuntu 20.04 machine, I have installed Haskell Stack unpacking the tarball and adding it to my PATH, as described in the README. After having cloned the fpm repository, stack build failed because I did not have the developers library of gmp (the package libgmp-dev, in my case). I have created PR #97 to add this information to the README (plus the fix to a trivial typo).\nHowever, I believe that we should provide the user with info to cover far more cases (consider also that my test did not start from a \"vanilla\" Ubuntu 20.04 and it is likely that I had already some required packages installed without knowing it). Ideally, I think that the following should be covered in the README:\n\npackages required for all the major GNU/Linux distributions\npre-requisites on Windows 8 and 10\npre-requisites on Apple OSs\n\nConsidering that I have no clue on how to action the above points, I wonder if the CI tools could help. (Disclaimer: I only vaguely know what CI is.)\nPS: just for the records, I was temporary stopped also by the following error in my attempts to complete stack build\n$ stack build\nLinking /home/emanuele/.stack/setup-exe-cache/x86_64-linux-tinfo6/tmp-Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5 ...\nclock               > configure         \nclock               > Configuring clock-0.8...\nclock               > build             \ncolour              > configure         \nclock               > Preprocessing library for clock-0.8..\nclock               > Building library for clock-0.8..\nclock               > [1 of 1] Compiling System.Clock\ncolour              > Configuring colour-2.3.5...\ncolour              > build             \nfile-embed          > configure         \ncolour              > Preprocessing library for colour-2.3.5..\ncolour              > Building library for colour-2.3.5..\ncolour              > [ 1 of 14] Compiling Data.Colour.CIE.Chromaticity\nfile-embed          > Configuring file-embed-0.0.11.1...\nfile-embed          > build             \nfile-embed          > Preprocessing library for file-embed-0.0.11.1..\nfile-embed          > Building library for file-embed-0.0.11.1..\ncolour              > [ 2 of 14] Compiling Data.Colour.CIE.Illuminant\nfile-embed          > [1 of 1] Compiling Data.FileEmbed\ncolour              > [ 3 of 14] Compiling Data.Colour.Chan\ncolour              > [ 4 of 14] Compiling Data.Colour.Internal\ncolour              > [ 5 of 14] Compiling Data.Colour.Matrix\ncolour              > [ 6 of 14] Compiling Data.Colour.RGB\nclock               > copy/register     \nclock               > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/clock-0.8-H1S1zDefxirImaRbI6ITNv\nclock               > Registering library for clock-0.8..\ncolour              > [ 7 of 14] Compiling Data.Colour.RGBSpace.HSL\nfile-embed          > copy/register\nfile-embed          > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/file-embed-0.0.11.1-1DkjC7VmQhQFLvxtpUIE3o\ncolour              > [ 8 of 14] Compiling Data.Colour.RGBSpace.HSV\ncolour              > [ 9 of 14] Compiling Data.Colour.SRGB.Linear\nfile-embed          > Registering library for file-embed-0.0.11.1..\ncolour              > [10 of 14] Compiling Data.Colour.RGBSpace\ncolour              > [11 of 14] Compiling Data.Colour.SRGB\ncolour              > [12 of 14] Compiling Data.Colour\ncolour              > [13 of 14] Compiling Data.Colour.Names\ncolour              > [14 of 14] Compiling Data.Colour.CIE\ncolour              > copy/register\ncolour              > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/colour-2.3.5-y0xjV3ONUd40VuBtReEvC\ncolour              > Registering library for colour-2.3.5..\nHttpExceptionRequest Request {\n  host                 = \"casa.fpcomplete.com\"\n  port                 = 443\n  secure               = True\n  requestHeaders       = []\n  path                 = \"/v1/pull\"\n  queryString          = \"\"\n  method               = \"POST\"\n  proxy                = Nothing\n  rawBody              = False\n  redirectCount        = 10\n  responseTimeout      = ResponseTimeoutDefault\n  requestVersion       = HTTP/1.1\n}\n (ConnectionFailure Network.Socket.getAddrInfo (called with preferred socket type/protocol: AddrInfo {addrFlags = [AI_ADDRCONFIG], addrFamily = AF_UNSPEC, addrSocketType = Stream, addrProtocol = 0, addrAddress = <assumed to be undefined>, addrCanonName = <assumed to be undefined>}, host name: Just \"casa.fpcomplete.com\", service name: Just \"443\"): does not exist (Try again))\nProgress 4/30\n\nbut simply running stack build again solved magically the issue (I don't know what that is).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-06-14 04:37:30+00:00",
                    "text": "I see, thanks.\nWe are planning to actually implement the production version of fpm in Fortran itself, and distribute it as a binary. So most of these issue will not be issues in the future. But in order to bootstrap fpm, we will keep the Haskell verison with minimal features (roughly as it is now), so that we can use it to actually develop the Fortran version of fpm.\nThanks for submitting this."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-06-15 13:15:48+00:00",
                    "text": "We are planning to actually implement the production version of fpm in Fortran itself, and distribute it as a binary.\n\nWas this mentioned somewhere previously? I recall reading it would be done in C++ for performance. If we could set up stdlib to work with the current fpm, and get the necessary string and system routines in stdlib it would be a nice test of the entire project."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-15 14:07:34+00:00",
                    "text": "If we could set up stdlib to work with the current fpm\n\nDo you mean building stdlib using fpm? I think this is a good short-term goal for fpm - I believe the prerequisites before we can do this are #78 (preprocessor support) and #86 (submodules support).\nIf fpm is implemented in Fortran, then using stdlib for this would also be a good demonstration of stdlib."
                }
            ]
        },
        {
            "number": 97,
            "user": "epagone",
            "date": "2020-06-13 18:33:53+00:00",
            "title": "add Ubuntu 20.04 package pre-requisite to `README`",
            "text": "Testing the building process, I have identified a pre-requisite on my machine with Ubuntu 20.04. Fixed a trivial typo, too.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-16 17:38:03+00:00",
                    "text": "Merging, thank you @epagone!"
                }
            ]
        },
        {
            "number": 96,
            "user": "certik",
            "date": "2020-06-12 17:08:54+00:00",
            "title": "Implement \"fpm init\" to create the initial project skeleton",
            "text": "It would work just like cargo init:\n$ cargo init myproject1\n     Created binary (application) package\n$ tree -a myproject1\nmyproject1\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 .git\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502   ...\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n\n10 directories, 18 files\n\nAs you can see, it starts a git repository, and so on. It is ready to compile, so:\n~$ cd myproject1\nmyproject1(master)$ cat src/main.rs \nfn main() {\n    println!(\"Hello, world!\");\n}\nmyproject1(master)$ cargo run\n   Compiling myproject1 v0.1.0 (/tmp/myproject1)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.25s\n     Running `target/debug/myproject1`\nHello, world!\n\nIf you just call cargo init, then it creates a new project in the current directory. Similar to git init.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:24:33+00:00",
                    "text": "I might split the two use cases and not actually run git init.\nfpm new name creates a folder name with contents fpm.toml, .gitignore and src\\name.f90. Maybe app\\main.f90 instead? Or maybe both? I'll come up with a specific proposal. But yeah, fpm build and maybe fpm run should work from the get go.\nfpm init uses the name of the current folder as the name of the project and just creates fpm.toml. Maybe append build/* to the end of .gitignore.\nI think we want people to be able to create new projects even if they don't already have git installed."
                },
                {
                    "user": "certik",
                    "date": "2020-06-12 18:49:31+00:00",
                    "text": "Yes, we should allow options to configure things, so all of the above will be possible with the proper options. For example to initialize without git:\ncargo init --vcs none myproject1\n\n(Obviously you can use other vcs also such as hg.) People that do not have git can always use this option.\nThe default (with no options provided) should be the ones that people use the most often as well as a \"default\" workflow that we want to encourage. I think that we absolutely want to encourage to use git and upload to GitHub or GitLab. I think that should be the default workflow to encourage.\nBut for people who are perhaps new to programming and just want to use a few dependencies and write some simple app and do not want to learn git at the moment, those would initialize with git init --vcs none myproject1.\n$ cargo init -h\ncargo-init \nCreate a new cargo package in an existing directory\n\nUSAGE:\n    cargo init [OPTIONS] [--] [path]\n\nOPTIONS:\n    -q, --quiet                  No output printed to stdout\n        --registry <REGISTRY>    Registry to use\n        --vcs <VCS>              Initialize a new repository for the given version control system (git, hg, pijul, or\n                                 fossil) or do not initialize any version control at all (none), overriding a global\n                                 configuration. [possible values: git, hg, pijul, fossil, none]\n        --bin                    Use a binary (application) template [default]\n        --lib                    Use a library template\n        --edition <YEAR>         Edition to set for the crate generated [possible values: 2015, 2018]\n        --name <NAME>            Set the resulting package name, defaults to the directory name\n    -v, --verbose                Use verbose output (-vv very verbose/build.rs output)\n        --color <WHEN>           Coloring: auto, always, never\n        --frozen                 Require Cargo.lock and cache are up to date\n        --locked                 Require Cargo.lock is up to date\n        --offline                Run without accessing the network\n    -Z <FLAG>...                 Unstable (nightly-only) flags to Cargo, see 'cargo -Z help' for details\n    -h, --help                   Prints help information\n\nARGS:\n    <path>     [default: .]"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 20:47:11+00:00",
                    "text": "I see, I was not aware of those options for cargo. With that, I'm fine with defaulting to using git. There is certainly value in having the defaults set to the most common use case and the one we want to encourage.\nI would still prefer init and new as two different commands."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 21:09:38+00:00",
                    "text": "Cargo also has init and new. They have similar but complementary roles. I see value in having both."
                }
            ]
        },
        {
            "number": 95,
            "user": "everythingfunctional",
            "date": "2020-06-11 21:43:54+00:00",
            "title": "Fix ordering for library archive list",
            "text": "Found a bug in how the library archive paths are kept. Caused a link time error for complicated dependency trees.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 16:23:29+00:00",
                    "text": "I had a test that I thought tested this, but apparently the dependency tree wasn't deep/complicated enough. It took a real world, complicated usage to finally uncover it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 17:01:03+00:00",
                    "text": "Sounds good. I don't understand the fix, but it should go forward.\nWhat's the example that didn't work and that this PR fixes? It's helpful to know so that if the same or similar scenario causes an issue again, we'll know where to look. It's good to document these things at least in the PR thread. I agree with @certik regarding tests."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 17:01:16+00:00",
                    "text": "Merging."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:29:53+00:00",
                    "text": "I started a simple executable project with matterff and a few other of its dependencies as dependencies, and it barfed at the link command. Unfortunately it was in a work repo, so I can't provide a link, but I should be able to relatively easily put together a separate example repo if needed."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:32:12+00:00",
                    "text": "The problem was that it was keeping the first instance of duplicate entries in the list, but it needed to keep the last one. The fix is to just reverse the list before removing the duplicates and then reverse it back once that's done."
                }
            ]
        },
        {
            "number": 94,
            "user": "certik",
            "date": "2020-06-08 16:48:21+00:00",
            "title": "Implement a build script",
            "text": "I would do exactly what Cargo does: https://doc.rust-lang.org/cargo/reference/build-scripts.html\nOnly I would allow the build script to be any of: any binary, cmake, make, Bash script.\nOtherwise the following I would do exactly the same:\n\n\nInputs: environment variables\n\n\nOutputs: the build script prints to stdout with lines starting with fpm:, everything else is ignored. At the beginning, I would support the following, and we can add more later:\n\nfpm:fc-link-lib=[KIND=]NAME --- Adds a library to link (doc)\nfpm:fc-flags=FLAGS --- Passes certain flags to the compiler (doc).\n\nThat should be enough to get us started. One of the environment variables passed to the build script is which Fortran compiler is being used, so the build script would know what compiler parameters to pass back (for example ifort in general might require different flags than gfortran). In the same way, the flags might depend on the platform (macOS vs Linux vs Windows), so one of the input variables can be what platform we run on.",
            "comments": []
        },
        {
            "number": 93,
            "user": "epagone",
            "date": "2020-06-07 12:22:50+00:00",
            "title": "Run dependencies tests",
            "text": "Use case: I'd like to build my program or library that depends on FGSL with fpm. I know how to specify such dependency (in theory, at least) and let's assume that there are no issues in fetching, compiling and linking.\nThe issue I'm raising here is: what if I want to make sure that the fetched and compiled dependency passes its tests on my machine before proceeding with linking and building my own program or library? How can I do that with fpm?\nI believe it's a non-trivial problem considering that each external dependency does not conform to fpm specs. Off the top of my head: maybe an additional key in the TOML file can be specified by the user that specifies how to test the dependency (e.g. make test)? However, I think that it is a sub-optimal solution because requires the user to gain this information for each dependency but it would be hard to have a general reliable method otherwise. Please correct me if I'm off-track.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-06-07 19:36:31+00:00",
                    "text": "@epagone good question. Here is how I think we are imagining this will work:\n\nyour program depends on FGSL.\nFGSL will be an fpm package. As such, when you execute fpm test in the FGSL repository, it will test it. (Currently FGSL is not an fpm package. We envision that eventually people would like to make all such libraries an fpm package, but until then, somebody can create simple repository that will be the fpm package for it, and it would fetch the FGSL sources and build it correctly with fpm, and it would ensure that fpm test works.)\nIn your program, you would just depend on the FGSL as an fpm package.\n\nTo run tests for FGSL, there are two options, you either checkout the FGSL repository and execute fpm test there. Or we can add an option to fpm test, such as fpm test -p FGSL that would execute the tests for FGSL.\nI just checked how Cargo does it. And while Cargo has the -p option for cargo test, it only works with local packages in a workspace (one can have multiple packages in a git repository), but it doesn't seem to work for dependencies that are not in the current repository.\nWe can discuss this more."
                },
                {
                    "user": "epagone",
                    "date": "2020-06-08 00:55:40+00:00",
                    "text": "Thanks for the explanation @certik, I understand now the logic better. However, I went back to re-read the packaging guide and I think the requirement that the dependency has to be already an fpm package is not stated:\n\nInevitably you'll want to be able to include other libraries in your project. fpm makes this incredibly simple, by taking care of fetching and compiling your dependencies for you. You just tell it what your dependencies are, and where to find them.\n\nProbably the assumption that the dependency has been already packaged with fpm is implied. Thinking about it, I guess it should not be a big deal to re-package existing libraries in fpm: it's a matter of swapping files in the right directories and writing the fpm.toml file (if I'm not missing anything major)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-08 02:26:54+00:00",
                    "text": "@epagone yes, that's the most natural approach."
                }
            ]
        },
        {
            "number": 92,
            "user": "certik",
            "date": "2020-06-07 04:32:52+00:00",
            "title": "Behavior of `fpm build` and `fpm test`",
            "text": "cargo build does not build tests. You have to do cargo build --tests to also build tests.\ncargo test build tests (if needed) and runs them.\nI suggest we follow the same approach.",
            "comments": []
        },
        {
            "number": 91,
            "user": "everythingfunctional",
            "date": "2020-06-07 03:59:40+00:00",
            "title": "Multiple executables or tests in the same directory",
            "text": "Right now, program source files can not be placed in the same folder. The build system sees the other program source files and assumes they are modules. We should discuss whether this restriction should be clearly identified in the user documentation, or whether we want to try and support having multiple program sources in the same folder.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-07 04:03:29+00:00",
                    "text": "The main use case I can see for allowing this would be to have modules common to multiple programs or tests, but not included in the library. I would generally be of the opinion that such a situation calls for either putting those modules in the library, or putting them into their own separate library. And by not supporting it, it encourages users to do things the right way."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:23:46+00:00",
                    "text": "I think Cargo allows to have programs in subdirectories of bin/, and I think it's one executable per subdirectory, and other files are just linked to it. I think that's fine.\nFinally, all programs in bin/ directory directly are all separate programs and I think only programs are allowed there.\nI think we can follow exactly the same approach."
                }
            ]
        },
        {
            "number": 90,
            "user": "certik",
            "date": "2020-06-04 20:55:38+00:00",
            "title": "The name fpm is used by another package manager",
            "text": "It was just pointed out to me that fpm is used by another project: https://github.com/jordansissel/fpm. Unfortunately it is in a similar field (also a package manager).\nHere are some options going forward (I'll update this list if there are more):\n\nRename our fpm\nKeep the name fpm and ensure that people do not mistake the two projects (what's the best way?)\n\nAs to myself, I really like the name fpm to mean a Fortran Package Manager. So I vote for 2., if there is a way to do it.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 21:13:50+00:00",
                    "text": "I vote for 2 as well. I think the two are sufficiently different, but knowing it's out there we can be conscious to avoid confusion as much as possible.\nOn a side note, should we use that tool to create our Linux packages?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-04 21:24:35+00:00",
                    "text": "This is unfortunate, though not surprising.\nAs the originator of the name, I'm sorry. I should've done better research. :(\nMy preference is also for 2, because I like the name. However I see issues ahead of us, and it will only be more difficult to rename later. Issues are:\n\nConfusion\nConflict (both CLI tools are called fpm)\nBad look on us as the community, as we are a younger project\n\n\nOn a side note, should we use that tool to create our Linux packages?\n\nThough it sounds like a good idea, now we're really screwed: \"So fpm will package fpm for Linux. Wait, which fpm is this? Is it this fpm or the other fpm?\". I'm confused already. :)\n\nSo I vote for 2., if there is a way to do it.\n\nLet's discuss how we could do it. This would probably mean putting a large disclaimer at the top of our README, saying \"This fpm is not the other fpm\", or similar. What else?\n@jordansissel Do you have any advice for us?"
                },
                {
                    "user": "jordansissel",
                    "date": "2020-06-05 00:59:34+00:00",
                    "text": "I ran into this myself shorty after releasing (my) fpm! I learned there\u2019s a\ntool PHP-FPM That many folks call FPM.\n\nNaming is hard. It\u2019s hard to know if conflicting names will cause\ndifficulties.\n\nI\u2019ve run into weirdness myself with things on Debian like \u201cdocker\u201d package\nnot being the container runtime tool.\n\nI think my advice is this: if you feel fpm is the right name for your tool,\nthen please keep the name. Computers and humans will likely figure this out\non their own with their own workarounds that aren\u2019t too harmful. Examples\nabound, like you can\u2019t really search for \u201cgo\u201d so while the language is Go\nyou gotta search golang. It\u2019s a weird workaround but it works most of the\ntime.\n\nIs this a bad look? I don\u2019t think so!\n\n+1 for a clarification at the top of the README. I\u2019d be happy to include a\nsimilar clarification in my fpm readme and docs. Something short and direct\nthat describes the project (FORTRAN for this one) and offers disambiguation\nlinks to help any wayward travelers.\n\nI agree with concern about command line name conflicts, but it\u2019s unclear\nwhat negative impact this will have. Again here we have examples like\ndownstream OS calling \u201cpip\u201d executable \u201cpython3-pip\u201d or similar naming\nsolutions. That said, it\u2019s probably fine to keep the cli name the same?\n\nAs for search/discovery, \u201cfpm\u201d plus any context should help search engines\nfind the right place for users.\n\nThoughts? Having the project and cli name be the same has low risk in my\nopinion.\n\u2026\nOn Thu, Jun 4, 2020 at 2:24 PM Milan Curcic ***@***.***> wrote:\n This is unfortunate, though not surprising.\n\n As the originator of the name\n <fortran-lang/stdlib#44 (comment)>,\n I'm sorry. I should've done better research. :(\n\n My preference is also for 2, because I like the name. However I see issues\n ahead of us, and it will only be more difficult to rename later. Issues are:\n\n    - Confusion\n    - Conflict (both CLI tools are called fpm)\n    - Bad look on us as the community, as we are a younger project\n\n On a side note, should we use that tool to create our Linux packages?\n\n Though it sounds like a good idea, now we're really screwed: \"So fpm will\n package fpm for Linux. Wait, which fpm is this? Is it this fpm or the other\n fpm?\". I'm confused already. :)\n\n So I vote for 2., if there is a way to do it.\n\n Let's discuss how we could do it. This would probably mean putting a large\n disclaimer at the top of our README, saying \"This fpm is not the other\n fpm\", or similar. What else?\n\n @jordansissel <https://github.com/jordansissel> Do you have any advice\n for us?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#90 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AABAF2WIFDF5BRL244MHV4LRVAGKDANCNFSM4NS7GCRA>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-05 02:54:11+00:00",
                    "text": "Jordan, thanks a lot. With your encouragement I now feel more comfortable keeping the name, and making it clear in the README to avoid confusion.\nSo if @certik and @everythingfunctional agree, we'll add the clarification and link to the top of the README."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 04:11:25+00:00",
                    "text": "@jordansissel thank you for your nice comment. Since you are ok with us keeping the name, I am too. @milancurcic yes, let's send a PR with a clarification at the top of our README and docs. That should make it clear to users.\nI agree with Jordan that there are ways around it. For example Debian has the alternatives system, so users will be able to choose what they want to run as fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-05 04:43:29+00:00",
                    "text": "I am in agreement. Good call just reaching out and asking, and thank you @jordansissel for your understanding and encouragement."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 21:49:37+00:00",
                    "text": "Here is an example how Spack disambiguates the name:\nhttps://spack.readthedocs.io/en/latest/\nThey write:\n\nThese are docs for the Spack package manager. For sphere packing, see pyspack."
                },
                {
                    "user": "nshaffer",
                    "date": "2020-06-13 23:23:01+00:00",
                    "text": "The fpm help text gave me an idea for an alternate name.\nwwf - working with Fortran\nIt seems like the naming crises has passed, but I'm just too tickled by the idea of scientists and engineers co-opting \"WWF\" to mean their package manager."
                }
            ]
        },
        {
            "number": 89,
            "user": "everythingfunctional",
            "date": "2020-06-02 15:12:27+00:00",
            "title": "Add ability to specify which test or program to run and their args",
            "text": "This adds some command line arguments to allow specifying which executable or test you would like to run, and any command line arguments you would like to pass on.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 20:15:45+00:00",
                    "text": "At this stage I (we) haven't really talked about whether executables should be in their own directory. So that is kind of a current edge case bug.\nRight now it just assumes that for a given executable, everything else in that directory is a module meant to be included with it. So while trying to compile one executable it saw the source for the other, assumed it was a module, and failed when compiling it didn't result in the appropriate mod file (or at least I'm guessing that's what happened).\nI'd suggest creating an issue so we can discuss and decide whether this should be documented as a limitation/requirement or marked as a bug to fix later."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 20:36:36+00:00",
                    "text": "Right. We should also consult how Rust does it.\n+1 to merge this PR."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-04 20:40:13+00:00",
                    "text": "I now see approval from @certik, so I agree to merge this, and we can add some basic instructions to the README in a separate PR."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 20:44:53+00:00",
                    "text": "See #83 for improving the tests in general. We have to add a lot more tests, that would serve as the \"spec\" of how fpm is expected to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 21:08:43+00:00",
                    "text": "I'll go ahead and add stuff to the README for this PR. No sense leaving it half done.\nAs for the testing, I think there's just one last thing I'd like to take a crack. I want to get support for using a build script or makefile. That shouldn't take much time to implement. Then yes, we should focus our efforts on writing as many tests (both happy path and error conditions) as we can think of.\nUp to this point, this has been a prototype. I think we've been incredibly successful with it, and it's functionality is pretty much right where we want. So now we just put some tests around it to make sure nothing breaks while we pretty up the insides."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-05 07:55:12+00:00",
                    "text": "Right now it just assumes that for a given executable, everything else in that directory is a module meant to be included with it. So while trying to compile one executable it saw the source for the other, assumed it was a module, and failed when compiling it didn't result in the appropriate mod file (or at least I'm guessing that's what happened).\nI'd suggest creating an issue so we can discuss and decide whether this should be documented as a limitation/requirement or marked as a bug to fix later.\n\nThanks for the explanation, this behaviour makes more sense to me now; I don't think it's a bug but it is definitely something that needs to be documented in PACKAGING.md."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:26:03+00:00",
                    "text": "So cargo build does not build tests. You have to do cargo build --tests to also build tests.\ncargo test build tests (if needed) and runs them.\nI suggest we follow the same approach."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-07 04:30:09+00:00",
                    "text": "Ok. That will require some (minor) refactoring to get working properly. Open an issue and I can fix it in another PR."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:33:08+00:00",
                    "text": "Sure: #92."
                }
            ]
        },
        {
            "number": 88,
            "user": "LKedward",
            "date": "2020-05-31 10:23:57+00:00",
            "title": "Parallel job control flag",
            "text": "I think it's great that fpm already supports parallel builds - there should be a command line flag, like -j, to control the maximum number of threads used.\nThis is important for two reasons:\n\nyou can't assume that the machine will not already be under load, particularly for multi-user environments;\nmemory limits - I have previously run out of memory on a work computer for a large parallel build",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:19:40+00:00",
                    "text": "Yep, that's fair. -j is something that would be expected.\nI didn't mention this subtle detail, but I probably should have; it doesn't build the dependencies in parallel, but it absolutely could. By that I mean building two dependencies that don't depend on each other could be done simultaneously. However, doing that at this stage would mean that each dependency get's built with the same number of threads. I'll need to think about how to really robustly structure the parallelism."
                }
            ]
        },
        {
            "number": 87,
            "user": "everythingfunctional",
            "date": "2020-05-31 00:18:15+00:00",
            "title": "Docker Image With fpm",
            "text": "Now that fpm is in a usable state, I think we should try and create a docker image with the latest version installed, so people can use fpm in their CI.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-31 02:59:46+00:00",
                    "text": "Yes. Even better we should distribute fpm as a single binary for each platform."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:11:14+00:00",
                    "text": "I think we should focus more on package manager distributions than just an executable. At a minimum we should support apt, yum, pacman, and homebrew. Probably also some others. Manually installed things don't get updated very often, if at all."
                },
                {
                    "user": "certik",
                    "date": "2020-06-01 02:16:37+00:00",
                    "text": "Yes, we need all of those also.\n\u2026\nOn Sun, May 31, 2020, at 8:11 PM, Brad Richardson wrote:\n\n\n I think we should focus more on package manager distributions than just\n an executable. At a minimum we should support `apt`, `yum`, `pacman`,\n and `homebrew`. Probably also some others. Manually installed things\n don't get updated very often, if at all.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#87 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWAXGOLNFFNM2HC23I3RUME43ANCNFSM4NO5JRWQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 18:18:03+00:00",
                    "text": "Let's not forget fpm update. This is something I'd expect as a user. fpm should be able to update itself.\nI'm not a target audience for Docker image but I see its value.\nLinux system package managers like apt and dnf I use occasionally, but I can't take them seriously because so many packages are out of date, so they're mostly good for mature (stable) packages. I agree one should be able to get fpm using those. Then also consider Homebrew, Linuxbrew, and Snapcraft."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-02 13:25:26+00:00",
                    "text": "I quickly slapped together a docker image here. I scheduled the CI to update weekly as well.\nAt some point this will deserve some effort to trim down the size of the resulting image. Right now I based it on Ubuntu and built fpm in the image. It should be possible to use a more lightweight starting point (like Alpine) and just copy in the fpm executable. Then we should create a more official one and publish it on docker hub."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-02 13:51:37+00:00",
                    "text": "Great! I think it's a good start. I suggest adding the Dockerfile (and associated instructions in the README.md) to the fpm repo."
                }
            ]
        },
        {
            "number": 86,
            "user": "LKedward",
            "date": "2020-05-30 16:12:03+00:00",
            "title": "Support Fortran submodules",
            "text": "Except for small/simple projects, I almost always adopt Fortran submodules now to structure new projects. This is primarily for the parallel and incremental builds that they allow.\nI realise this may be low down on the list of project priorities currently, but I think it should only require an update to the dependency tracking whereby submodules depend on their parent modules as if they use them.\nMuch further down the line, I assume fpm will aim for some kind of parallel build support?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-30 16:14:52+00:00",
                    "text": "Thanks. Yes, fpm must work with submodules and yes, we must be able to build in parallel."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:55:20+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel (to the extent they can be of course, given dependencies on the .mod files). Supporting submodules won't be too difficult, but I haven't found a particularly compelling use case."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-30 20:01:22+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel\n\nThis is awesome! I didn't realise. Does it use all available threads by default?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 23:04:41+00:00",
                    "text": "Yep"
                }
            ]
        },
        {
            "number": 85,
            "user": "everythingfunctional",
            "date": "2020-05-30 03:03:17+00:00",
            "title": "Implement test/executable specific dependencies",
            "text": "At this point it's kind of a terrible, ugly, hacked together prototype, but it works. And allows for \"semi\"-circular dependencies. If one of your test or executable dependencies depends on your library, it will still work.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 03:08:20+00:00",
                    "text": "My use case for this is that vegetables depends on both iso_varying_string and strff, but I want to be able to use vegetables to test them. This way that will work.\nI still need to try to migrate these to using fpm to be sure that it will work, but I'll try that over the next day or two. The test I added suggests it will."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:08:40+00:00",
                    "text": "Yes, we need this feature. However, let's follow the Cargo's syntax? Or do you have reasons why that's not a good idea in this case?\nhttps://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies\nIt has [dependencies] for just building the package, and additional [dev-dependencies] for building tests / benchmarks etc.\nCurrently you have:\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\n  [test.dependencies]\n    circular_test = { path = \"../circular_test\" }\nLet's instead do:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\n\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\nAnd finally fpm should be clever enough to figure out the tests from the layout only (eventually), so it would become just:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\nIn Cargo you can specify also dependencies for a particular target only. But it seems this dev-dependencies would cover 90% of use cases, including yours (I think)."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:09:43+00:00",
                    "text": "My other comment is that instead of adding tests in the root directory as examples, let's move them in the tests directory?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:41:26+00:00",
                    "text": "I'm not opposed to also having [dev-dependencies], but my question would be, are those used for the executables too? Or would we want to have [test-dependencies] and [exe-dependencies]?\nI can move the tests into the tests directory. That's no problem."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 00:16:34+00:00",
                    "text": "I was able to try this out converting a few of my libraries to using fpm, and it works great. This will make it possible for me to convert (almost) all of my packages to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 02:49:41+00:00",
                    "text": "I am not sure about the executables --- I would expect that dev-dependecies only work for tests, benchmarks etc.\nIn your use case, you have to have special dependencies for executables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 23:20:53+00:00",
                    "text": "I don't personally have a project with special dependencies for an executable, but I could envision one. Somebody develops and tool, and there's a library that goes along with it, but the executable has dependencies that user's of the library don't necessarily need. The use case is probably rare enough, and covered by the executable/test specific dependencies I've already implemented that having dev-dependencies only for tests is probably fine. I'll get that implemented."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 23:35:10+00:00",
                    "text": "Yes, I think that's precisely the approach that Cargo took also. For this rare case, you just specify the dependency for the executable that needs it. Otherwise the dependencies and dev-dependencies cover over 90% of use cases.\n\nThanks for all the work you are doing on this.\n\u2026\nOn Sun, May 31, 2020, at 5:21 PM, Brad Richardson wrote:\n\n\n I don't personally have a project with special dependencies for an\n executable, but I could envision one. Somebody develops and tool, and\n there's a library that goes along with it, but the executable has\n dependencies that user's of the library don't necessarily need. The use\n case is probably rare enough, and covered by the executable/test\n specific dependencies I've already implemented that having\n `dev-dependencies` only for tests is probably fine. I'll get that\n implemented.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#85 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCG44ZNP5I7MSX2U3LRULQ6BANCNFSM4NOQBL6A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 16:32:06+00:00",
                    "text": "Sorry, I don't have time to review this but please go forward with it and I will play with it at a later time."
                }
            ]
        },
        {
            "number": 84,
            "user": "certik",
            "date": "2020-05-29 18:14:25+00:00",
            "title": "Optional dependencies",
            "text": "It is extremely common to have optional dependencies in Fortran projects (see the examples section at the end of this description).\nThe way Cargo handles it is described in here: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html\n[dependencies]\nfoo = { version = \"1.0\", optional = true }\nbar = { version = \"1.0\", optional = true }\n\n[features]\nfancy-feature = [\"foo\", \"bar\"]\nit seems it is somehow tied to \"features\" that one can enable somehow, but I don't yet understand the full mechanism. Also there must be some way to propagate this \"feature\" on/off status inside the code using some macros or something.\nIn Fortran, I can see at least two ways to implemented it, are there more?\n\n\nWe can define some pre-processor definitions and use #ifdef to enable certain code if an optional dependency is used. We can support multiple pre-processors (cpp, fypp, ...).\n\n\nOne can do it at the module level: I sometimes have two files, say, openmp.f90 and openmp.dum.f90 both of which implement the openmp module, so the rest of the Fortran code just use openmp no matter what, and only one of the two files is compiled and linked in the buildsystem:\n# OPENMP\nif(WITH_OPENMP)\n    set(SRC ${SRC}\n        openmp.f90\n    )\nelse()\n    set(SRC ${SRC}\n        openmp.dum.f90\n    )\nendif()\n\n\nThe advantage of 2. is that you do not have to use any pre-processor, which I try to avoid in my codes. The advantage of 1. is that it's simpler in some ways, you just put a few ifdefs in your code.\nI think fpm can support either one, or both.\nfpm could for example create some module, say optional_dependencies and export some variable or a function such as openmp_enabled for the \"openmp\" feature, that you can call in your code and make some decisions.\nEither way, we should figure out how to make fpm support optional dependencies and features that the user can configure.\nExamples\nExample 1\nA typical example is a large electronic structure code, that provides its own default exchange correlation functional, but optionally allows to link against the libxc library, in which case one must enable and link against it and some code paths are different (typically some Fortran modules are enabled / disabled) and it allows the code to use functionals from the libxc library.\nExample 2\nThere are many linear and eigensolver libraries, and there is typically some default, but if the user installs a particular 3rd party solver, it can optionally enable it in the Fortran program to use it instead.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-29 19:36:50+00:00",
                    "text": "I would lean towards option 1 as being easier to implement in fpm. It just doesn't fetch and build optional dependencies unless specified, and only defines the environment variables for the ones specified.\nWith option 2, the build process has to be able to make decisions about which source file gets used to satisfy a given module. This requires us to modify/extend our current naming conventions with regards to source file name and module name.\nI definitely see the need for such a feature, and I think we should definitely try and tackle this at some point."
                }
            ]
        },
        {
            "number": 83,
            "user": "certik",
            "date": "2020-05-24 00:56:44+00:00",
            "title": "Add tests",
            "text": "Currently the new fpm does not seem to have any tests. We have to fix it, and start adding lots of tests.\nIn the old fpm, I had two initial tests:\nhttps://github.com/fortran-lang/fpm/tree/master/archive/tests\nAnd we need to add a lot more. The idea would be to test any configuration that is supported, and that way we can ensure that it works and things don't break when new functionality is implemented.\nFurthermore, if we decide to use a different language for the production implementation, the tests will allow us to ensure that the new implementation works as expected.",
            "comments": []
        },
        {
            "number": 82,
            "user": "everythingfunctional",
            "date": "2020-05-23 17:35:14+00:00",
            "title": "Enable dependencies",
            "text": "This makes working with git dependencies possible!\nSee an example project I create here.\nIt's still very raw, but should work for a lot of situations.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-23 19:40:39+00:00",
                    "text": "Great, I'm excited to play with it.\n\nIt's still very raw, but should work for a lot of situations.\n\nAt this time, do you know what situations don't work?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-24 01:00:15+00:00",
                    "text": "Great work, thanks for adding this Brad!\nWe really need to start adding tests for every PR, see #83.\nFor this particular PR, what is the best way to test this? It might be quite hard to setup a test server and download using it, all automatically when running tests. The way I was thinking we can test this is to add support for specifying a dependency that lives on a local filesystem. That way we can simply test it locally, without setting up some test servers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-24 03:19:07+00:00",
                    "text": "@milancurcic , I think it may still have an issue trying to build if there is a circular dependency. You'll probably hit an infinite loop. But I haven't tested that.\n@certik , Agreed. I'm thinking of going ahead and adding path dependencies, and then yes, you can just test it locally. Really the only way to test whether stuff that needs to go over the network works is to let it go over the network. Otherwise you have to figure out how to supply a \"dummy network\" when working under tests.\nI think at this point, the best tests are going to be beta testers. I'm going to try and migrate a few of my projects to use it and see how it goes. Long term we could take the Rust/Cargo approach and just try to build all the libraries in the registry with every new version. Not sure how feasible that is, but it would at least guarantee we never break any existing packages."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-24 16:10:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 02:09:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend\n\n\nThat's odd. stack.yaml.lock is supposed to ensure that exactly the same dependency versions get used for everybody. It looks like something went funky with the specific version of tomland that I specified. What is the difference in that file after you removed it and rebuilt?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:02:06+00:00",
                    "text": "$ diff stack.yaml.lock stack.yaml.lock.orig \n8,10d7\n<     cabal-file:\n<       size: 6802\n<       sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n\nstack.yaml.lock.orig is the one checked out from the repo. stack.yaml.lock is the one generated by stack build.\nI don't understand how is this related to the specific tomland version \ud83d\ude15\nFWIW, I reproduced this on Fedora 28 and Ubuntu 18.10."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 18:44:08+00:00",
                    "text": "It looks like the difference in the files is in the tomland section, and the error message you got mentions tomland. So that's where the problem is, but I'm still not sure why. I'm on Arch running version 2.3.1 of stack. Maybe the format/info in the stack.yaml.lock versions has changed slightly?\nI can remove it for now, since things work without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:55:22+00:00",
                    "text": "Sounds good, this can be merged IMO."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:02:22+00:00",
                    "text": "Here is the error that I am getting with d89214b on Ubuntu 18.04:\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nWith 1cb711d things build fine.\nThe lock file, at least for Rust, is supposed to be checked into git for applications but not libraries. fpm would be an application."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:03:20+00:00",
                    "text": "As a side note, since fpm is following the same design as Stack and Cargo: I want fpm's error messages to be much nicer and more user friendly than the above exception that Stack gives. :)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:28:13+00:00",
                    "text": "Aren't you are supposed to recommit the lock file whenever you add/update dependencies - @everythingfunctional is the tomland dependency new in this PR?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:31:17+00:00",
                    "text": "Yes, you are supposed to regenerate it when dependencies change. The tomlang dep seems to be new here?\nhttps://github.com/fortran-lang/fpm/pull/82/files#diff-fafd0cdcd559a7b124cc61c29413fb54R42"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:34:39+00:00",
                    "text": "When I commit the new lock file that got generated for me, and diff the old one, here is what I get:\n$ git diff d89214b\ndiff --git a/stack.yaml.lock b/stack.yaml.lock\nindex 31e0c19..15bfc22 100644\n--- a/stack.yaml.lock\n+++ b/stack.yaml.lock\n@@ -5,6 +5,9 @@\n \n packages:\n - completed:\n+    cabal-file:\n+      size: 6802\n+      sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n     name: tomland\n     version: 1.3.0.0\n     git: https://github.com/kowainik/tomland.git\nFurthermore, when I remove those 3 lines by hand, I get the exception above.\nFrom this I conclude that the lock file should be committed, and it should contain the above 3 lines."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:42:19+00:00",
                    "text": "I pushed in the lock file again. Things work on my machine and tests pass at the CI.\n@everythingfunctional can you verify that things work on your machine also with the latest commit 3613167?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:51:50+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 20:07:51+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?\n\nExactly, this worries me too that our CI passed even though the lock file was broken. Possibly the CI uses a different Haskell version?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 20:56:23+00:00",
                    "text": "I suspect my machine and the CI are using a newer version of stack, which does not need those 3 lines in the stack.yaml.lock file. @certik , your latest push does work on my machine.\nYes, the .lock file should generally be checked in to version control. It's generally ignored for dependencies, (i.e. if a library has this file, when you include it as a dependency, that file doesn't even get looked at). It's purpose is to avoid having to consider different versions of dependencies when trying to diagnose \"works on my machine\" type issues. Stack is able to make sure you're using the exact same dependencies of everything your project uses, including the version of GHC (the Haskell compiler), except for the version of Stack itself. It seems to me that's the only possible explanation here.\n@LKedward , the dependency on tomland isn't new here, but I had to implement some new functionality in that library, and it hasn't made it to an official release yet, so I had to specify it as a git dependency. That part is new here."
                },
                {
                    "user": "certik",
                    "date": "2020-05-28 20:43:47+00:00",
                    "text": "Thanks for merging."
                }
            ]
        },
        {
            "number": 81,
            "user": "ShamanTcler",
            "date": "2020-05-19 12:59:23+00:00",
            "title": "Understanding intent",
            "text": "This is more of a discussion than an issue.\nAs a developer who routinely develops in FORTRAN and  C, I have come across Conan, http://conan.io a C/C++ package manager.\nNow in my mind C and FORTRAN are very similar in character ... both have attributes such as:\n\ncompilers\n\ncompiler vendors\ncompiler versions\ncompiler flags\n\n\nbitness (32 vs 64)\ndebug/release builds\n\nEtc.\nConan manages these very well via a hash assigned to the package.\nNow I tried about two years ago to implement a similar scheme, to what Conan was doing but finally said ... they just do it better.\nToday I use VS Code, CMake/Ninja and Conan as my \"best practice\". ( BTW, the new Ninja version 10.  native support for FORTRAN modules ) This set up supports Intel FORTRAN/GFORTRAN and hopefully FLANG soon\nSo I am curious what do you think you bring new to the table.\nPlease don't think I am just throwing stones ... I have hundreds of thousands of lines of FORTRAN code, and Conan is bit of a \"force fit\", but not bad,  ... so I truly am looking to improve my best practice.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 13:42:12+00:00",
                    "text": "Hi @ShamanTcler and welcome! Thank you for starting this discussion.\nHere's an excerpt from an email I sent to colleagues a few days ago. It's my answer to your question.\nfpm solves the (1) user and (2) developer experience problem. I don't think it solves any technical problem. How it's implemented under the hood is details, and there are many different roads we can take. But in the design of fpm we focus on UI and UX.\n\nUser experience: Once fpm is installed, all that the user has to do is fpm build, fpm run, fpm test, or fpm install. This is by far the simplest UI for Fortran out there, and is aligned to what Cargo does (we designed it after Cargo exactly with UX in mind). So the only friction comes down to installing fpm. If we make this seamless--single binary executable to download--then we'll have reduced the friction to near minimum.\n\nThe key solution for here is that the user doesn't have to a) download the source code by hand; b) edit any build files; and c) download and build any dependencies by hand.\n\nDeveloper experience: See this doc that describes the layout of an fpm package. As you can see, we take the sane default approach like Cargo where we assume a package layout and file and module naming conventions. So the developer has to remember/learn only where to put the files and how to name them. As far as I'm aware, this is the simplest developer UI for Fortran out there. Plus, the developer also gets the perk from the user experience above, which is that dependencies are automatically downloaded, built, and linked for you.\n\nAs you know, there are tools that collectively do all of the stuff that I described. However, there's no single tool that does all of what we want, and no more. Most tools were designed and intended as \"the one build system/package manager to rule them all\". They all fail because this is an extremely difficult problem. They also tend to be language agnostic (or at least support several different languages), so they necessarily have to be more general and handle more edge cases, which means more complex, and more complicated for the user.\nAnother great developer recently said \"we don't need another language-specific tool\". I think that's exactly what we need. Language-agnostic is what makes a tool become either too general and complex, or the design gets out of hand to reach all its objectives. Cargo is perfect for Rust. We need Cargo for Fortran.\nThere's also a cultural and aesthetic aspect that people rarely bring up. It's very difficult to convince a community of developers to adopt exclusively Conda, CMake, Meson, Ninja, or whatever. Conda is maybe becoming a household name in scientific Python community, but CMake is far from being a household name for Fortran. If there's a household name for Fortran, that would maybe be autotools + Make, and that's just Linux. Yes, I'm mixing up build systems and package managers here, but I'm trying to make a point, which is that we need a household name. We need a tool that, when a newcomer to Fortran visits fortran-lang.org, we can tell them here is the one tool you should use. This will only work if we have mass buy in from the community, and I think we can do this more easily if we build a Fortran-specific build system + package manager in a single tool, than trying to adopt multiple external tools.\nIt's easy for you and me and most people here to say \"why do you need this when there are already tools X, Y, and Z\". I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja. I've walked away before from Python packages that only had the Conda install instruction, and were not installable by pip. That's just me. Now imagine how it is for somebody new to Fortran, not to mention somebody new to programming.\nWe are targeting Fortran users across all skill levels, and especially the entry level programmers. I think it's crucial for Fortran that a new programmer who learns Fortran as their first language, loves the experience and is not scared off.\nThe Fortran build system + package manager must be at least as easy (and should be easier) to install and use, than it is to install and use the compiler directly.\n\nTake a look at Fortran Discourse. I think it's the perfect format for discussions like this."
                },
                {
                    "user": "ShamanTcler",
                    "date": "2020-05-19 14:42:45+00:00",
                    "text": "Thanks for the link to \"FORTRAN Discourse\" ... already joined. ( user CandL there)\nI see mention of FORTRANCon  ... good 'ole Steve Lionel is the key note, should be a good show.\nYour comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja. I am sure this could lead to an interesting evening over a few adult beverages of your choice.\nBut I agree the discourse area is a better spot for this discussion. Thanks for your time and consideration.\nRegards\nCarl"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 15:22:40+00:00",
                    "text": "Your comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja.\n\nYes, a bit of a hyperbole. If I need the project to get work done, sure. If I'm just playing, I'd pass. From Ninja's landing page, I'm not clear how it can help me. From the manual, it sounds like a faster Make. So, a tool for power users.\n\nI am sure this could lead to an interesting evening over a few adult beverages of your choice.\n\nI hope we get a chance to do it soon! :)"
                }
            ]
        },
        {
            "number": 80,
            "user": "milancurcic",
            "date": "2020-05-17 20:20:24+00:00",
            "title": "Install dependencies from remote git URLs",
            "text": "As discussed in #33, let's allow installing fpm-enabled packages form their git repositories.\nIf the following is placed in fpm.toml:\n[dependencies]\ndependency_name = { git = git_url, tag = git_tag }\nThen the package depends on dependency_name, which fpm will fetch from git_url and a specific git tag git_tag.\nHere's a concrete example that will work, when this issue is implemented.\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nQuestion: If tag is omitted, should fpm fetch from the latest commit on master? I think so. Cargo does it like that as well. Then you could also do:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\" }",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-17 20:23:03+00:00",
                    "text": "This is exactly my plan."
                },
                {
                    "user": "certik",
                    "date": "2020-05-17 21:05:04+00:00",
                    "text": "Yes, if tag is omitted, it should check out the latest master.\nOtherwise I agree."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 17:46:14+00:00",
                    "text": "This was finished in #85"
                }
            ]
        },
        {
            "number": 79,
            "user": "certik",
            "date": "2020-05-14 19:48:36+00:00",
            "title": "Easily create a Spack package",
            "text": "This issue is similar to #70 but for Spack instead of Conda. Essentially for people that use Spack (myself included sometimes), it would be nice to just be able to spack install any fpm package.\nTo do that, fpm should be able to take any package and produce a working Spack package out of it, that can then be submitted to Spack.\nThe generated Spack package would probably call fpm underneath to do the build.",
            "comments": []
        },
        {
            "number": 78,
            "user": "LKedward",
            "date": "2020-05-12 12:35:32+00:00",
            "title": "Preprocessor support",
            "text": "This issue is to ask whether fpm will have any built-in support for preprocessing and how this might look.\nI bring this up since I noticed that stdlib is listed in #17 under 'Pure Fortran', however it requires the fypp preprocessor to build from repo source.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-12 14:18:26+00:00",
                    "text": "We've had discussions about it. I believe we decided we want to settle on a preprocessor, and just always use it. I'd have to go find that discussion, but I believe we settled on fypp."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 14:49:08+00:00",
                    "text": "Yes, we definitely want fpm to apply a preprocessor. We also talked about file extensions, and it seems most people would prefer to just stick with .f90, and fpm would apply the preprocessor appropriately (via a compiler option or otherwise).\nWe probably should support both cpp and fypp. For fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-12 15:23:04+00:00",
                    "text": "\ud83d\udc4d on both cpp and fypp. cpp is de facto standard and many Fortran projects rely on it. fypp we have established earlier that it is more powerful than cpp and thus useful for generation of specific procedures like those in stdlib.\n\nFor fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python.\n\nI agree, although this is a non-issue until fpm itself is Fortran or C++. Python ships out of the box on most systems."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 15:33:39+00:00",
                    "text": "I agree, although this is a non-issue until fpm itself is Fortran or C++.\n\nActually it's an issue for distributing fpm, as we cannot easily integrate fypp into the fpm single binary, so we now have to ship it along side fpm somehow, etc.\nHowever, since we will eventually use Conda for the non Fortran dependencies, then fypp can just be installed using Conda / Mamba, and then indeed it should become a non-issue."
                }
            ]
        },
        {
            "number": 77,
            "user": "milancurcic",
            "date": "2020-05-10 18:20:20+00:00",
            "title": "Should we refer to this software as FPM or fpm?",
            "text": "They mean the same, but they look and \"feel\" different. We should have a consistent way to refer to this so it's not confusing to the readers whether they're different things. Especially as we begin to write about these things more publicly?\nI've been using both. I don't know which one I prefer. Perhaps 60/40 in favor of fpm.\nSo, which one should it be?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 18:24:29+00:00",
                    "text": "I've been using both also. Let's use lowercase.\n\nI think fpm, with `fpm` in markdown. Just like git or markdown.\n\nIf it is at the beginning of a sentence, let's use Fpm.\n\u2026\nOn Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n\n\n They mean the same, but they look and \"feel\" different. We should have\n a consistent way to refer to this so it's not confusing to the readers\n whether they're different things. Especially as we begin to write about\n these things more publicly?\n\n I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n favor of fpm.\n\n So, which one should it be?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#77>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 18:31:19+00:00",
                    "text": "I guess git uses both Git and git: https://git-scm.com/\n\nI think svn also uses both SVN and svn.\n\nI am fine either way.\n\nWe can have a rule to use FPM when referencing the project, but fpm when the executable, and encourage to use fpm where it make sense. But should we write Fortran Package Manager (FPM) or Fortran Package Manager (fpm) at the top of the website?\n\nOndrej\n\u2026\nOn Sun, May 10, 2020, at 12:24 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I've been using both also. Let's use lowercase.\n\n I think fpm, with `fpm` in markdown. Just like git or markdown.\n\n If it is at the beginning of a sentence, let's use Fpm.\n\n On Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n >\n >\n > They mean the same, but they look and \"feel\" different. We should have\n > a consistent way to refer to this so it's not confusing to the readers\n > whether they're different things. Especially as we begin to write about\n > these things more publicly?\n >\n > I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n > favor of fpm.\n >\n > So, which one should it be?\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#77>, or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:59:39+00:00",
                    "text": "Node Package Manager uses npm universally. Even the company is called \"npm, Inc.\".\nI vote for fpm all the way, and fpm when referring specifically to the command line executable."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:14:26+00:00",
                    "text": "I also vote fpm all the way.\n\u2026\nOn Sun, May 10, 2020, at 12:59 PM, Milan Curcic wrote:\n\n\n Node Package Manager <https://www.npmjs.com/> uses npm universally.\n Even the company is called \"npm, Inc.\".\n\n I vote for fpm all the way, and `fpm` when referring specifically to\n the command line executable.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#77 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH4JET6LJBKTX7JHJLRQ32SNANCNFSM4M5LDRPA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:19:29+00:00",
                    "text": "I can come up with logical arguments for either.\nOn the one hand, it's a proper noun, Fortran is capitalized, and it's an acronym, so FPM would make sense.\nOn the other hand, Fortran is a case insensitive language, and our community style guide seems to be leaning towards all lowercase, so fpm would be consistent with that.\nGiven that this really is a purely aesthetic choice, and there seems to be a trend in other places towards all lowercase, I have nothing against using fpm everywhere. I'll start doing that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-17 20:09:08+00:00",
                    "text": "The consensus so far is to use \"fpm\" everywhere. Closing."
                }
            ]
        },
        {
            "number": 76,
            "user": "everythingfunctional",
            "date": "2020-05-10 04:15:33+00:00",
            "title": "Prefix library archive file names with lib",
            "text": "Fix #75",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 05:01:32+00:00",
                    "text": "+1, looks good\n\u2026\nOn Sat, May 9, 2020, at 10:15 PM, Brad Richardson wrote:\n\n\n @everythingfunctional <https://github.com/everythingfunctional>\n requested your review on: #76\n <#76> Prefix library archive\n file names with lib.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#76 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWC2J6GTOZI5TTUQDW3RQYS7BANCNFSM4M5CPJ6A>."
                }
            ]
        },
        {
            "number": 75,
            "user": "milancurcic",
            "date": "2020-05-09 20:22:10+00:00",
            "title": "Add lib prefix to the static library file name",
            "text": "Currently, FPM emits a static library file that has the same name as the project. For example, first line of fpm.toml could be:\nname = \"datetime\"\nThen, the static library created is datetime.a. However, the canonical way to name libraries (static and dynamic) is to use a lib prefix: libdatetime.a. Then one can link to this library with -ldatetime.\nCurrent workaround can be to add the lib prefix to the package name in fpm.toml:\nname = \"libdatetime\"\nHowever, this isn't pretty, and would down the road be more awkward once we're installing packages from remote URLs.\nLet's add the lib prefix to library files.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-09 21:25:13+00:00",
                    "text": "I agree.\n\u2026\nOn Sat, May 9, 2020, at 2:22 PM, Milan Curcic wrote:\n\n\n Currently, FPM emits a static library file that has the same name as\n the project. For example, first line of `fpm.toml` could be:\n\n name = \"datetime\"\n Then, the static library created is `datetime.a`. However, the\n canonical way to name libraries (static and dynamic) is to use a `lib`\n prefix: `libdatetime.a`. Then one can link to this library with\n `-ldatetime`.\n\n Current workaround can be to add the `lib` prefix to the package name\n in `fpm.toml`:\n\n name = \"libdatetime\"\n However, this isn't pretty, and would down the road be more awkward\n once we're installing packages from remote URLs.\n\n Let's add the `lib` prefix to library files.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#75>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWETEZUJY7Q5QWRYIYTRQW3P3ANCNFSM4M46DEDQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-10 03:41:20+00:00",
                    "text": "I see. This is a simple enough change to make. I will note however that FPM is just including the archive directly in the link command, rather specify both -Ilib/folder and -lname arguments. So this will only impact users doing things outside of FPM. Granted that many people will want to do things outside of FPM, I think it makes sense to go ahead and do it."
                }
            ]
        },
        {
            "number": 74,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:55:33+00:00",
            "title": "Add compiler to build path",
            "text": "This is the first part of supporting #66\nNote: This should be merged after #72",
            "comments": []
        },
        {
            "number": 73,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:35:09+00:00",
            "title": "Output a message if no executables or tests are found",
            "text": "Fix #64",
            "comments": []
        },
        {
            "number": 72,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:22:15+00:00",
            "title": "Remove compiler option from `fpm.toml`",
            "text": "Fix #63",
            "comments": []
        },
        {
            "number": 71,
            "user": "epagone",
            "date": "2020-05-03 17:20:05+00:00",
            "title": "Install app or library system-wide",
            "text": "I know it might be a bit early but I'd like to log this issue that is particularly important for me.\nTo use routinely fpm, I would need a functionality that works a bit like sudo make install to install the executable or library system-wide.\nPS: thanks for your great work!",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-03 21:16:09+00:00",
                    "text": "@epagone thanks! Yes, we have to do it.\n@everythingfunctional how can one do that using stack install? I read through stack install --help but didn't see an option to install into /usr/local/bin/."
                },
                {
                    "user": "epagone",
                    "date": "2020-05-03 22:58:47+00:00",
                    "text": "I read through stack install --help but didn't see an option to install into /usr/local/bin/.\n\nFor the records, on Ubuntu 20.04, if I copy manually my library files (libsomething.a) in /usr/local/lib/ or /usr/lib, gfortran finds it with $ gfortran libtest.f90 -lsomething.\nHowever, copying the module files to /usr/local/include does not work and the full path must be specified after the -I flag: $ gfortran libtest.f90 -lsomething -I/usr/local/include\nPS: sorry for having repeatedly edited my message, but I have been experimenting a bit and I didn't want to leave confusing or contradictory messages around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 02:16:33+00:00",
                    "text": "I think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\nI'm not completely opposed to the idea, but I would need somebody to show me a use case that would constitute good practice. I'd rather FPM not try and also take on the role of system package manager. I think twice about anything that needs sudo to do it."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 04:38:39+00:00",
                    "text": "Ah, I missed this point: this is about fpm installing the apps and libraries systemwide.\nWhy don't we start with what Cargo does via cargo install --root ... which however is for Cargo managed packages, and then we see what else we can do. I think installing apps that are statically linked should be no problem.\nFinally, that's a good point that if fpm is to become a usable replacement for CMake (let's say), it must be able to install the executables and libraries to a user defined location.\n(Most probably we'll have to be able to build both static and dynamic libraries with fpm down the road.)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 07:47:24+00:00",
                    "text": "For installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things.\n\nThe Linux file system has a well-defined segregation between files installed by package managers and those built by users; as @epagone mentioned user-built executables/libraries/headers go in /usr/local/bin /usr/local/lib (both shared and static) and /usr/local/include. This is a common target for makefiles for c libraries and avoids the need to specify include and library paths when compiling and linking.\nHowever this approach can't be used for Fortran libraries because:\n\n\nUnlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n\nThere is no agreed-upon location to place (and search for) the requisite .mod files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nI agree with @everythingfunctional that one of the goals of fpm is to solve this problem for us; specifically, it handles module paths and linker library paths for us in a robust and repeatable manner (which is the main advantage of installing system-wide IMO).\nI think install functionality for executables is a natural functionality, I would like:\n\n(sudo) fpm install for /usr/local/bin and;\nfpm install --local for $HOME/.local/bin"
                },
                {
                    "user": "epagone",
                    "date": "2020-05-04 10:10:17+00:00",
                    "text": "@everythingfunctional\n\nI think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\n\nSorry, but I do not understand. Let's take this example: I have a string manipulation library that I build from source pulling a GitHub repo. I need this library in almost all of my many projects. I think it's obvious to expect from the package manager the ability to make the library available system-wide. (FWIW, I am not using FoBiS exactly because it lacks this functionality.) Am I doing something wrong in my development procedures?\n@LKedward\n\nHowever this approach can't be used for Fortran libraries because:\n1. Unlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n2. There is no agreed-upon location to place (and search for) the requisite `.mod` files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nOuch. Thanks for this explanation, but it's really a bad news! \ud83d\ude1e"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 14:29:36+00:00",
                    "text": "I need this library in almost all of my many projects.\n\nIf you're using FPM, then it has the responsibility to provide the appropriate version to compile and link with your project. It does not rely on whatever version happens to be installed on your system.\nSay for example, the latest version of a library introduced a breaking change that your project relies on. You can continue using the old version for your old project, but use the latest version in your new project, on the same machine, and not have any issues."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:22:18+00:00",
                    "text": "@epagone wrote:\n\nI think it's obvious to expect from the package manager the ability to make the library available system-wide.\n\nYes, that's the goal. Fpm must have an option to install a library systemwide or to any location you want."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-04 15:35:54+00:00",
                    "text": "I also think it's important to allow both static and dynamic library builds down the road.\nIf I understand this correctly, it seems to me that the high-level debate here is whether fpm should work only within the context of a local, package-specific environment (@everythingfunctional position I think), vs. whether fpm could also install to places elsewhere on the system (regardless whether it's a root or user directory).\nIf you always worked in the package-specific environment, that means that you'd need to rebuild the same dependency for every project that uses it, rather than re-use an existing build. I don't know if Cargo for example can build system-wide, but its canonical behavior is to rebuild everything per-project. For example if you try a demo database or web-server project in Rust, you'll first be building all the 500 dependencies that it needs.\nBesides the rationale others already provided, another advantage to this is that some libraries take some time to build (for example NetCDF). Rebuilding them for every new project would hurt user experience.\nI think both approaches should be possible. Default should be like Cargo. How about this UI:\n\nFor in-package build, fpm build suffices, no need for fpm install. The library is already installed in build/... in the package directory.\nFor install elsewhere, fpm install installs to a sane default user location, perhaps /home/user/.fpm/{bin,lib,include}.\nFor install to a specific place, fpm install --prefix=/path/to/install."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:48:08+00:00",
                    "text": "I agree with @milancurcic's proposal at the end.\nLet's start with rebuilding everything for each directory where you call fpm build. But down the road fpm can simply build somewhere in ~/.fpm/ and cache each build and reuse them where possible.  Note also that this build directory (whether local to a project directory or in ~/.fpm/) I think might be a bit different from the fpm install command --- the build directory might have more information / metadata that the install command doesn't need to install.\nAnyway, I think we can design this so that each of us will get the functionality that we want."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 15:54:37+00:00",
                    "text": "If we do eventually place built libraries in a central location like ~/.fpm/ then I would suggest that this path include the compiler and compiler version for the same reasoning as #66 due to binary incompatibility between compilers. e.g. ~/.fpm/gfortran-9.1.0/bin etc."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 17:55:03+00:00",
                    "text": "@LKedward yes, that's necessary. In fact it should be done by hashes, where a hash depends on:\n\ncompiler vendor and version\nwhether Debug or Release build\nhash of the sources for the package\nall dependencies' hashes\nhow the given package was configured --- Cargo allows some optional capabilities and we might too in the future, say if you want to build a package with or without netcdf support\n..."
                }
            ]
        },
        {
            "number": 70,
            "user": "certik",
            "date": "2020-04-30 20:08:12+00:00",
            "title": "Have a Conda backend",
            "text": "This is related to #69 but it's a separate issue. fpm should be able to create a Conda package for the project, so that it's easy to submit it to conda-forge.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:27:15+00:00",
                    "text": "What's required for a Conda package?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:44:39+00:00",
                    "text": "Here is a Conda package for my dftatom Fortran package:\nhttps://github.com/conda-forge/dftatom-feedstock/\nThe main config file:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/meta.yaml\nLinux / macOS build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/build.sh\nAnd Windows build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/bld.bat\nAll of which could be generated. The build process could simply just call fpm on all platforms."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:50:54+00:00",
                    "text": "That seems like it wouldn't actually require any changes to FPM."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:16+00:00",
                    "text": "One still has to generate things like \"description\", \"name\" (both of which fpm knows), and the proper template to call fpm. But yes, it should be a simple backend to fpm."
                }
            ]
        },
        {
            "number": 69,
            "user": "certik",
            "date": "2020-04-30 20:07:05+00:00",
            "title": "Have CMake and Make backends",
            "text": "Currently the Haskell based fpm is compiling things directly, just like Cargo does it. That's the best default. (The \"archived\" Rust based fpm was generating CMake.)\nHowever, until fpm is everywhere used by everybody, it would be super helpful to have a CMake and pure Make backends. That way we can move packages like stdlib or any of my own packages into using fpm, and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\nSince fpm knows (or should know) everything about the Fortran project, it can generate 100% robust CMake and Make files, following the latest practices for CMake / Make, human readable, etc.\nI am thinking having these backends would be beneficial for many purposes, such as debugging, anyway. We should also have a Ninja backend.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:18:49+00:00",
                    "text": "and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\n\nI don't understand why generate CMake of Make files. If fpm is smart enough to generate a correct CMake or Makefile for an arbitrary package, would it not be smart enough to simply build the package on its own?\nI thought that the value of enabling CMake or Make backend is when fpm is not smart enough yet to build the package on its own, but is just smart enough to detect an existing CMakeLists.txt, Makefile, or configure file, and run the appropriate commands to build it, like, cmake . or FC=gfortran make."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:31:08+00:00",
                    "text": "Let me see if I can explain it better.\nWe should assume that fpm is smart enough to completely build the project on its own. We are very close and we will get there soon.\nThe other assumption is that the goal has never been to call an existing CMakeLists.txt or configure script. The whole point of fpm is that users write fpm.toml and they never write CMakeLists.txt or configure by hand.\nSo with these assumptions, yes, you can just use fpm. However, it will be a while before we can just get every user using fpm. For example I don't think it would be wise to get rid of the CMake build system in stdlib and only use fpm --- maybe later, but not today. At the same time, I would love to be using fpm with stdlib as well as all my other Fortran projects now.  So to achieve it, if fpm can generate CMake, then users of my packages can keep using CMake as they do now. But I, as a developer, can just use fpm, and use fpm to generate the CMake files for my users (and commit them to git), so that I do not need to maintain the fpm build system, and a separate CMake build system by hand. And since fpm knows how to build the project on its own, it also by definition knows how to generate beautiful looking CMake files that just work (or any other build system also)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:48:36+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:55:48+00:00",
                    "text": "Yes exactly. And not just be done with it, but you can keep using fpm to keep the other build systems up-to-date. When you have a bigger project, the inter-dependencies of Fortran modules change every time you modify the use line (all the time). So you have to update manual Makefiles all the time you change this. And every time you add / remove files or move them around, you would have to update CMake also. fpm could do all that for you.\nIn fact fpm could detect that your project contains fpm-generated CMake (from some comment in it) and it can warn you every time it needs to be re-generated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:25:36+00:00",
                    "text": "So, the idea here is that, not only should FPM be able to use \"non\"-FPM packages, it should also be able to generate \"non\"-FPM packages? I think this may be inviting a lot of requests for special cases. We might end up constantly chasing users who aren't willing to actually use FPM as intended.\nI'm not saying it isn't doable or worth considering. If we limit the scope to saying these other build systems must functionally produce exactly what FPM itself would do it might not be too bad, but then I don't think that actually reaches many people that we wouldn't have already convinced to switch over.\nOn the other hand it might provide a slightly smoother transition path. Make these tweaks to your current build system so FPM can use. Then get all your user's to adjust to that. Then stop maintaining that build system yourself and let FPM do it.\nI'll have to think about this for a while."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 21:37:02+00:00",
                    "text": "I made a joke a year ago, and we may actually do it.\nI share the same concerns as Brad. Mainly that this effort may not be closely aligned with FPM itself. In other words, it would be helping users to not use FPM. On the other side, if this would help many packages support multiple build systems, it would improve their portability, a long-term Fortran goal."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:51:19+00:00",
                    "text": "From a practical perspective, we already use both CMake and manual Makefiles for stdlib (because people have requested both) and now we also want to use fpm. I have the same problem with dftatom and Milan with datetime-fortran. I bet there are tons of other projects like that too. So instead of each of us maintaining 3 different build systems, let's just all collaborate on CMake and Makefile backend to fpm, which will produce higher quality CMake / Makefile in the end, and it will remove the burden of each of us maintaining 3 different build systems."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:53:34+00:00",
                    "text": "Ok, let's at least finish a beta version that just supports standard FPM projects before we start tackling this one though."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:47+00:00",
                    "text": "I agree. I only posted it here to keep it in mind."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-07 18:00:39+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it.\n\nI think this feature will be great in particular when you want to distribute a code:\n\nsome users just want to type \"make\" to be able to compile the code (and maybe edit the makefile)\nthe fpm installation (with its dependencies) is not straightforward and it adds another layer. If it fails, without this feature you will not be able to run the code.\n\nlauvergn (alias gardhor)"
                }
            ]
        },
        {
            "number": 68,
            "user": "certik",
            "date": "2020-04-30 19:50:53+00:00",
            "title": "How to handle non-Fortran dependencies",
            "text": "I am very confident we can make fpm very robust to work for pure Fortran packages. Just like Cargo works well for pure Rust packages or pip works great for pure Python packages.\nThe problem is with non-Fortran packages. Pip allows to hook in compiling C (and with some work) Fortran code, but it's very fragile in my experience (thus the motivation for Conda that is a binary package manager). Python doesn't have an option to avoid C++/Fortran dependencies because Python itself is slow. Rust allows to (in principle) rewrite everything in Rust. As an example, take png. The system bindings: https://crates.io/crates/libpng-sys they say are unreliable, and you should use a pure Rust implementation: https://lib.rs/crates/lodepng.\nI agree it does make things more robust to stick to pure Fortran and for many things we will do that and people will provide pure Fortran implementation of basic tasks. Python cannot do it well due to performance, but Rust and Fortran can.\nHowever, we still need a robust way of handling non-Fortran dependencies, because if there is a robust and well maintained library in another language, we should just use it instead of reimplementing everything. Take HDF5. Here is the Rust package: https://crates.io/crates/hdf5. If you look at the documentation how to build it: https://github.com/aldanor/hdf5-rust they even mention Conda (to install the HDF5 library itself on all platforms --- which in my experience is much more robust than pip). Anyway, the way it works is by this line: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/Cargo.toml#L11 which causes Cargo to execute this script: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/build.rs which emits flags how to link against HDF5 correctly. That way the Cargo itself doesn't need to know almost anything, it just parses the output of this file. I think we should follow the same approach in fpm. The flags in this case are emitted by: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/src/lib.rs#L65. I think this is when you link against hdf5 rust package in your own code. How to link against hdf5 library itself is done here I think: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L566, it's quite complicated unfortunately.\nBut it's clean from the Cargo side, it offloads the responsibility to the package itself. We can provide helpers that fpm packages can use to work with things like pkg-config, cmake packages, etc.\nIn Rust it looks like each package is on their own, so for example this HDF5 package has messy code for each platform, e.g., here: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L492, you can see they are checking brew, or Windows registry, etc.\nThe good news is that Fortran codes do not need many non-Fortran dependencies, and so doing what Rust does might work for us. What I've seen is that Fortran codes mostly need some of: Lapack, MPI, FFT, MKL, HDF5, JSON, NETCDF, HYPRE, ...\nOf which MPI and Lapack being the most important. I think fpm will have support for all Fortran compilers and I think it can have built-in support for MPI and Lapack also. One reason to special case MPI and Lapack is so that one can switch MPI implementaitons and Lapack implementations easily, and not have the Fortran packages hardcoded with a particular implementation.\nWith those out of the way, the rest can be done Cargo style, at least for now. Most other packages have just one implementation, so Fortran packages can just depend on a particular package (say Arpack, or Scalapack).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:03:57+00:00",
                    "text": "I agree, this sounds quite reasonable as a first stab. Thank you for the research.\nMy personal sorted list of most used non-Fortran dependencies: MPI, HDF5, NetCDF, zlib, libpng.\nIf everybody here listed their most used dependencies, we could have an idea of top candidates which to design for and test first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:06:38+00:00",
                    "text": "I definitely would like to be able to handle some non-Fortran dependencies. As it's currently designed, I think it won't be that difficult.\nThe end result of building a library in FPM is just a .a file, and all of the relevant .mod files. So, if your package specifies a build script for that, FPM will just call it. There is a small set of things that FPM would like to dictate to that script though. Those being:\n\nThe compiler to use\nThe compiler flags to use (mostly to ensure the flags are compatible with the given compiler)\nWhere to put the archive and module files\nWhere to find any of the dependencies\n\nIn this way, almost anything could be wrapped into an FPM package. Best practice would be to entirely wrap the package into a Fortran API, so consumers don't necessarily even have to know it's not Fortran, but this may not be strictly necessary in every case.\nFor the build scripts, I really like Rust's way of having the build scripts be written in Rust too. Not sure if Fortran would really be doable for that, but it would make sure building a package doesn't have additional external requirements. We could special case Makefiles and CMakeLists to use the typical environment variables I think."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 12:53:00+00:00",
                    "text": "C has a special relationship to Fortran though. Thanks to the compatibility section, it makes sense for a Fortran developer to include C code in a Fortan project. Could that be taken into account?\nMy \"pet\" usage for this is to write a PRNG in C with a Fortran wrapper module. PRNGs often use unsigned integers whose usage is possible in C.\nA fpm package could thus, in this scenario, contain Fortran and C source."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 14:18:22+00:00",
                    "text": "@everythingfunctional, @milancurcic and I discussed this point on the phone and we think so far that the best way forward is to work with Conda (or Mamba to be specific) together with their developers (@wolfv and others) to provide all non-Fortran dependencies. fpm would link with mamba and from a user perspective things would just work (users would not need to handle Conda environments explicitly).\nRegarding C support, I would suggest initially to handle them via Conda, just to keep things simple.\nWe can think if if want to later extend fpm to handle not only Fortran compilers but also C and C++ compilers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-13 14:34:13+00:00",
                    "text": "@pdebuyl , my recommendation would be to put the C parts of your project in a separate project so that fpm can easily build the \"pure Fortran\" part of your project with ease.\nWe're planning to support make and Cmake as separate build scripts, so supporting linking with (almost) any other language and still having it be an fpm package would be possible."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-13 16:20:01+00:00",
                    "text": "@everythingfunctional , @certik , what are the disadvantages/difficulties with natively supporting c sources in fpm? Many projects do need to include c code from time to time and this is quite normal for Fortran (even before iso_c_binding came along). I think this would be a good feature.\n(I'm not talking about whole package dependencies, just self-contained projects with mixed c/Fortran code)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 16:26:15+00:00",
                    "text": "I don't foresee issues with building C alongside Fortran. It may be even simpler as there are no modules to deal with."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 16:35:13+00:00",
                    "text": "Regarding C support: a full solution there is this: TheSnakePit/mamba#223.\nWhat we could do for fpm is not the full solution, but provide functionality for simple C source files, not full packages with a complicated build system.\nWe have to decide on a layout for C sources:\n\n\nShould the .c files be simply files in src/ folder? (I vote yes.)\n\n\nWhere should the header files be? Either in src/ or in include/.\n\n\nWhat about dependencies and their header files? (I would suggest Conda and that you can use anything from there, so fpm will create an internal environment and you can use any header file from there.)\n\n\nWhat about linking of dependencies?\n\n\nGiven that we will support C, why not C++ also? Supporting C++ would be very useful to provide Fortran wrappers: we would write a simple C wrapper that calls into a 3rd party C++ library, and call that C wrapper from Fortran, so it requires compiling of a C++ code.\n\n\nAlso one needs to link libc properly for C, and libc++ properly for C++. I think we have to do this anyway anytime we depend on a C or C++ library.\n\n\nThere will be more issues. Some of them similar to what we have to deal with anyway for Fortran sources. So I think let's keep this option open when we are designing fpm, although I still suggest to concentrate on Fortran sources first."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 17:24:18+00:00",
                    "text": "The low hanging fruit here seems to be handling the mixed C and Fortran source in a single project.\nJust let .c and .h sit in src/ by default, use gcc by default (like we do now with gfortran), link all object files into a static library and executable (like we do now).\nLinking to external (binary) dependencies seems orthogonal to this. Nevertheless important, but we could tackle these incrementally."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 20:47:04+00:00",
                    "text": "I had in mind the \"simple\" use case of one or a few c files that indeed \"just get compiled\" as part of the Fortran module. Making the shared C libraries available to other Fortran \"consumer code\" is probably out of scope. Anyway, thank you for the replies :-)"
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 21:40:36+00:00",
                    "text": "@pdebuyl thanks for bringing it up, I think we can do that. Looking at my own code here: https://github.com/certik/hfsolver/tree/master/src, I have .f90 files, .c and .h files and also .cpp files all in the src directory. So if fpm could eventually compile all that correctly, that would go a long way. The reason I have the C and C++ files are just to interface 3rd party libraries, typically there is no way around that, as one must write some simpler wrapper that is ready to be called from Fortran using the iso_c_binding interface.\nSo I like this."
                }
            ]
        },
        {
            "number": 67,
            "user": "everythingfunctional",
            "date": "2020-04-30 03:21:47+00:00",
            "title": "Add sections to PACKAGING.md on explicit fpm.toml and tests",
            "text": "Add a couple of sections to the PACKAGING.md file and some other minor fixes.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-30 15:41:51+00:00",
                    "text": "I played with fpm finally, and it works well. This is how I was imagining it would work. Obviously it is still a prototype, but a usable one. Thank you @everythingfunctional for putting all the effort there! I really appreciate it.\nI think we need a mailinglist, for a general discussion. @milancurcic how about we create a fortran-lang mailinglist and simply see how it goes? We can always close it if it does not work out."
                }
            ]
        },
        {
            "number": 66,
            "user": "LKedward",
            "date": "2020-04-29 15:12:24+00:00",
            "title": "Support multiple compilers side-by-side in build",
            "text": "Currently compiled binaries are placed in build/debug/ and build/release.\nWould it be possible to make this build path dependent on compiler (and maybe architecture)?\ne.g. build/gfortran-9.2.0-x86_64_debug/\nThis reason for this being that I like to build and test my projects on multiple compilers during development; separating the binary output paths allows incremental builds using multiple compilers and allows tests on each compiler to run simultaneously and without clean and rebuild.\nThis may be considered an 'ugly' directory structure, however since fpm handles all compiler/linker paths and offers the fpm run command, this has no effect on end-user experience.\nThe workflow for using a non-default compiler could then be along the lines of:\n$> export FC=ifort\n$> fpm run\n\nor\n$> FC=ifort fpm run\n\nor\n$> fpm run --compiler=ifort",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:51:56+00:00",
                    "text": "Yeah, this shouldn't be too difficult. Good idea."
                }
            ]
        },
        {
            "number": 65,
            "user": "milancurcic",
            "date": "2020-04-29 14:45:54+00:00",
            "title": "How to build multiple programs?",
            "text": "Currently, FPM can build only one executable program, namely main.f90.\nHere's how Cargo does it:\n.\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u251c\u2500\u2500 main.rs\n\u2502   \u2514\u2500\u2500 bin/\n\u2502       \u251c\u2500\u2500 named-executable.rs\n\u2502       \u251c\u2500\u2500 another-executable.rs\n\u2502       \u2514\u2500\u2500 multi-file-executable/\n\u2502           \u251c\u2500\u2500 main.rs\n\u2502           \u2514\u2500\u2500 some_module.rs\n\u251c\u2500\u2500 benches/\n\u2502   \u251c\u2500\u2500 large-input.rs\n\u2502   \u2514\u2500\u2500 multi-file-bench/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 bench_module.rs\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 simple.rs\n\u2502   \u2514\u2500\u2500 multi-file-example/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 ex_module.rs\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 some-integration-tests.rs\n    \u2514\u2500\u2500 multi-file-test/\n        \u251c\u2500\u2500 main.rs\n        \u2514\u2500\u2500 test_module.rs\n\nSo, for Fortran, the main executable could be src/main.f90, and other executables could go in src/bin.\nI like this approach, and I am not married to this particular directory structure. I also like the structure that we have now, namely app/, src/, tests/.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:57:27+00:00",
                    "text": "Right now, if you want multiple executables you have to specify them manually. I'm open to enabling some auto-detection of multiple executables. I'll put together an outline of what that would look like."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:28:46+00:00",
                    "text": "I like the Cargo layout a lot. Brad, is there a reason to use app? I would switch to src/bin to be consistent with Cargo.\n\u2026\nOn Wed, Apr 29, 2020, at 8:46 AM, Milan Curcic wrote:\n\n\n Currently, FPM can build only one executable program, namely `main.f90`.\n\n Here's how Cargo\n <https://doc.rust-lang.org/cargo/guide/project-layout.html> does it:\n\n `.\n \u251c\u2500\u2500 Cargo.lock\n \u251c\u2500\u2500 Cargo.toml\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 lib.rs\n \u2502   \u251c\u2500\u2500 main.rs\n \u2502   \u2514\u2500\u2500 bin/\n \u2502       \u251c\u2500\u2500 named-executable.rs\n \u2502       \u251c\u2500\u2500 another-executable.rs\n \u2502       \u2514\u2500\u2500 multi-file-executable/\n \u2502           \u251c\u2500\u2500 main.rs\n \u2502           \u2514\u2500\u2500 some_module.rs\n \u251c\u2500\u2500 benches/\n \u2502   \u251c\u2500\u2500 large-input.rs\n \u2502   \u2514\u2500\u2500 multi-file-bench/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 bench_module.rs\n \u251c\u2500\u2500 examples/\n \u2502   \u251c\u2500\u2500 simple.rs\n \u2502   \u2514\u2500\u2500 multi-file-example/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 ex_module.rs\n \u2514\u2500\u2500 tests/\n     \u251c\u2500\u2500 some-integration-tests.rs\n     \u2514\u2500\u2500 multi-file-test/\n         \u251c\u2500\u2500 main.rs\n         \u2514\u2500\u2500 test_module.rs\n `\n So, for Fortran, the main executable could be `src/main.f90`, and other\n executables could go in `src/bin`.\n\n I like this approach, and I am not married to this particular directory\n structure. I also like the structure that we have now, namely `app/`,\n `src/`, `tests/`.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#65>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEWB2SGOZD73V6TTXTRPA4TFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 16:34:11+00:00",
                    "text": "I actually much prefer app to src/bin. In my mind a bin directory is for binary files only, not source code."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:54:16+00:00",
                    "text": "Ok. Well, let's at least evaluate the options how to structure the layout with pros / cons. Because once we pick one, it will be hard to change.\n\u2026\nOn Wed, Apr 29, 2020, at 10:34 AM, LKedward wrote:\n\n\n I actually much prefer `app` to `src/bin`. In my mind a `bin` directory\n is for binary files only, not source code.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#65 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCPT6UMT3RKJ6WRDJ3RPBJJFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 17:28:53+00:00",
                    "text": "The app, src separation makes it much easier to determine what should be packaged up into the library, and what is just for use in executable(s). I also makes finding the executable(s) a bit simpler for the automatically detected case. If we switch to the src/bin approach I'll need to special case out of searching that directory when building the library."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 17:59:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-29 18:13:31+00:00",
                    "text": "I think we should aim to minimize special cases in the UI, and implement accordingly. A good test for this is asking what design leads to the simplest user guide.\nFor example, if everything in src is considered a library component except src/main.f90 and src/bin/*.f90, then these are special cases that require additional clauses in the documentation.\nOn the other hand, app for programs and src for library is simplest to explain to a user, and is currently my favorite solution.\nAn even simpler UI than this (to explain to a user) is to have program files be programs, and module files be modules, regardless of where they are in the tree. However this complicates implementation because now fpm needs to parse the sources. A downside is that now there may not be clear separation between programs and module files if the user is just looking at the source tree. However if you have app and src, it's clear.\nWe should study Rust+Cargo model in detail, but we shouldn't assume that it's the optimal solution for us. This could be because of Rust's own history of the project, or because Rust and Fortran are different languages and have different cultures.\nI agree with @LKedward about app vs bin."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 18:27:07+00:00",
                    "text": "Good points. Note that fpm has to parse the sources anyway to determine module dependencies and to enforce that each module name is named appropriately.\nSo looks like the most natural solution so far is:\n\nsrc contains module files (or loose procedures / function --- we should not encourage it, but some existing projects do that and I think we can incorporate this without harm). Everything in src gets built into a library.\napp, contains programs. Perhaps app/main.f90 could be the main program (by default executed by fpm run).\ntests contains tests\nbench contains benchmarks (we can do this one later perhaps --- although most of my projects contain some kind of benchmarks which are distinct from apps and distinct from tests)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 21:41:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway.\n\nNo, I didn't implement src/main.f90 to be an executable. If it sees that it will expect it to be a module named main."
                }
            ]
        },
        {
            "number": 64,
            "user": "milancurcic",
            "date": "2020-04-29 14:38:17+00:00",
            "title": "fpm run and fpm test should emit a message if no action is taken",
            "text": "Currently, if you issue fpm run in a library project without executable program, it does nothing.\nIt'd be more user friendly if we emitted a message to stderr, something like:\nfpm: This package has no executable programs.\n\nor similar.\nLikewise for fpm test. If there are no test, we should say something like:\nfpm: This package has no tests.\n\nWhat do you think?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:39:43+00:00",
                    "text": "Not a bad idea. Shouldn't be too difficult to implement."
                }
            ]
        },
        {
            "number": 63,
            "user": "milancurcic",
            "date": "2020-04-29 14:34:01+00:00",
            "title": "Don't require compiler field in fpm.toml",
            "text": "Following up on the discussion in #60, let's remove the requirement for the compiler setting in the package-specific fpm.toml.\nFor now, FPM should default to gfortran, and we can put a note in the README or the packaging guide that gfortran is currently the only compiler supported. We can relax this at a later time. The compiler setting can still remain in the toml parser as optional--perhaps we will want to allow package-specific choice of compiler.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:41:04+00:00",
                    "text": "That's reasonable for now. I'll make that change on my PR"
                }
            ]
        },
        {
            "number": 62,
            "user": "everythingfunctional",
            "date": "2020-04-29 02:55:30+00:00",
            "title": "Handling Dependencies",
            "text": "My basic outline of how to do this is the following recursive algorithm:\n\nfor each listed dependency, download/check it out\nGo into the dependency's fpm.toml file and for each of it's dependencies\na. if it's already been downloaded, check that it's version is compatible, otherwise recursively repeat this process\nCollect each of the dependencies dependencies,\nReturn the tree of dependencies\nBuild each of the dependencies, recursively building each of it's dependencies first",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:58:57+00:00",
                    "text": "I should be able to implement this soon. I'll use a similar toml specification style as Rust's cargo. I got sidetracked implementing the ability to parse that properly for the toml parser we're using.\nWhich brings up a question. Do we specify the specific git version of that library as one of our dependencies, or do we include the functions I implemented directly in our source? For either, at some point we'll be able to remove it and go back to using the library as normal."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 08:17:58+00:00",
                    "text": "Thanks @everythingfunctional, this will be great to get working! I have a few questions:\n\nAt this stage are dependencies simply specified directly as git repository urls (#33 decentralized package management)?\nAre you using git tags to track specific versions in git repositories?\nHow are dependency versions specified in fpm.toml? (cargo supports several version operators)\nAre you adopting some form of semantic versioning rules to resolve version compatibility?\n\nAlso: surely you can only resolve compatible dependency versions after the entire dependency tree has been constructed?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:30:29+00:00",
                    "text": "For now, we'll just support git repository urls, since we don't have a centralized repo yet.\nJust like cargo does, we'll support tags, commits, or branches being specified for a git dependency.\nI'm planning to implement version specifications exactly like cargo does. That's a bit longer term goal though.\nYes, we'll adopt semantic versioning rules. Long term, it may even be possible to enforce those rules in a centralized repository.\nIn the short term, we won't \"resolve\" dependency versions. It will just check if the version already downloaded is compatible with the package's requirements. If not we'll just throw an error. You can then \"resolve\" the conflict by specifying a version that works for all the dependencies in your package. I don't know of any package manager that has really and truly solved the version compatibility search problem. Many have just reasonable approximations or workarounds."
                }
            ]
        },
        {
            "number": 61,
            "user": "milancurcic",
            "date": "2020-04-28 20:52:11+00:00",
            "title": "add license",
            "text": "FPM needs a license.\nMIT seems a no-brainer here, but need permission from contributors.",
            "comments": []
        },
        {
            "number": 60,
            "user": "milancurcic",
            "date": "2020-04-28 20:47:08+00:00",
            "title": "Package layout guide",
            "text": "First stab at describing package layout and examples.\nI took the user guide approach rather than a specification document because:\n\nIt's impossible to separate package layout specification (output of tree) and fpm.toml specification; they are interdependent;\nIt's impossible to predict the exact specification that we'll need; in other words, we need to work up to it;\nBy writing this out as a user guide, I had to learn it enough to teach it. This process illustrates what's missing and what's working or not working. We should take it step by step from there.\nWe want users to try to adapt their package to FPM and open issues with what doesn't work or is unclear.\n\nPlease read it and let me know any suggestions, or edit the document directly.\nYou'll see that I asked one question and proposed two issue candidates in quotation blocks (>). We should remove them and open issues before merging this.\nEverything covered in the guide works with current master of FPM, except a few details about fpm.toml settings that aren't implemented.\nI also need to say, even at this early and raw stage it's pleasure using FPM. Doing something like this with Fortran code is already pushing the boundary. So, great work @everythingfunctional and @certik.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-28 21:06:59+00:00",
                    "text": "Thanks @milancurcic for writing a tutorial for this. Very helpful. It looks great overall and I don't have any issues with it, except one big one: I strongly feel we should not be encoding compiler options into fpm.toml and so we should not be encouraging users to do so. In the same way, we should not be encoding standard layout into fpm.toml either. FPM should allow both as an option, but by default it would do the right thing.\nSo in particular, none of this should be there:\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[executables.executable-name]\nmain = \"main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\n\nThis should be all inferred automatically. Exactly as Cargo works.\nI think fpm might not be able to do it yet. That is fine, but in that case I would like to see very clearly stated that this is temporary and show how the fpm.toml will look like once we implement this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:31:39+00:00",
                    "text": "@certik I agree. What I think makes most sense is:\n\nfpm has default behavior baked in\n(optional) compiler can be changed on fpm level (not the package level)\n(optional) some packages may need to override default compiler flags, but I assume this is minority of packages.\n\nIt turns out, right now fpm doesn't require any of this except compiler. So even for the last example, this is a valid fpm.toml:\nname = \"math_constants\"\nversion = \"0.1.0\"\nlicense = \"MIT\"\nauthor = \"Jane Programmer\"\nmaintainer = \"jane@example.com\"\ncopyright = \"2020 Jane Programmer\"\ndependencies = []\ncompiler = \"gfortran\"\nSo I can go right ahead and remove the other settings from examples. That will also make the tutorial simpler.\nAs for the compiler setting, it seems like it would be straighforward for @everythingfunctional to hardcode it for now. I think that's a reasonable temporary solution."
                },
                {
                    "user": "certik",
                    "date": "2020-04-28 21:56:15+00:00",
                    "text": "fpm can optionally allow setting the compiler + options both at the package level (fpm.toml) as well as the fpm level (command line options / configure file such as ~/.fpmconfig).\nIdeally most packages will not specify either, just use the default as in your tutorial (I agree we should remove the gfortran that is currently still hardwired in fpm.toml even though clearly those examples would compile with any Fortran compiler). That way getting all packages working with a new compiler (say Flang or LFortran later on) would be trivial --- just add support for those compilers into fpm.\nOnly packages that truly require some special handling in compilers should do so --- and even then we should try to see what special handling they require. I've seen that some old f77 code requires the -std=legacy gfortran option. In that case I would suggest to not make them gfortran specific, but rather introduce a legacy=true fpm option (or in this case std=f77, std=f2018, ...), that would (in principle) work with any Fortran compiler and fpm would figure out what options must be set for each compiler."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:16:23+00:00",
                    "text": "This looks really good. I haven't read all the way through it yet, but I did notice a few inconsistencies with how I actually finished implementing all the toml options. I suggest we go ahead and merge this though, and then I'll fix any inconsistencies on my branch before we merge it. I should be able to do that within the next few days.\nI'll note that while in my implementation the compiler flags are hard coded, the compiler actually isn't. I suspect in the short term we'll pick different hard coded flags based on the compiler specified, and long term we'll come up with a compiler agnostic way of specifying special flags needed for a given project."
                }
            ]
        },
        {
            "number": 59,
            "user": "milancurcic",
            "date": "2020-04-26 18:46:49+00:00",
            "title": "remove -Werror gfortran flag",
            "text": "Fixes #56",
            "comments": []
        },
        {
            "number": 58,
            "user": "milancurcic",
            "date": "2020-04-26 18:44:47+00:00",
            "title": "Update readme and executable name",
            "text": "This PR:\n\nUpdates install instructions in the README and adds instructions on how to use fpm.\nRenames FPM executable from fpm-exe to fpm.\n\nFixes #55",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:56:01+00:00",
                    "text": "@certik Does this look good? It's a simple PR."
                }
            ]
        },
        {
            "number": 57,
            "user": "milancurcic",
            "date": "2020-04-26 18:18:15+00:00",
            "title": "fpm assumes .mod has the same name as the source file",
            "text": "If I have a source file datetime.f90 that contains a module called datetime_module, then gfortran (and all other compilers I believe) output datetime_module.mod. However, fpm expects datetime.mod and can't find it.\nI believe the assumption about .mod filename comes from somewhere around here, however I don't have a solution right now.\nI think the safe assumption is that the .mod file will have the module name, for fpm will need to scan the source file to get this info.\nFurther, a source file can have multiple modules defined, and for each the compiler will emit one .mod file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:06:21+00:00",
                    "text": "That assumption actually comes from here.\nThe reasoning is that we want the file name to match the module name, and the module name to include the path components of the file name. This was a basic structure to help with organizing modules that @certik and I came up with.\nThere are ways to just inspect the source files and figure out the module names and dependencies more flexibly, but for our initial implementation we wanted to keep things as simple as possible and try and encourage a common organizational convention.\nObviously this is something that should be added to the README. @certik , do you think you'll have time to write up our standard conventions in the README any time soon?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:27:04+00:00",
                    "text": "Specifically for datetime-fortran, that's fine. I'm happy to rename the source file so it can build with fpm.\nI also support encouraging the practice one module per source file, with file name matching the module.\nHowever, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\nThis made me think now: why would there be an expectation for a specific .mod file to be present? AFAIK, the compiler cares only about the include path and that the modules are there. It knows how to find the file in the include directory. So, this requirement by fpm seems artificial to me. Could it be removed so that fpm only checks for .o files? I think it's safe to assume that if .o file is created, that the .mod files have been created as well."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:28:26+00:00",
                    "text": "However, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\n\nRelated to this, I think more problematic is that this requirement would prevent fpm from building correct and modern Fortran code."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 04:22:28+00:00",
                    "text": "It's more about rebuilds. If you change a module and rebuild, then if the .mod file changes, you need to rebuild everything that depends on it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 05:12:55+00:00",
                    "text": "Yes, the default layout restricts what can be done, and you want that. It's not meant as a replacement for cmake, which allows you to do anything, but you pay for it by maintaining a complex buildsystem. We want to rather create a convention, that would allow fpm to figure out everything by itself.\n\nFor existing packages we either have to adapt them, or we need to tell fpm extra information where things are.\n\u2026\nOn Sun, Apr 26, 2020, at 10:22 PM, Brad Richardson wrote:\n\n\n It's more about rebuilds. If you change a module and rebuild, then if\n the .mod file changes, you need to rebuild everything that depends on\n it.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#57 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBXBCUBJJZTLO54K4LROUCBBANCNFSM4MRK6V2A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 12:27:17+00:00",
                    "text": "Okay, sounds good. We can revisit if it shows to be an issue, I don't think it is right now.\nYes, it'd be good to discuss and write out requirements for packages. I don't remember seeing this specific one anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 15:58:24+00:00",
                    "text": "@milancurcic see #39."
                }
            ]
        },
        {
            "number": 56,
            "user": "milancurcic",
            "date": "2020-04-26 17:59:16+00:00",
            "title": "Correct code fails to build due to hardcoded -Werror",
            "text": "fpm is currently making gfortran fail on warning by hardcoding -Werror. Removing -Werror from fpm.toml doesn't change this behavior (I understand specifying flags via fpm.toml may not be implemented yet.\nHowever, in the meantime, we shouldn't use -Werror because it's making correct code to fail. For example:\n[milan@gary test_project_error]$ cat src/mylib.f90 \nreal :: a, b\na = 2.\nb = 2.\nprint *, a == b\nend\n[milan@gary test_project_error]$ cat fpm.toml \nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = []\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n[milan@gary test_project_error]$ fpm build\n# gfortran (for build/debug/library/mylib.o build/debug/library/mylib.mod)\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o build/debug/library/mylib.mod\n  at cmd, called at src/Build.hs:179:19 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Raised the exception:\nDevelopment.Shake.cmd, system command failed\nCommand line: gfortran -c -Jbuild/debug/library -Wall -Wextra -Wimplicit-interface -Werror -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -o build/debug/library/mylib.o src/mylib.f90\nExit code: 1\nStderr:\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\n\nWhat do you think?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-04-26 18:15:42+00:00",
                    "text": "I think Werror is not your friend and should not be used here; especially here where we cannot guarantee a specific compiler version.\nLatest gfortran actually produces spurious warnings for certain derived-type allocations so Werror would completely prevent you from producing a debug build.\n#50"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:15:52+00:00",
                    "text": "As I mentioned on the PR, I'm fine with removing the -Werror flag from the default list. But in this instance I will point out that comparison of reals really is a bad idea. Floating point math means that equality will almost surely never be true. For example, I'm pretty sure (1.0 / 3.0) == ((1.0 / 9.0) * 3.0) is false, when you really would expect it to be true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:35:26+00:00",
                    "text": "In most cases, yes, and that's why there should be a warning for it. :)"
                }
            ]
        },
        {
            "number": 55,
            "user": "milancurcic",
            "date": "2020-04-25 17:52:58+00:00",
            "title": "stack build does not add fpm executable to path",
            "text": "First time running stack. On running stack build, it looks like the fpm executable is not installed in any working path. I expected it to be installed either somewhere under stack like pip does, or locally and then added to my path.\nFor example, I'm working in /home/milan/Work/fortran/fpm, fpm-exe is installed here: /home/milan/Work/fortran/fpm/.stack-work/install/x86_64-linux-tinfo6/68e6a00e61079ec9146947ae047a1ce619d26ace12c1e4cd5fd58ceb496743b0/8.6.5/bin\nso I had to add this to my PATH.\nIs this expected behavior? If not, is this an issue with stack or with fpm?\nfpm-exe should be called just fpm.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 17:20:18+00:00",
                    "text": "stack build is not supposed to install the executable. I'll have to try it, but I believe stack install will do what you are after. I think it typically will install it to $HOME/.local/bin."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 18:58:34+00:00",
                    "text": "Thanks, I tested stack install and it works."
                }
            ]
        },
        {
            "number": 54,
            "user": "everythingfunctional",
            "date": "2020-04-14 00:37:36+00:00",
            "title": "Additional testing",
            "text": "Set up and test some example projects",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-22 02:46:11+00:00",
                    "text": "I think this is now sufficient for any project, with no dependencies, on any platform. But please feel free to put it through the ringer and let me know if you find anything."
                },
                {
                    "user": "certik",
                    "date": "2020-04-22 03:54:13+00:00",
                    "text": "Thanks @everythingfunctional. I'll test it out soon. I was really busy with other things lately."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 19:00:58+00:00",
                    "text": "I just noticed this didn't make it to master yet. I will play with it. So far I worked only with current master."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 23:29:17+00:00",
                    "text": "@certik , do you want a chance to test it out, or should I go ahead and merge this?"
                }
            ]
        },
        {
            "number": 53,
            "user": "everythingfunctional",
            "date": "2020-04-11 22:45:31+00:00",
            "title": "Finish commands",
            "text": "Finish the required functionality for a project with no dependencies.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-12 05:15:52+00:00",
                    "text": "Yeah, we should test a variety of setups, with default settings, specified default settings, and non-default settings. I guess my next steps should be to come up those examples."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-13 02:47:40+00:00",
                    "text": "@milancurcic , absolutely."
                },
                {
                    "user": "certik",
                    "date": "2020-04-13 17:40:38+00:00",
                    "text": "Thanks @everythingfunctional for working on this. It's quite difficult for me to contribute to the Haskell code base, as I am still learning it, but I'll be able to greatly help with the test cases --- if you provide some initial tests, I'll submit PRs with more tests."
                }
            ]
        },
        {
            "number": 52,
            "user": "everythingfunctional",
            "date": "2020-04-11 21:46:12+00:00",
            "title": "Finish simple project settings",
            "text": "This finishes up all the necessary settings for a basic simple project",
            "comments": []
        },
        {
            "number": 51,
            "user": "everythingfunctional",
            "date": "2020-03-31 20:50:29+00:00",
            "title": "Two stage settings",
            "text": "This splits the settings for FPM into a two stage process and starts to make use of that for default behavior",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 20:53:18+00:00",
                    "text": "The architecture is starting to come together and look reasonable so far. No major changes should be needed from this point to support all 3 commands for a project with no dependencies. I think that will be my next step after this."
                },
                {
                    "user": "certik",
                    "date": "2020-04-04 16:19:42+00:00",
                    "text": "Yes, our goal should be that fpm packages work with all compilers by default. My experience is with larger Fortran codes that they typically work with a few particular compilers but not all, e.g., one of our codes works with Intel and NAG, but not gfortran. I don't know if it makes sense to allow fpm packages to restrict which compilers it works with. But for now I would simply allow all.\n\u2026\nOn Sat, Apr 4, 2020, at 9:33 AM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \ud83d\udc4d\n\n Should the compiler choice (e.g. gfortran) be set in fpm.toml? It seems\n to me more appropriate to be a local fpm setting and not a package\n setting. It's okay here for now, just a note for later.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#51 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHLSETPQZ5T3WR6ILLRK5HNLANCNFSM4LX72EBA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-04 17:17:08+00:00",
                    "text": "My thought is that the fpm.toml doesn't specify which compilers a package works with, but which compiler is used by default when building that package on its own. When building a package as a dependency for another project I don't expect any settings to be taken from the fpm.toml file except where to find the source files, and what other dependencies are needed. Compiler, flags, any other relevant settings would be set by the parent project and be in effect for building all dependencies."
                }
            ]
        },
        {
            "number": 50,
            "user": "everythingfunctional",
            "date": "2020-03-30 15:20:37+00:00",
            "title": "Compiler flags",
            "text": "How should we organize/specify compiler flags?\nShould we only have two sets of compiler flags? devel-options and release-options, and they are used to build all dependencies and executables?\nAlso, should we come up with our own keywords for specifying the compiler options, and have a look up table to determine the correct flag for each compiler?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 16:29:04+00:00",
                    "text": "We will have to iterate on this, I don't know all the details either yet. Here are some guiding principles:\n\nWe should have Debug and Release builds. (I would call it Debug, not Devel.)\nPerhaps also ReleaseCheck (that would enable all optimizations, but keep all runtime checks; it could be named differently, perhaps ReleaseSafe, or something).\n\nThe Debug build should enable all runtime and compile time checks / warnings that a given compiler allows. The Release build should make the fastest build for the given architecture. For ifort I think that's the default (i.e. no options). For gfortran that's -O3 -march=native -ffast-math -funroll-loops (the later gfortran versions also have -Ofast which does a lot of these and a few more --- so we should look into it and probably use it).\nSo as a start, I would start with Debug and Release. Then as we go, we can keep refining it.\nWe can take the initial options for gfortran / Intel from here:\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-development\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-production-run"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 19:07:49+00:00",
                    "text": "Those are good suggestions for defaults. But I'm more talking about what we want to allow users to specify.\nShould we only allow users to specify a single set of compiler flags for each of debug and release modes? Or should there be some more granularity available? Different flags for executables vs libraries?\nAlso, when a user specifies compiler flags manually, should they specify the flags directly (i.e. \"-funroll-loops\") or with a more generic option that looks up the specific flag for the given compiler?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:22:45+00:00",
                    "text": "Ah I see. I would definitely allow to specify any compiler flag to any file and any executable / library. That way it should be possible to build any project out there. It's just that we want to discourage users doing that obviously, but we should allow that.\nRegarding \"generic options\" like \"unroll loops\" for \"-funroll-loops`, I would not do that, because I think it will be very hard to find such options for every compiler. Initially the only generic options that I would allow are Debug / Release / ReleaseSafe. Later on, we can perhaps add more, if users request them.\nSo for example, the user can select Debug mode that would be applied to every file, except those that the user specifically sets manually."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 21:49:28+00:00",
                    "text": "Ok, that's definitely going to have to take some thinking about how to design on both the fpm.toml side, and the actual build process side."
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:54:46+00:00",
                    "text": "We should not over design this. Right now we are just writing a prototype, to help us figure out the requirements, because what you are asking for are the requirements which we do not know yet, until we gain more experience using fpm with actual Fortran codebases."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 13:52:31+00:00",
                    "text": "You're right. I'm just going to leave out the options to specify compiler flags for now. Until we have time to design it properly."
                }
            ]
        },
        {
            "number": 49,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:35:57+00:00",
            "title": "TOML to Settings Architecture",
            "text": "I'm creating this as mostly a reference for how I think we should proceed with having sane defaults to allow minimal fpm.toml files. Right now I'm just reading the toml contents directly into the data structure for the settings for building the project. What I think will make more sense is to have two different data structures. One for reading the settings from the fpm.toml file, and a slightly different one for the settings for the project passed to the rest of the process. This will allow a step for interrogating the file system for some of the defaults based on the presence/absence of information in the fpm.toml file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:23:55+00:00",
                    "text": "Closing this since it's been implemented this way."
                }
            ]
        },
        {
            "number": 48,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:30:02+00:00",
            "title": "Simplify example project",
            "text": "This simplifies the example project and sets things up to begin building according to the settings read from fpm.toml",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 21:10:03+00:00",
                    "text": "Thanks!"
                }
            ]
        },
        {
            "number": 47,
            "user": "everythingfunctional",
            "date": "2020-03-24 21:12:17+00:00",
            "title": "Read fpm toml",
            "text": "Start reading the settings for a package from fpm.toml",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-24 21:37:14+00:00",
                    "text": "I've got it reading the first setting from an fpm.toml file. Take a look and let me know what you guys think."
                },
                {
                    "user": "certik",
                    "date": "2020-03-24 22:17:35+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 13:36:18+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo.\n\nImplicit layout will be a bit trickier to implement I think. The default would be only one executable, with main having the default expected name (probably main.f90).\nAll doable. I think we should start with explicit, make sure that works, then come up with lots of example projects, leaving various things out to allow for defaults."
                },
                {
                    "user": "certik",
                    "date": "2020-03-25 16:14:15+00:00",
                    "text": "Here is our last iteration that we did at the Committee meeting in Vegas:\n#39 (comment)\nAnd to have more executables in the app directory, you just add more subdirectories just like Cargo does it I think."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-25 16:39:30+00:00",
                    "text": "I think the purpose of going for an implicit, minimal, sane default is that it can be implemented most quickly. You can then assess what's most needed to generalize next. I prefer this approach to development and we use it at Cloudrun.\nOtherwise, we have to make a lot of assumptions on what are all the options and edge cases that will be desired, and we'd spend a lot of time doing that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:03:06+00:00",
                    "text": "With the toml parser I'm using, it's actually easiest to define the data structure that holds all the necessary settings, and require they be present in the toml file. Then we can figure out how to make that setting optional (have a default). Yes we should start with the simplest possible project and the simplest settings, but it actually is easier to make them required first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:05:47+00:00",
                    "text": "I'm going to merge this in and then take a stab at simplifying the example project and it's toml file to the bare minimum."
                }
            ]
        },
        {
            "number": 46,
            "user": "everythingfunctional",
            "date": "2020-03-13 02:25:57+00:00",
            "title": "Create first draft of an example fpm.yaml file",
            "text": "This is a first shot at what an fpm.yaml file might look like.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-13 03:38:04+00:00",
                    "text": "Thanks for trying to figure out what to put in.\nMy view is to do exactly what Rust / Cargo does. In Cargo, you can set many of these options, but by default, you do not, and you follow the layout. And you then tell cargo to build in Release or Debug modes, and Cargo chooses the default options.\nIn our case, I was thinking of following exactly the same approach. That is, fpm will support all Fortran compilers. Which means, the compiler specific options should not be set in fpm.toml, because those would be specific to a compiler, so would not work with another compiler.\nSo I would suggest to simplify your example as follows:\nname:                package-name\nversion:             0.1.0\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\ndependencies: \n- stdlib\n\ntests-dependencies:\n    - vegetables 1.0  # I think in Cargo this means >= 1.0 and < 2.0\nFinally, I would follow Cargo's naming conventions.\nI am going to post a TOML example."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 03:44:41+00:00",
                    "text": "Here is the TOML equivalent:\n[package]\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthors = [\"Author name here <example@example.com>\"]\nedition = \"2018\"\n\n[dependencies]\nstdlib = \"0.2.3\"\n\n[dev-dependencies]\nvegetables = \"1.0\""
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 04:00:30+00:00",
                    "text": "For comparison, a literal translation of the YAML to TOML is:\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = [\"../std-lib.tar.gz\"]\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-Werror\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n\n[executables.executable-name]\nmain = \"Main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\ndependencies = [\"iso_varying_string\"]\n\n[tests.test-name]\nmain = \"Spec.f90\"\nsource-dirs = \"test\"\nlinker-options = [\"-Og\"]\ndependencies = [\"vegetables >= 1.0 && < 2.0\"]\n(But as I said, I think we should simplify some of the sections and follow Rust's naming scheme.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-11 17:59:46+00:00",
                    "text": "Closing, since we're going with toml"
                }
            ]
        },
        {
            "number": 45,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:08:54+00:00",
            "title": "Package File Spec",
            "text": "We need a specification, or at least a start of one, for what should go into the package file and how it should be organized.\nI'd suggest we start by answering the question \"What does fpm need to know about a package in order to be able to build it?\" in as much detail as possible and then trying to organize it logically.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:24:59+00:00",
                    "text": "I think we've settled this now?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:42+00:00",
                    "text": "Yes.\n\u2026\nOn Wed, Apr 29, 2020, at 9:25 PM, Brad Richardson wrote:\n\n\n I think we've settled this now?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#45 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBSCLSYDG6OBIOZH73RPDVRPANCNFSM4LGDENXA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:06:16+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 44,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:05:20+00:00",
            "title": "toml or yaml or something else",
            "text": "Are we sold on using toml as the file format for a package manifest/configuration file?\nI see that Rust uses toml, but many other package mangers use others. Haskell's Stack uses yaml, and I think I've seen others use that. I think I've also seen json, and maybe even xml.\nA new project Cargo.toml looks like:\n[package]\nname = \"rusttest\"\nversion = \"0.1.0\"\nauthors = [\"Brad Richardson <brichardson@structint.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nand a new project package.yaml (for Haskell) looks like:\nname:                haskelltest\nversion:             0.1.0.0\ngithub:              \"githubuser/haskelltest\"\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/githubuser/haskelltest#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  haskelltest-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\ntests:\n  haskelltest-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\nI'm not strongly opposed to toml, but it's the one I'm least familiar with. My gut tells me we should go with yaml. I would not suggest json or xml though, too much syntax/line noise.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 00:35:16+00:00",
                    "text": "Both toml and yaml look good and have sufficient capability. Yaml is personally slightly prettier to me.\nWhich has a more mature parser in Haskell? Let's go with that one.\nI recommend against json for configuration files (even though I use it a lot) because it doesn't allow comments. This would make it harder to work with them in development and testing when you want to quickly try out different values. It's also a bit more noisy (verbose) than either toml or yaml.\nxml burns my eyes."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 01:44:44+00:00",
                    "text": "There are parsers for both that seem pretty mature. I just think yaml is more naturally represented as a simple/common data structure, so it is easier to work with once it's parsed.\n@certik , do you have a vote?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 01:50:06+00:00",
                    "text": "I vote for toml, I think it's more readable, that's what Rust and Python uses and I would follow exactly the Rust model for everything unless we have a good reason not to. Fortran is close to Python and Rust in most respects than to Haskell.\n\u2026\nOn Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n\n\n There are parsers for both that seem pretty mature. I just think yaml\n is more naturally represented as a simple/common data structure, so it\n is easier to work with once it's parsed.\n\n @certik <https://github.com/certik> , do you have a vote?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#44 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 02:03:10+00:00",
                    "text": "Here are good pros and cons:\n\nhttps://www.reddit.com/r/rust/comments/7izxrg/toml_or_yaml_for_config/\n\nOne big downside of yaml is that it is very complicated. TOML is very simple for flat configuration files, and Cargo shows that flat is enough. And we should strive for flat.\n\nI agree that we should not use JSON or XML.\n\u2026\nOn Thu, Mar 12, 2020, at 7:49 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I vote for toml, I think it's more readable, that's what Rust and\n Python uses and I would follow exactly the Rust model for everything\n unless we have a good reason not to. Fortran is close to Python and\n Rust in most respects than to Haskell.\n\n On Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n >\n >\n > There are parsers for both that seem pretty mature. I just think yaml\n > is more naturally represented as a simple/common data structure, so it\n > is easier to work with once it's parsed.\n >\n > @certik <https://github.com/certik> , do you have a vote?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#44 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 03:10:43+00:00",
                    "text": "@certik , that sounds reasonable. I put together an example of what an fpm.yaml file would look like (#46). Could you try converting that to toml so we can see what that would look like?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 04:08:58+00:00",
                    "text": "I am now in favor of toml as well. I like the idea of following the Rust packaging model."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 16:29:17+00:00",
                    "text": "@everythingfunctional see my comments at #46: #46 (comment) how it would look like in YAML and TOML. Let me know your thoughts."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-23 16:56:09+00:00",
                    "text": "I think the TOML looks fine. I'll start trying to put together the logic to pull in the dependencies, and compile them in the right order based on the fpm.toml file."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 18:49:37+00:00",
                    "text": "@everythingfunctional perfect. Let me know once you have something, and I'll test it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-28 18:31:28+00:00",
                    "text": "I'm going to go ahead and close this issue, since I think we've decided to stick with toml. Plus we're now moving forward in that direction."
                }
            ]
        },
        {
            "number": 43,
            "user": "everythingfunctional",
            "date": "2020-03-07 03:48:33+00:00",
            "title": "Add place to specify other libraries when building library",
            "text": "This completes all the necessary capabilities of the build system.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-09 03:32:59+00:00",
                    "text": "Next step is to start putting together fpm.toml files and code to read them."
                }
            ]
        },
        {
            "number": 42,
            "user": "everythingfunctional",
            "date": "2020-02-28 15:52:57+00:00",
            "title": "Bpr add build system",
            "text": "Can now build a single project. Assumes all files in the app directory are programs.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 16:15:59+00:00",
                    "text": "I tested it locally and it seems to work. Thanks!"
                }
            ]
        },
        {
            "number": 41,
            "user": "certik",
            "date": "2020-02-25 22:45:09+00:00",
            "title": "Test calling GFortran from Haskell",
            "text": "Tests the new builder on the example.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 17:27:18+00:00",
                    "text": "@everythingfunctional I think the build code in master failed on Windows: https://github.com/fortran-lang/fpm/pull/41/checks?check_run_id=475345857"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-04 04:16:07+00:00",
                    "text": "Got it to work on Windows. Problem was inconsistencies with file paths. At various places, Shake normalizes them to Linux form, but other things are still in Windows form."
                },
                {
                    "user": "certik",
                    "date": "2020-03-04 04:41:30+00:00",
                    "text": "@everythingfunctional thanks a lot for fixing it! I am really happy it works on Windows also."
                }
            ]
        },
        {
            "number": 40,
            "user": "everythingfunctional",
            "date": "2020-02-25 18:34:35+00:00",
            "title": "Switch to using Haskell",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-25 18:43:48+00:00",
                    "text": "The Linux and Mac works, the Windows fails due to mstksg/setup-stack#5. I am figuring a workaround."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 18:48:36+00:00",
                    "text": "@milancurcic: To describe our plan here: @everythingfunctional and I decided to join forces on FPM. Brad has already an implementation in Haskell of a subset of what we want FPM to do, and we decided to use his code to get the minimal viable version of FPM. So we'll do it in Haskell. It turns out Haskell's Stack is like Rust's Cargo, and both do what we want to achieve with FPM.\nOnce we have the minimal viable version working, we, as a community, will have to choose a language to implement this in for the long run (I still think Rust is not a bad option). But for now our goal is to get a minimal version out there, and the best is to join forces as much as we can."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 18:54:02+00:00",
                    "text": "Sounds good. I like Haskell as well. I was more interested in learning Rust though. However this is a practical decision and getting to MVP sooner is what matters.\nI only wish this was discussed in the open rather than decided under the table. Not so much about who makes the decision, but more about how and why are decisions made."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:04:34+00:00",
                    "text": "@milancurcic thanks for the comment. (Yes, I am personally more interested in learning Rust also.)\nI should have phrased it differently. We are working on the PR and once we are done with the PR, we would like to get a community agreement that this would be an ok path to get to the MVP. We have not made the decision under the table. Only if the community agrees, then we will merge the PR.\nThe downside is that Haskell is not as well known language. The huge upside is that now we have 2 developers (@everythingfunctional and myself) as opposed to just one developer (myself). And that, in my eyes, outweighs the slight negative of using a different language for the MVP.\nOnce MVP is out, we would need to decide what language to use for the long run. (I think I would prefer either C++ or Rust for that.)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:16:03+00:00",
                    "text": "Thanks for clarifying that, sounds like a good plan."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:49:57+00:00",
                    "text": "Tests pass. This is currently just a bare bones Haskell project, but it runs on Linux, macOS and Windows.\n@milancurcic would you be ok with merging this PR now? It would help us to develop faster --- have a master that passes tests everywhere and we can quickly send PRs to get the features implemented. The Rust version is still there in the archive directory if we every wanted to come back to it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-25 19:51:27+00:00",
                    "text": "I think we can have some MVP within the week. If things go wrong or the community would rather switch back to using Rust or something else, we can always switch back to that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:58:00+00:00",
                    "text": "This is fine with me. As I'm not actively engaged yet, I don't have much say. But I also don't foresee issues when I do start contributing. So please go ahead with whatever you find is the best way forward and keep discussing."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 22:08:44+00:00",
                    "text": "Thanks @milancurcic! We'll keep you updated."
                }
            ]
        },
        {
            "number": 39,
            "user": "certik",
            "date": "2020-02-24 21:56:43+00:00",
            "title": "Package layout",
            "text": "We've been working with @everythingfunctional on the standardization of the layout. First iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n$ cat fpm.toml \nName \"a\"\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-24 23:17:07+00:00",
                    "text": "Here is a second iteration of the above layout:\n$ tree .\n.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main.f90\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 x\n    \u2514\u2500\u2500 x.f90\n\n5 directories, 6 files"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:22:34+00:00",
                    "text": "I'm really confused now.\n\nThis thread doesn't say that the source file should have the same name as the module;\nIt actually implies that it can be different, e.g. utils.f90 defines module a_utils.\nfpm can't build this example because of #57.\n\nSo based on feedback so far, I assume that source file should be named the same as the module, and perhaps the spec in this thread is out of date. Then you have (ignoring app and x.f90 for simplicity):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 a_b_utils.f90\n\n2 directories, 4 files\n\nNow the source files have the same name as the modules they define. This doesn't work either because fpm builds b_a_b_utils.o out of src/b/a_b_utils.f90:\n# gfortran (for build/debug/library/a_utils.o build/debug/library/a_utils.mod)\n# gfortran (for build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod)\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/debug/library/b_a_b_utils.o\n  build/debug/library/b_a_b_utils.mod - MISSING\n\nOkay, so fpm does some renaming of files under the hood--b/a_b_utils.f90 compiles to b_a_b_utils.f90. But the compiler emits a_b_utils.mod and fpm expects b_a_b_utils.mod.\nA-ha! Maybe I need to call my module b_a_b_utils:\n$ head -1 src/b/a_b_utils.f90 \nmodule b_a_b_utils\n\nGreat, fpm now builds correctly.\nPerhaps this is what Brad meant in #57 when he said\n\nwe want the file name to match the module name, and the module name to include the path components of the file name.\n\nI didn't understand this because the 1st half of the sentence conflicts the 2nd half of the sentence.\nBut I think the 2nd half is key: If you have src/a/b/c/utils.f90, then the module should be called a_b_c_utils.\nGiven this, perhaps I can reverse engineer the correct spec. Let's try a third iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502   \u2514\u2500\u2500 b_utils.f90\n    \u2514\u2500\u2500 utils.f90\n\nThen, the contents are:\n$ cat src/a.f90 \nmodule a\nuse utils, only: util1\nuse b_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/b_utils.f90 \nmodule b_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nfpm builds this correctly.\nNow, if I went through this much trouble to figure this out with help from fpm developers, imagine other people trying to build their thing with fpm. :)\nWe need a clear, clean, explicit spec."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 17:34:12+00:00",
                    "text": "@everythingfunctional and I discussed this, and the solution that we both liked in the end is precisely as I posted above (which is different to your comment), I just didn't have time to write it more explicitly. @milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\nThe most natural way seems to have a file src/a/b/utils.f90, which means a package \"a.b\", and module \"a.b.utils\" (using Python syntax). However, in Fortran we do not have nested packages, until j3-fortran/fortran_proposals#86 is implemented. But what we can do now is to put the package name in the name of the module, so the file src/a/b/utils.f90 would start with module a_b_utils and fpm would check / enforce it. To move files around, you can simply move them, and fpm will have a mode to rename the first module line correctly.\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\nNow we are just working on fpm to work like this. If there are some bugs, then we need to fix them.\nIn particular, we need to write more tests, which would clarify what is meant to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 17:38:11+00:00",
                    "text": "Ok, yeah. Here's what I think the specification about that would be.\nfpm replaces the path separators with underscores when determining the name of the .o file to be created when compiling a given source file. For modules, it also expects compiling that source file to create a .mod file with the same name as the .o file. This means that a source file a/b/utils.f90 should contain a module named a_b_utils.\nI'm sure this could use a bit more wordsmithing or clarification. It also needs to be fit into a larger specification about the expected (default) organization of an fpm compatible project, with instructions about how to override the defaults."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:57:01+00:00",
                    "text": "@milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\n\nWhat do you think I'm doing? :)\n\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\n\nI don't propose that, it's how I originally understood Brad, but that's not what he meant and I understood it later. What led me astray is that the 2nd iteration of your tree wasn't consistent with the module names in the original post.\nBased on the feedback, here's the package structure (same as Ondrej's 2nd iteration):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n\nAnd here are the contents:\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/a_utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nDoes this look correct?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 18:17:27+00:00",
                    "text": "Almost. You are still putting the prefix into the filename in a_utils.f90. It should look like in #39 (comment). So put a_utils.f90 into a/utils.f90.\nI also had the b module nested under a, but that just depends what you are trying to show. Both can be done."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:27:00+00:00",
                    "text": "Oops, you're right, I did that. If we ignore src/x* and app, we get:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_b_utils\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_utils\n    \u2514\u2500\u2500 a.f90 # module a\n\n3 directories, 4 files\n\nI put module names as # comments next to each file. I think this is correct now and I agree with it.\nIf you agree, I'll submit a PR to document this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:32:28+00:00",
                    "text": "Btw, current master of fpm builds this correctly."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 19:04:45+00:00",
                    "text": "@milancurcic yes, if you could please document this and the reasoning behind this decision, that would be awesome. I am really happy you agree with this also. It's different to what I've been used to doing, but only in the fact that each module has the full name in the module line (and when you think about it, it makes sense to do it that way until j3-fortran/fortran_proposals#86 is implemented). Otherwise I've seen lots of projects structured in directories like this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 20:38:49+00:00",
                    "text": "It looks like we're on the same page now. Thanks for struggling through this @milancurcic . I know we didn't do a very good job documenting it, so your efforts are hugely appreciated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:30:00+00:00",
                    "text": "I think this is pretty well settled now. Should we close this?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:10+00:00",
                    "text": "We should document these choices and why we chose it. Then we can close this. Because this will come up again.\n\u2026\nOn Wed, Apr 29, 2020, at 9:30 PM, Brad Richardson wrote:\n\n\n I think this is pretty well settled now. Should we close this?\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#39 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWES7J5OW4SJVYLBDYLRPDWENANCNFSM4K2TQKOQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:41:18+00:00",
                    "text": "This issue does not have much info anyway and it is documented in the tutorial a bit, so let's close this one."
                }
            ]
        },
        {
            "number": 38,
            "user": "certik",
            "date": "2020-02-23 18:31:31+00:00",
            "title": "Implement common_prefix",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-23 18:40:48+00:00",
                    "text": "There is a failure on Windows due to / vs \\. I am glad we test it. I have to investigate and fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:53:58+00:00",
                    "text": "I am going to close this one for now."
                }
            ]
        },
        {
            "number": 37,
            "user": "certik",
            "date": "2020-02-20 21:37:08+00:00",
            "title": "CI: Do not install GFortran (already present)",
            "text": "Implemented in actions/virtual-environments#202 (comment).",
            "comments": []
        },
        {
            "number": 36,
            "user": "certik",
            "date": "2020-01-31 19:59:25+00:00",
            "title": "How to handle packages that do not have `fpm.toml`",
            "text": "There will be a lot of packages that do not have fpm.toml. Here is my suggested approach how to handle that:\n\n\nEncourage every package to use fpm.toml and to use fpm.\n\n\nThose packages that do not use it yet could be handled as follows: we will maintain a version (fork) at GitHub or GitLab that includes the fpm.toml. It will be this fork that would be used with fpm. From fpm's perspective, each package always contains fpm.toml.\n\n\nThe alternative to (or modification of) 2. is to allow fpm.toml to specify where to find sources of the actual package. So our GitLab package can be just one file fpm.toml that would list the metadata and where to download the sources plus any patches to them.\n\n\nIn particular, here is my plan: I will start with forking the packages listed at #17 and implementing fpm.toml together with any modifications that might be needed. I will not submit a PR back initially, but rather simply get my forks working well with fpm, and test it all out and get some usage. Then, as things start to get more serious and the fpm tool matures, we can easily send a PR against the upstream package and start the discussion with upstream authors if they would be willing to use fpm and maintain fpm.toml themselves. And depending on how this conversation goes, we'll either do just 2., or if we need to, we can also implement 3. in fpm. I expect that upstream authors will give us a list of features that they need fpm to have implemented, and once we do, they would be willing to use it.",
            "comments": []
        },
        {
            "number": 35,
            "user": "certik",
            "date": "2020-01-31 19:25:52+00:00",
            "title": "Full package registry",
            "text": "After #34 is implemented, we can discuss how to implement a full package registry similar to https://crates.io. It would be an extension of #34, which would also include hosting of the tarballs, and collecting usage statistics and other things. I think the solution in #34 can be evolved into this.",
            "comments": []
        },
        {
            "number": 34,
            "user": "certik",
            "date": "2020-01-31 19:22:34+00:00",
            "title": "Minimal metadata registry",
            "text": "After #33 is implemented, the next step is to implement a minimal metadata registry. Here is one way to do that:\n\nHave repository https://github.com/fortran-lang/package-registry that would contain a simple JSON file of this form which is the package registry:\n\n[{\n    \"name\": \"stdlib\",\n    \"versions\": [\n        {\"version\": \"0.3.4\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.4.tar.gz\"},\n        {\"version\": \"0.3.5\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.5.tar.gz\"},\n    ]\n}, {\n    \"name\": \"bspline\",\n    \"versions\": [\n        {\"version\": \"6.0.0\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/6.0.0.tar.gz\"},\n        {\"version\": \"5.4.2\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz\"},\n    ]\n}]\n\n\nWe will then have scripts that take this JSON file and download the actual metadata for each package version. So for example, to obtain the metadata for the package bspline version 5.4.2, it would download the tarball https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz, unpack and it would read its fpm.toml, which would contain all the metadata such as short and long description, the list of dependencies, and other things. Then we can automatically create a website which would list all this metadata. This generated website would contain a generated file metadata.json, which the fpm tool can then download to obtain a searchable data base of packages (fpm search).\n\n\nTo add a new package to registry, just a new simple entry must be made to the above JSON file by hand, say by issuing a PR against the repository.\n\n\nLater we can automate things more, similarly to how conda-forge works (https://conda-forge.org/docs/maintainer/adding_pkgs.html), where to put a new package in, a PR is sent against https://github.com/conda-forge/staged-recipes/, where the CI checks initial quality and that the package builds, and then if it gets merged, the CI actually creates a new repository for the package etc. In our case, we could have a staging repository, and if a PR is merged, the CI would correctly update the above JSON file.\n\n\nWe can discuss if the JSON file should also contain all the metadata from fpm.toml directly. The advantage of the above approach is that it is not redundant, the JSON only contains the minimal amount of information that can be edited and maintained by hand, and if you want more, you download the tarball and read its fpm.toml, which will be done automatically in the step 2.\nOverall, this minimal package registry only contains a minimal JSON file. The actual tarballs and metadata are hosted elsewhere. After this is well implemented and works, we can evolve it into a full package registry (#35).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-31 19:35:29+00:00",
                    "text": "The thing to discuss here, which we didn't have to worry about in #33 is what to do if multiple people want to have a bspline package. Should we require to prefix it with the github organization/user name, as in jacobwilliams/bspline, or what do we do if somebody submits (registers) the bspline name, but there will later be a better, more widely used and popular bspline package. If we simply switch the url for bspline from the old package to the new package, then all kinds of packages that already depend on the old bspline package would break. One approach could be that since most Fortran packages will be in this ecosystem, we would know which packages depend on it, so we could correctly update them all (and rename bspline to bspline_legacy). For example Debian had to rename the git package, as it wasn't the usual git, but some older package that just happened to be called git before the version control system came along. In our case I can see this happening for every popular package name such as \"mesh\", \"utils\", \"spline\", ... So we should have some policy how to handle such things. One such policy can be that we would evaluate the usage and a number of github stars, and allow the most used package to have the more popular name."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 19:49:28+00:00",
                    "text": "Great, thanks! The step 2 in the proposed flow assumes that the package will include its fpm.toml. However, this is only possible if the package has an active maintainer that is willing to maintain the package-specific fpm.toml. Would this not preclude fpm from downloading tarballed packages from the wild, like SOFA for example?\nIf the community maintains all metadata needed to download and build the package in the registry, it would broaden the ecosystem of packages fpm could work with."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 20:00:58+00:00",
                    "text": "@milancurcic your last comment seems to be a bit orthogonal issue, so I created #36 for it to discuss just this aspect of how fpm is designed."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:52:48+00:00",
                    "text": "Now that there's a package that can be built with fpm, let's revisit this issue which is a requirement for installing a package from a remote location such as a GitHub repo.\nI think @certik's idea of a minimal registry is a good start. We'll also need a description field, so that fpm list not just names of packages, but also there (one-line) descriptions, just like other package managers.\nAnother doubt I have is whether this should be a separate repository, rather than part of this repository. In my opinion, keeping it in this repo is simpler because:\n\nOne doesn't need to maintain a separate repo for the registry\nLess confusing for newcomers--there's only one repo (this one), whether you want to contribute to the code, or submit a package to the registry\nIssues+PR system allows clean separation between fpm issues and package submissions to the registry. So we don't need to separate them in another way.\n\nfpm would need to update its registry cache in either approach.\n@certik are there benefits of having a registry in a separate repo, or is it more an esthetic thing?\n\nSeparate vs. same repo question aside, how would this look like from the UI perspective? For simplicity, let's forget about search for now. Let's say we just want to be able to list available packages. This could be something like:\nfpm list\n  datetime-1.7.0 -- Date and time manipulation\n  openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n  stdlib-0.1.0 -- Fortran standard library\n\nUnder the hood, fpm:\n\nFetches the registry\nParses it\nLists individual packages and latest version so you get the above\n\nWe can discuss how to list individual available versions at a later time. Let's try to solve the minimal problem first."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:13:31+00:00",
                    "text": "My initial gut feeling is not to put packages in this repository. Although Spack does it like that and I think it works for them.\n\nEither way, fpm needs to download the packages from the internet, unless we do it like Spack, which reads them from a local repository checkout.\n\nI think since we are in a prototype mode, let's just put everything in this repo. Get things working for a few packages with dependencies and then let's figure out what to do for production version of fpm.\n\nLet's also understand well how Cargo does it and why something does not work for us. Let's also document our reasoning.\n\u2026\nOn Sun, May 10, 2020, at 12:53 PM, Milan Curcic wrote:\n\n\n Now that there's a package that can be built with fpm\n <https://github.com/wavebitscientific/datetime-fortran>, let's revisit\n this issue which is a requirement for installing a package from a\n remote location such as a GitHub repo.\n\n I think @certik <https://github.com/certik>'s idea of a minimal\n registry is a good start. We'll also need a description field, so that\n fpm list not just names of packages, but also there (one-line)\n descriptions, just like other package managers.\n\n Another doubt I have is whether this should be a separate repository,\n rather than part of this repository. In my opinion, keeping it in this\n repo is simpler because:\n\n  * One doesn't need to maintain a separate repo for the registry\n  * Less confusing for newcomers--there's only one repo (this one),\n whether you want to contribute to the code, or submit a package to the\n registry\n  * Issues+PR system allows clean separation between fpm issues and\n package submissions to the registry. So we don't need to separate them\n in another way.\n fpm would need to update its registry cache in either approach.\n\n @certik <https://github.com/certik> are there benefits of having a\n registry in a separate repo, or is it more an esthetic thing?\n\n Separate vs. same repo question aside, how would this look like from\n the UI perspective? For simplicity, let's forget about search for now.\n Let's say we just want to be able to list available packages. This\n could be something like:\n\n `fpm list\n   datetime-1.7.0 -- Date and time manipulation\n   openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n   stdlib-0.1.0 -- Fortran standard library\n `\n Under the hood, fpm:\n\n  1. Fetches the registry\n  2. Parses it\n  3. Lists individual packages and latest version so you get the above\n We can discuss how to list individual available versions at a later\n time. Let's try to solve the minimal problem first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#34 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGTEEJIDXEN5FKTROTRQ3ZYZANCNFSM4KOMKF7A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:33:50+00:00",
                    "text": "I think we should do what Cargo does with crates.io and have a separate repository for packages. Packages are stored there as tarballs and you can interact with it via a simple REST API. This gives us several advantages.\n\nWe can put certain checks in place for packages published to the official repo\nAnyone else can stand up their own repo, and just conform to the same API (i.e. private repos). We can even open-source the code for it\nAnyone else can write whatever tools they like to interact with it\n\nUntil we can get such a service stood up, we should endeavor to keep a list in the fpm README of known packages"
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 13:31:39+00:00",
                    "text": "@everythingfunctional what you are proposing is #35. I think we all agree on that one. We also agree that is a lot of work, and so right now we are discussing what to do until we get there.\nSo far the proposals are:\n\nDocument available packages in the README\nCreate a manual metadata registry (this issue #34)\n\nI think we should definitely try the manual metadata registry, not just a README, as it would allow us to almost get the full experience of #35.\n\nProgressing the discussion further, I proposed above how such a JSON file (if we use JSON) could look like. Milan suggested it also needs a description field. I don't think that's a good idea for the following reasons:\n\nThe description is another thing to handle manually\nIt can change between versions, so it would have to be attached to each version\nIt's duplicate from the upstream package's toml file, another thing to keep in sync.\n\nThe reason I think why Milan proposed it is to make it possible for fpm to print packages with more information about them. I agree fpm should be able to do that, but not in the above proposed way.\nThe same with putting this metadata in this repository.\nRather, we should plan out how to we get to fixing #35. And then in this issue we should do work that is aligned with it.\nSo here I am proposing a draft of such a plan:\n\nThe issue #35 is mainly about hosting tarballs. But everything else about the registry can be done as part of this issue\nHave a separate repository called fpm_registry\nThe fpm_registry will have a JSON file (with the format above)\nTo submit a package (version) to the registry, people send a PR towards fpm_registry to update the JSON file ---- and just like when submitting to pypi or crates, you do not fill out a separate description field, you should not here either --- that gets filled out automatically from fpm.toml (see below)\nThen we have a separate repository plus CI pipeline that automatically takes this JSON file and:\n\ndownloads each package (it can cache old info, so only needs to download new packages), extracts full metadata (description, dependencies, etc.) and uses that information to:\ncreate a nice website with a page for each package that looks like crates.io (has a description, links to dependencies, and any other useful metadata extracted from fpm.toml)\ncreate a \"registry JSON\", which has full metadata for each package, including description\n\n\nfpm gets updated to be able to download this \"registry JSON\" from this auto generated website, and use this \"registry JSON\" to print info about packages, what packages depend on, etc.\n\nThen later on, to take this to implement the full #35, the only thing missing really is just hosting of tarballs. Everything else I think can be reused.\nThe above plan also allows other people (companies) to host their own registry\n\nThe above plan can be started by simply:\n\ncreate an fpm_registry with the minimal JSON\nadd a CI that takes this JSON and creates \"registry JSON\" and hosts it online\nupdate fpm to download and work with this \"registry JSON\"\n\nThese are three simple steps that I can even help implement, I've done something similar for LFortran. This can then be naturally expanded to also create a nice website."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 14:20:14+00:00",
                    "text": "I like that plan. It's usable to the point that even if we don't end up moving to a tarball hosting registry, I don't think anybody would even mind."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:44:57+00:00",
                    "text": "I like this plan as well. So actually this minimal registry is not what's read by fpm, but is read by another program that outputs the \"production\" registry with complete information. This is a good idea because then we don't have to assume ahead of time what is all the metadata that we'll need.\nI realize now that this issue is a step 2 from a 3-step #33. I will write there for now."
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 20:36:37+00:00",
                    "text": "Now when #33 is (mostly) done, let's tackle this issue.\n@milancurcic, @everythingfunctional, let's keep the (centralized) registry in a separate repository. How should it be named? Some ideas:\nhttps://github.com/fortran-lang/package-registry\nhttps://github.com/fortran-lang/fpm-package-registry\nhttps://github.com/fortran-lang/fpm-registry\nI don't really have a preference. This repository will have a JSON or rather a TOML file where people will submit their packages using a GitHub PR. This file will only contain the name of the package, the version and url (everything else is redundant, so should not be there). There can also be the \"latest\"/\"development\" version that would simply download the latest git (and thus things like description can change in this latest version, so that should not be part of this TOML file, but rather only in the upstream repository inside fpm.toml, and we process it automatically).\nWe'll then build CI jobs to process this JSON/TOML file to:\n\ncreate rich metadata JSON file that collects things like descriptions, license, website, logo url (later on), etc. by downloading the package (ensuring it actually downloads...) and reading the fpm.toml inside it.\nadd a section to our fortran-lang.org website (ccing @LKedward) that would probably use the json metadata from the previous point\nimplement fpm search that would use the json metadata from the first bullet point to implement search (so that you can search through the description of the package, not just the name)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 22:46:58+00:00",
                    "text": "Looks good. I like fpm-registry.\nI'm unclear about versions. If this file includes the version number, which version is it? The latest? Perhaps all versions that are fpm-enabled? Or should the version metadata be the responsibility of the package itself?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 22:50:22+00:00",
                    "text": "Re version: all versions that are fpm enabled. This is hard to figure out automatically, as typically old versions are just some git tags, and maybe not all of them are valid / working, etc. So I figured each version has to be explicitly specified, and one of the version can be \"latest git commit\"."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:03:15+00:00",
                    "text": "I like fpm-registry.\nI worry a bit about having to specify every version. But as this is more of a stop-gap measure, I guess it's ok."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:07:59+00:00",
                    "text": "Ok, I created https://github.com/fortran-lang/fpm-registry and gave access to everybody with push access. We can start submitting PRs against that repository to get it up."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:21:17+00:00",
                    "text": "We can continue the discussion at fortran-lang/fpm-registry#1 and other issues there."
                }
            ]
        },
        {
            "number": 33,
            "user": "certik",
            "date": "2020-01-31 04:18:26+00:00",
            "title": "Decentralized package management",
            "text": "Rust allows the packages to be decentralized, they do not have to be listed at https://crates.io/.\nThe Go language does not even have a centralized package registry at all, see this blog post that explains it in the section \"Package Management\":\nhttps://nullprogram.com/blog/2020/01/21/\n\nModules are named by a module path that includes its network location. This means there\u2019s no land grab for popular module names.\n\nI don't like the Go's model that the name of the package is the url, I prefer the Rust model where a package has a simple name, but you specify where it can be downloaded. The end result is the same. (Overall, the Rust package management seems much more thought out, and it seems they fixed the issues that Go is tackling long time ago.)\nI want to implement the same approach for fpm. That will allow us to build an ecosystem of packages for Fortran, without a \"goldrush\" to reserve a popular package name in a centralized registry. Then, as we have a healthy ecosystem of packages, we can add a centralized registry later.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 18:45:30+00:00",
                    "text": "Overall I like this direction. However I'm confused about how this works in practice. Perhaps it's just a terminology issue.\nLike PyPI, Crates serves both as a registry (metadata), and code distribution.\nI agree that it's not feasible for fpm to host and distribute code. It's a huge ordeal and technical challenge.\nHowever, do you also mean that fpm wouldn't have a centralized metadata registry? If yes, how would a newcomer to Fortran and fpm search for packages? It seems to me that if you don't have some centralized metadata registry, the user would need to know what package they need and how to download it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 19:44:11+00:00",
                    "text": "I think it's a step by step process, we start with the step 1. below, then we progress to step 2. and then to step 3.:\n\n\nThis issue #33: indeed there is no centralized metadata registry. The advantage is that there is no \"goldrush\" to reserve popular names in a centralized registry. Initially there is no package search (newcomers must know the package name), but I can imagine actually creating a search --- all we need for people to submit urls of packages out there, and since each is using fpm.toml, we can then create a search of those decentralized packages.\n\n\nIssue #34: minimal centralized registry. Allows a natural fpm search capability.\n\n\nIssue #35: both registry and code distribution.\n\n\nIf step 1. is fully developed, there can actually be a \"decentralized package registry\". It would work just like described in step 2. (see the issue #34 for details), except that there would not be a centralized name for a package, so people could submit various packages (as url) that can have the same name. Then fpm search would give you all the packages with urls to put into your fpm.toml. We can curate this list as a community to prevent spam and malicious code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:51:08+00:00",
                    "text": "Coming from #34, let's discuss how the step 1 (no centralized registry) works. This means we don't need fpm search and fpm list.\nLet's say I just want to fpm install with datetime-fortran as a dependency. I know the name of the package. I don't (and shouldn't) know the URL of the package.\n@certik How does this work? It seems to me that we need some metadata even at this stage.\nOr is the user expected to enter something like:\n[dependencies]\nname = \"datetime\"\nurl = \"https://github.com/wavebitscientific/datetime-fortran\"\nto their fpm.toml?\nBoth approaches seem okay to me for now (latter is simpler), I'm just not clear what's your idea how this works."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:11:38+00:00",
                    "text": "The step 2 in #34 is what we should eventually do, and then step 3 in #35. It looks like we got agreement on both.\nYou can only install datetime-fortran (btw, it should probably just be called datetime) without knowing the url at the step 2., because you need the registry to get the url.\nSo let's start with step 1 in this issue #33. In here I propose to do exactly what Cargo does. Say I want to use datetime in my program. Here are details about Cargo's syntax: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html, so let's do what they do:\nI would have this in my fpm.toml:\n[dependencies]\ndatetime = \"1.7.0\"\nOnce step 2 is implemented, then fpm would have a default registry, and you can also specify your own registry either on a command line or explicitly:\n[dependencies]\ndatetime = { version = \"1.7.0\", registry = \"my-registry\" }\nUntil then, in this step 1, we do not have a registry, so you have to also tell it where it can download the datetime package directly. As explained at the webpage, Cargo only uses the version field if it downloads from a registry, otherwise it ignores it if it downloads it directly from a git repository or a local path. We can start with that approach, if we need more, we can modify that behavior. So here is how you would do it:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nHowever, since we want to move to a registry, and since most projects follow the convention of prefixing the version by v in the git tag (I do in all my projects, and I noticed you do too), I am proposing this natural extension of what Cargo does:\n\nIf git and version is specified, it will checkout a tag named v + version from that git repository\n\nSo with this extension, you would do:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nAnd then later once we move to a registry, you just remove the git field, but keep the version and it would do the right thing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 16:27:04+00:00",
                    "text": "Cargo actually has a different meaning for this:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nThis means that when working in this package, it will download the latest master version of datetime, but for a package that depends on this one, the transitive dependency is version 1.7.0 of datetime from the default registry.\nI'm not saying we definitely shouldn't do what you're suggesting, but if we do it will preclude us from ending up with the same functionality as Cargo. It would also impose a tagging convention on people's repositories that will be unnecessary once we have a proper registry. Also, relying on git tags for official release version identifiers is wide open for abuse."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 16:51:00+00:00",
                    "text": "Perfect, this is what we're after as a first step:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nThis alone will already be a huge improvement over the current state of things.\nWe can work out the nuances of version and registry behavior as we go."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:53:16+00:00",
                    "text": "@everythingfunctional I am glad you noticed that. Let's not do my proposal then, just use tag. I think it is good enough and we will have a minimal registry soon anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 20:25:03+00:00",
                    "text": "@everythingfunctional, @milancurcic I think this issue is fixed now?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 20:36:40+00:00",
                    "text": "Yes, IMO this is good to close."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:06:28+00:00",
                    "text": "Yep, go ahead and close it."
                }
            ]
        },
        {
            "number": 32,
            "user": "certik",
            "date": "2020-01-28 06:37:38+00:00",
            "title": "Implement dependencies",
            "text": "Just like in Cargo.\nWe should work on this after #25 is fixed.",
            "comments": []
        },
        {
            "number": 31,
            "user": "certik",
            "date": "2020-01-28 06:34:52+00:00",
            "title": "Add tests for different build directories",
            "text": "We need to add more tests:\n\n test that the default directory is target (in some temporary directory)\n test other locations of the build directory (will require to construct relative paths in CMakeLists.txt)",
            "comments": []
        },
        {
            "number": 30,
            "user": "certik",
            "date": "2020-01-28 05:54:47+00:00",
            "title": "Cleanup the test program",
            "text": "",
            "comments": []
        },
        {
            "number": 29,
            "user": "certik",
            "date": "2020-01-28 01:55:16+00:00",
            "title": "Use Command::new() instead of Command::cargo_new()",
            "text": "This seems to actually fix the issue #16 as documented at:\nhttps://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255/6",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 02:02:34+00:00",
                    "text": "I need to figure out how to obtain the absolute path to fpm in a platform independent way, and then pass it in. But this approach seems to be able to fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 04:59:06+00:00",
                    "text": "Tests pass. I am now testing that this truly fixes the macOS bug at certik#14."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:34:37+00:00",
                    "text": "It works. I think this really fixed it! I am going to merge this and we'll watch it if it ever fails again."
                }
            ]
        },
        {
            "number": 28,
            "user": "certik",
            "date": "2020-01-25 17:44:14+00:00",
            "title": "Add Cargo.lock",
            "text": "This is the recommended approach for an application.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-25 18:29:18+00:00",
                    "text": "I was surprised by this, but indeed the docs recommend not committing Cargo.lock for a library and committing it for an application. Link for anybody like me who wondered about this:\nhttps://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries"
                }
            ]
        },
        {
            "number": 27,
            "user": "certik",
            "date": "2020-01-25 17:34:00+00:00",
            "title": "Install cmake using apt-get",
            "text": "",
            "comments": []
        },
        {
            "number": 26,
            "user": "certik",
            "date": "2020-01-18 17:31:51+00:00",
            "title": "Build in a target directory",
            "text": "Fixes #24.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-18 18:01:01+00:00",
                    "text": "I just need to fix it up on macOS and Windows."
                }
            ]
        },
        {
            "number": 25,
            "user": "certik",
            "date": "2020-01-18 15:05:48+00:00",
            "title": "Build in temporary directory for tests",
            "text": "After #24 and #31 is fixed, set the --target-dir to a temporary directory for tests. That way multiple tests can reuse the same source directory for different tests, in parallel.",
            "comments": []
        },
        {
            "number": 24,
            "user": "certik",
            "date": "2020-01-18 15:05:05+00:00",
            "title": "Put everything into target/",
            "text": "Put the CMakeLists.txt into target/, and ensure the source directory is not polluted at all.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 06:35:12+00:00",
                    "text": "The basic issue is fixed, but more tests need to be added (#31)."
                }
            ]
        },
        {
            "number": 23,
            "user": "certik",
            "date": "2020-01-18 15:00:29+00:00",
            "title": "Implement --target-dir",
            "text": "",
            "comments": []
        },
        {
            "number": 22,
            "user": "certik",
            "date": "2020-01-18 06:39:01+00:00",
            "title": "Parse fpm.toml",
            "text": "",
            "comments": []
        },
        {
            "number": 21,
            "user": "certik",
            "date": "2020-01-18 00:02:55+00:00",
            "title": "Print the full Rust stacktrace on error",
            "text": "",
            "comments": []
        },
        {
            "number": 20,
            "user": "certik",
            "date": "2020-01-17 23:36:35+00:00",
            "title": "macOS: repeat the test up to 2x if it fails",
            "text": "This is a workaround for #16. It turns out that if the executable fails\nto run, just rerunning all tests typically fixes it.",
            "comments": []
        },
        {
            "number": 19,
            "user": "certik",
            "date": "2020-01-17 20:30:08+00:00",
            "title": "CI repr 6",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-17 20:54:20+00:00",
                    "text": "My apologies, meant to create this one: certik#5"
                }
            ]
        },
        {
            "number": 18,
            "user": "certik",
            "date": "2020-01-16 05:56:24+00:00",
            "title": "Better reporting on terminated processes",
            "text": "This will eventually help fix #16.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-16 06:45:48+00:00",
                    "text": "I think this PR works as expected. In https://github.com/fortran-lang/fpm/pull/18/checks?check_run_id=392603247 it reports more information about the failure due to #16:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nstatus: signal: 9\nstdout: \nstderr: \n##[error]thread 'test_2' panicked at 'INTERRUPTED with signal: 9', tests/cli.rs:35:21"
                }
            ]
        },
        {
            "number": 17,
            "user": "certik",
            "date": "2020-01-15 22:18:24+00:00",
            "title": "Candidate packages to get working",
            "text": "Here are a few good candidate packages to get working with fpm first, that are relatively simple (and so possible to package soon), yet very useful.\nPure Fortran (Simple)\n\n https://github.com/wavebitscientific/functional-fortran\n https://github.com/jacobwilliams/bspline-fortran\n https://github.com/fortran-lang/stdlib\n https://github.com/astrofrog/fortranlib\n https://github.com/certik/fortran-utils/\n https://github.com/wavebitscientific/datetime-fortran\n https://github.com/jacobwilliams/pyplot-fortran\n\nPure Fortran (More Complex)\n\n https://github.com/Reference-LAPACK/lapack\n https://github.com/opencollab/arpack-ng\n https://github.com/jacobwilliams/json-fortran\n https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit\n https://github.com/Goddard-Fortran-Ecosystem/pFUnit\n https://github.com/szaghi/StringiFor (Lots of dependencies)\n\nFortran with non-Fortran dependencies\n\n https://github.com/scivision/h5fortran\n https://github.com/scivision/nc4fortran\n https://github.com/SHTOOLS/SHTOOLS\n https://github.com/unidata/netcdf-fortran\n\nAnd obviously any other more complicated package from https://github.com/fortran-lang/stdlib/wiki/List-of-popular-open-source-Fortran-projects.\nAny other candidates?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-16 03:02:29+00:00",
                    "text": "I added nc4fortran and netcdf-fortran to the list."
                }
            ]
        },
        {
            "number": 16,
            "user": "certik",
            "date": "2020-01-15 15:02:32+00:00",
            "title": "The fpm binary gets interrupted at the CI (macOS)",
            "text": "There is a bug at our CI that I haven't been able to figure out yet. Here is an example of it: https://github.com/fortran-lang/fpm/runs/390475601.\nHere is what I know:\n\n\nIt only happens on macOS, never on Linux or Windows\n\n\nRestarting the build typically fixes it (sometimes it fails 2x or 3x in a row, but eventually it always passes)\n\n\nThe cargo test runs in parallel by default, so I set -j1 to run in serial. That seemed to improve how often it fails (although I could be wrong on that). It still fails sometimes however, so the actual bug is still there.\n\n\nThe error is:\n\n\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n\nWhich is caused by the assert_cmd package, which just uses the Rust's std::process::Command, when the output command did not succeed, but it also failed to retrieve the error code, which according to the documentation means the process was interrupted by the system (with some signal like SIGKILL).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-15 15:31:20+00:00",
                    "text": "And here it failed in master (https://github.com/fortran-lang/fpm/runs/391281163) after merging #15 that passed. So we have to figure this out."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 15:35:41+00:00",
                    "text": "Is there anybody with a Mac that can reproduce this locally?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:39:25+00:00",
                    "text": "I tried it on a macOS yesterday locally, and I can't reproduce it. So we have to Debug it at the CI itself (as I have done in #14), which is quite time consuming."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 06:48:29+00:00",
                    "text": "As reported in #18 (comment), the process gets interrupted with signal 9 (SIGKILL). I suspected that above, but it's nice to have a proof. For some reason macOS kills the fpm process."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 07:03:41+00:00",
                    "text": "This might be a bug at GitHub, so I reported it at https://github.community/t5/GitHub-Actions/GitHub-Actions-on-macOS-randomly-kill-my-test-program/m-p/43526#M5414."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 18:28:12+00:00",
                    "text": "I am trying to reliably reproduce this bug in certik#1."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:44:30+00:00",
                    "text": "One approach to fix this is to do cargo test || cargo test. An example where the first one fails, but the second one succeeds is https://github.com/certik/fpm/runs/396031403."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:56:03+00:00",
                    "text": "This is precisely the kind of issue I am a bit worried with Rust, that the toolchain is not mature enough and will produce binaries that do not work (but only sometimes!). The closest error that I was able to find is:\ngolang/go#19734"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-17 22:05:49+00:00",
                    "text": "But this likely has more to do with GitHub Actions than Rust itself. Neither you nor the person from the GitHub Forum could reproduce it locally, correct?\nI agree it's very important to have fpm work on all 3 major platforms, but I wonder if it's a bit too early to focus Mac OS work 100% of the time? Why not let it fail sometimes? We can manually trigger the build when it does fail."
                },
                {
                    "user": "certik",
                    "date": "2020-01-18 00:20:48+00:00",
                    "text": "I implemented a workaround in #20. The problem with GitHub Actions is that you cannot just restart a single build, you have to restart all the builds. The other issue is that it was already failing a lot with just 3 tests. Once we have hundreds of tests, it might end up failing all the time. For now the workaround implemented in #20 should make the CI robust enough for now. But we'll have to get back to this and fix it.\nThe reason I spent so much time on this is that I thought I can use \"bisection\" to create a minimal example that fails, and figure it out. But I failed. Essentially it's extremely unreliable to trigger the bug by submitting 20 commits. Sometimes they all pass, and sometimes they get 4 failures. And I haven't figured out a minimal example that can reliably trigger it in 20 runs. As I start removing things, the failures become less and less frequent.\nIf #20 doesn't give us reliable CI, then we can switch the macOS build to Azure pipelines or Travis-CI.\nBut having a reliable CI is a must."
                },
                {
                    "user": "certik",
                    "date": "2020-01-21 18:31:06+00:00",
                    "text": "I reported it in the Rust community also: https://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255"
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:35:21+00:00",
                    "text": "I think #29 fixed this issue."
                }
            ]
        },
        {
            "number": 15,
            "user": "certik",
            "date": "2020-01-15 05:42:54+00:00",
            "title": "Remove manual tests",
            "text": "Use \"cargo test\" instead.",
            "comments": []
        },
        {
            "number": 14,
            "user": "certik",
            "date": "2020-01-14 23:15:22+00:00",
            "title": "WIP: try to reproduce the error",
            "text": "",
            "comments": []
        },
        {
            "number": 13,
            "user": "certik",
            "date": "2020-01-14 21:20:21+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:39:55+00:00",
                    "text": "The Linux CI is currently broken at GitHub, but once they fix it, it should pass. The main problem that the macOS build was failing seems to be fixed by a571570. I am going to wait until the CI works again and rerun tests. Once they all pass, we can merge."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 23:08:53+00:00",
                    "text": "I tested almost 10x and the macOS built never failed, so I thought it was fixed. But now it failed twice in a row:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n...\n\nThe CI is killing the runner for some reason, but I don't know why."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 04:30:59+00:00",
                    "text": "The macOS bug is still there, but by restarting the tests it typically fixes itself, so I am going to merge this and we'll eventually figure out what is causing it."
                }
            ]
        },
        {
            "number": 12,
            "user": "certik",
            "date": "2020-01-14 20:47:50+00:00",
            "title": "Draft: See if we get a failure",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:14+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 11,
            "user": "certik",
            "date": "2020-01-14 20:42:36+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:34+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 10,
            "user": "certik",
            "date": "2020-01-14 20:35:44+00:00",
            "title": "Prepare fpm to run on Windows using Rust tests",
            "text": "",
            "comments": []
        },
        {
            "number": 9,
            "user": "certik",
            "date": "2020-01-14 17:06:48+00:00",
            "title": "Run all tests using \"cargo test\" only",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 17:40:14+00:00",
                    "text": "Unfortunately there seem to be random errors on macOS of the type:\n---- test_help stdout ----\nthread 'test_help' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"--help\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\nstack backtrace:\n   0: backtrace::backtrace::libunwind::trace\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\n   1: backtrace::backtrace::trace_unsynchronized\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\n   2: std::sys_common::backtrace::_print_fmt\n             at src/libstd/sys_common/backtrace.rs:77\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\n             at src/libstd/sys_common/backtrace.rs:61\n   4: core::fmt::write\n             at src/libcore/fmt/mod.rs:1028\n   5: std::io::Write::write_fmt\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/io/mod.rs:1412\n   6: std::io::impls::<impl std::io::Write for alloc::boxed::Box<W>>::write_fmt\n             at src/libstd/io/impls.rs:141\n   7: std::sys_common::backtrace::_print\n             at src/libstd/sys_common/backtrace.rs:65\n   8: std::sys_common::backtrace::print\n             at src/libstd/sys_common/backtrace.rs:50\n   9: std::panicking::default_hook::{{closure}}\n             at src/libstd/panicking.rs:188\n  10: std::panicking::default_hook\n             at src/libstd/panicking.rs:202\n  11: std::panicking::rust_panic_with_hook\n             at src/libstd/panicking.rs:464\n  12: std::panicking::continue_panic_fmt\n             at src/libstd/panicking.rs:373\n  13: std::thread::local::fast::Key<T>::try_initialize\n  14: assert_cmd::assert::Assert::success::{{closure}}\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148\n  15: core::option::Option<T>::unwrap_or_else\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/option.rs:419\n  16: assert_cmd::assert::Assert::success\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:147\n  17: cli::test_help\n             at tests/cli.rs:9\n  18: cli::test_help::{{closure}}\n             at tests/cli.rs:6\n\nThis error only happens sometimes. So there might be some bug in the assert_cmd package on macOS."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 21:41:03+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 8,
            "user": "scivision",
            "date": "2020-01-14 16:43:19+00:00",
            "title": "cmake_minimum_required => 3.14",
            "text": "fpm/src/main.rs\n    \n    \n         Line 38\n      in\n      bf8ee01\n    \n    \n    \n    \n\n        \n          \n           cmake_minimum_required(VERSION 3.5.0 FATAL_ERROR) \n        \n    \n  \n\n\nThe CMake syntax used in this Rust script requires at least CMake 3.13.\nIn general in the Fortran stdlib we currently planned to use CMake 3.14 minimum.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:15:15+00:00",
                    "text": "Yes, it needs to be 3.14. Is the FATAL_ERROR needed? It seems to fail fatally even without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:34:02+00:00",
                    "text": "This raises a broader issue about how should we handle minimum CMake version in fpm.\nShould we set a fixed minimum cmake version for all packages brought in by fpm (even if they are okay with an earlier version)? This seems like an unnecessary overkill to me.\nOr, should we let cmake do the work and have individual package builds fail if user's cmake is inadequate? I like this better.\nAre there other approaches?"
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 07:21:52+00:00",
                    "text": "if you intend to communicate with CMake beyond simple command line interaction, there was a significant improvement in CMake 3.14 adding a file based API. That would avoid having to implement that twice for CMake < 3.14 and the deprecated CMake server, if such communication is necessary for fpm.\nThis would allow for example to introspect CMake projects that don't use fpm, but are used by fpm."
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 16:35:19+00:00",
                    "text": "In my opinion the FATAL_ERROR parameter to cmake_minimum_version() can be omitted. It does nothing for CMake releases less than about 15 years old, and those with CMake that old would have trouble building almost anything for the past few years."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 19:21:08+00:00",
                    "text": "@scivision thanks. (I can't believe I've been using CMake longer than 15 years, but it seems I have...)\nRegarding the minimal version, it requires 3.14 for Windows, and I was thinking of simply using that for now everywhere.\nOnce fpm is further along, let's revisit this. Down the road I actually think fpm should be able to build things on its own, just like Cargo does it, which would be a lot faster (since cmake's configure phase can be pretty slow).\nFor now I just want to get some minimal product working, then we'll carefully revisit all these decisions."
                }
            ]
        },
        {
            "number": 7,
            "user": "certik",
            "date": "2020-01-14 15:46:23+00:00",
            "title": "CI: Test on Windows",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 16:10:13+00:00",
                    "text": "Tests pass, so I'll merge this. Futher work needs to be done on Windows, but this is a start."
                }
            ]
        },
        {
            "number": 6,
            "user": "certik",
            "date": "2020-01-14 06:08:41+00:00",
            "title": "How to support packages that do not conform to our \"standard layout\" (to be specified...)",
            "text": "How to support packages that do not conform to our \"standard layout\" (to be specified...). Some examples of such a package would be reference Lapack, or Arpack. The way to do that is that we create a new repository, say certik/lapack.fpm, which will have fpm.toml, in there it would specify the url to the actual sources (https://github.com/Reference-LAPACK/lapack) and a build script, which would build the sources (using CMake in this case) and install them into some $PREFIX provided by fpm and fpm takes it from there. This approach also works for non Fortran packages --- the build script either builds it, or requires it from the system (where it can be provided by, e.g., Spack). Either way this is a clean way to hook this up into the fpm ecosystem.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:40:11+00:00",
                    "text": "Yes, I think fpm.toml for each project should include the exact commands that need to be executed to build the package, very much like we do in yml files for CI.\nThat said, until a need arises, I'd suggest that we take this approach for all packages, including those built with CMake, autotools, or plain Makefiles.\nIf we can make a package build in CI, we should be able to build it by fpm by making it execute commands specified in fpm.toml.\n\nThe way to do that is that we create a new repository, say certik/lapack.fpm\n\nDoes this even need to be a separate repo? Are you thinking about a repo that would be the registry of all fpm-supported packages, like what I described in #4 ?"
                }
            ]
        },
        {
            "number": 5,
            "user": "certik",
            "date": "2020-01-14 06:08:04+00:00",
            "title": "Naming of `fpm.toml`",
            "text": "Naming of fpm.toml. Cargo names Cargo.toml with capital C, and as explained in https://doc.rust-lang.org/cargo/faq.html#why-cargotoml, to \"ensure that the manifest was grouped with other similar configuration files in directory listings. Sorting files often puts capital letters before lowercase letters, ensuring files like Makefile and Cargo.toml are placed together.\" If we want to do the same, the candidates are Fpm.toml and FPM.toml. I think fpm.toml looks better. But using a capital letter would make it similar to CMakeLists.txt also. We might want to devise a different name or naming scheme. Any ideas?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:30:36+00:00",
                    "text": "If we consider fpm.toml, I like it better than either Fpm.toml or FPM.toml. I see little value in the sorting argument.\nIf I think of any better names than fpm.toml, I will write here, but I think fpm.toml is just fine."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-01-15 08:25:24+00:00",
                    "text": "If I get it correctly in the Rust world libraries/packages are called crates, and the package manager called Cargo is responsible for shipping these crates?\nIn line with the Rust naming, if you don't mind playing with some old Fortran terminology, crates would become decks (as in punched card decks), and the Fortran package manager would be a box/package/drawer/folder/cabinet/chest/case/dealer/dispenser/pile/loader/...?.... Unfortunately none of these words really ring. The  fpm.toml acronym is also easy enough to remember.\nFrom Wikipedia:\n\n...a box of computer programs in punched card form from the early 1970s. The deck in the middle shows what a program deck looked like after extensive editing and debugging. The cardboard box was originally used to ship blank cards and held 2000 cards."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 05:22:26+00:00",
                    "text": "Thanks @ivan-pi for the ideas.\nI think a Rust package is simply called a crate, but even I am not 100% sure. For that reason I would recommend to simply call a package as a package, so that people know what that means.\nI agree, let's just use fpm.toml."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:28:15+00:00",
                    "text": "Should we close this now? We've implemented it as fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:31+00:00",
                    "text": "Yes, can be closed.\n\u2026\nOn Wed, Apr 29, 2020, at 9:28 PM, Brad Richardson wrote:\n\n\n Should we close this now? We've implemented it as `fpm.toml`.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#5 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEQACM33QVEE66CTT3RPDV5XANCNFSM4KGNRUOQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:05:50+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 4,
            "user": "certik",
            "date": "2020-01-14 06:07:30+00:00",
            "title": "Hosting of packages",
            "text": "Eventually we need to have a central place for packages similar to crates.io.\nBut for now we will use a git repository (GitHub, GitLab and other places will work) as well as just url for a tarball. That way we don't need to host anything ourselves at first and can get the initial community and ecosystem of packages built up without worrying about security and other issues that will come with maintaining our own repository.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:26:22+00:00",
                    "text": "Although worthwhile thinking ahead, I think we are far from this. It's a big technical challenge that requires dedicated hardware and person (people) if it's to work smoothly.\nIn the interim, as you describe, we can maintain a registry that provides all the info about available packages that fpm needs, but the source code of packages is hosted wherever its hosted by the package maintainers (GitHub, GitLab, custom url, whatever). The downside to this approach is that if the maintainer takes down the package, or changes the url, or GitHub is down, the package is unavailable through fpm. I think these are edge cases that we can live with and work around for a while, especially considering that Fortran's ecosystem is still fledgling.\nLet's discuss what would the registry look like. How about if we maintain a registry of fpm.toml files for each supported package in fpm's repo. Something like this:\nfpm/\n  Registry/\n    blas/\n      fpm.toml\n    lapack/\n      fpm.toml\n    stdlib/\n      fpm.toml\n    ...\n\nfpm.toml for a package includes all the info that fpm would need to build the package, including but not limited to:\n\nBuild backend such as CMake, autotools, or plan make\nGitHub, GitLab or custom url from which to download source code\nVersions available\nDependencies\nWhat else?\n\nFor a maintainer to add their package to fpm, they would open a PR in fpm to add their fpm.toml to the fpm Registry.\nAm I going in the right direction?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 05:13:52+00:00",
                    "text": "Actually, the registry would be just a list of urls to download the package, so:\nhttps://github.com/certik/lapack.fpm\nhttps://github.com/fortran-lang/stdlib\n...\n\nEach of these urls will be either a tarball, or a git repository. When you download it, it contains the fpm.toml file with all the metadata. And we'll have code that will simply download each package and extract the metadata to create a nice (static) webpage and to allow to search from a command line (fpm search) --- we can automatically prepare some JSON file with package name / description / url, etc., and host it at some github repo, and fpm would simply download it. (The registry might be a combination of version + url, because a single package can have multiple verisons, so one would use, e.g., git tags for different versions.)\nRegarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:38:34+00:00",
                    "text": "Can you explain why you need a separate (middle-man) repo for metadata, per package?\nIf fpm gets metadata from one repo, which would then instruct it to download the package tarball from a custom url and build it with some commands, then it would have to do that transaction every time you inquire about a package. To not query a remote repo on every command, you'd want to cache results, which basically means you'd be building a local registry of packages. But if you're building a local registry of packages, you might as well maintain the registry in one repo.\nMore problematically, without a local (or remote but aggregated) registry, how do you search for available packages? With Cargo I can do:\n$ cargo search blas\nblas = \"0.20.0\"                   # The package provides wrappers for BLAS (Fortran).\ncoaster-blas = \"0.2.0\"            # Coaster library for full BLAS support\nrust-blas = \"0.1.1\"               # BLAS bindings and wrappers, fork of rblas\ncollenchyma-blas = \"0.2.0\"        # Collenchyma library for full BLAS support\nblas-src = \"0.4.0\"                # The package provides a BLAS source of choice.\nrblas = \"0.0.13\"                  # BLAS bindings and wrappers\nblas-sys = \"0.7.1\"                # The package provides bindings to BLAS (Fortran).\ncuda_blas = \"0.1.0\"               # cuBLAS API bindings.\npopcorn-blas = \"0.1.0\"            # Popcorn BLAS: Broadcasting BLAS operations for Popcorn\nnetlib-blas-provider = \"0.0.8\"    # BLAS/LAPACK provider using the Netlib implementation\n... and 54 crates more (use --limit N to see more)\n\nWould fpm search only list urls? Or would it try to fetch metadata from any number of repos that match the pattern? This won't scale.\nLooking at my local .cargo/ directory, it doesn't seem like Cargo keeps an index of all packages locally (for many many packages this doesn't scale either) but fetches from a remote registry (I assume cargo.io)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:42:22+00:00",
                    "text": "Regarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants.\n\nAre you saying that for pure Fortran code (like stdlib at the moment), you wouldn't use a build system but do the build explicitly by directly invoking the compiler? In the long run I think this is a good choice but I'm worried that it'd be a big ordeal to implement because now you have to worry about building dependency trees and all the necessary stuff that CMake was doing for us.\nOr, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:37:45+00:00",
                    "text": "Or, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too.\n\nYes, that's how it is already implemented in this very small prototype of fpm. If you look here:\nhttps://github.com/fortran-lang/fpm/tree/master/tests/1\nAll you have to do is execute fpm build in that directory, and it will generate the proper CMakeLists.txt and build it and then fpm run will run the executable.\nThat's exactly how Cargo does it, and I think that's what we want also.\nAnd yes, I agree with you that using CMake as the vehicle to actually build it is the way to go initially. All fpm has to do is to construct it properly.\nIt already works, and my next step is to start doing the dependencies. Once we have a prototype of that, let's brainstorm how to host it properly. (Yes, I want fpm search to list names and descriptions just like Cargo does, so it needs to download some JSON description of all packages --- But what I am arguing is to maintain such JSON description automatically, not by hand, by downloading it from the actual packages --- we can discuss it later.)"
                }
            ]
        },
        {
            "number": 3,
            "user": "certik",
            "date": "2020-01-14 06:02:10+00:00",
            "title": "Remove GitLab-CI",
            "text": "We will use GitHub and its CI from now on.",
            "comments": []
        },
        {
            "number": 2,
            "user": "certik",
            "date": "2020-01-14 05:43:25+00:00",
            "title": "Build and run Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 06:00:39+00:00",
                    "text": "Tests pass, merging."
                }
            ]
        },
        {
            "number": 1,
            "user": "certik",
            "date": "2020-01-14 05:38:24+00:00",
            "title": "Add GitHub CI",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 05:40:20+00:00",
                    "text": "I think it has to be merged first in order to run."
                }
            ]
        }
    ]
}